<roblox version="4">
  <Item class="Folder" referent="0">
    <Properties>
      <string name="Name">DragonEngine</string>
      <string name="Name">DragonEngine</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">Boilerplate</string>
        <string name="Source">--[[
	Required boilerplate functions for the engine.
]]

local BoilerPlate={}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Recurse
-- @Description : Returns all items in a folder/model/table and all of its subfolders/submodels/subtables.
--                If it is a table, it returns all items in a table and all items in all of its sub-tables.
-- @Params : Instance &lt;Folder>/table "Root" - The folder/table to recurse through.
-- @Returns : table "Items" - A table containing all of the items.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function BoilerPlate.Recurse(Root)
	local Items={}

	if typeof(Root)=="Instance" then --Root is an instance, make sure it is a model or a folder.

		if Root:IsA("Model") or Root:IsA("Folder") then --It's a folder or a model.
			for _,Object in pairs(Root:GetChildren()) do
				if Object:IsA("Folder") then --Recurse through this subfolder.
					local SubObjects=BoilerPlate.Recurse(Object)
					for _,SubObject in pairs(SubObjects) do
						table.insert(Items,SubObject)
					end
				else --Just a regular instance, add it to the items list.
					table.insert(Items,Object)
				end
			end
		end

	elseif typeof(Root)=="table" then --Root is a table.

		for _,Item in pairs(Root) do
			if typeof(Item)=="table" then --Recurse through this subtable.
				local SubItems=BoilerPlate.Recurse(Item)
				for _,SubItem in pairs(SubItems) do
					table.insert(Items,SubItem)
				end
			else --Just a regular value, add it to the items list.
				table.insert(Items,Item)
			end
		end

	end

	return Items
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : RecurseFind
-- @Description : Returns all items of a given type in a folder/model and all of its subfolders/submodels.
--                If it is a table, it returns all items of a given type in a table and all items in all of its
--                sub-tables.
-- @Params : Instance &lt;Folder>/table "Root" - The folder/table to recurse through.
--           Variant "ItemType" - The type of the item to search for.
-- @Returns : table "Items" - A table containing all of the found items.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function BoilerPlate.RecurseFind(Root,ItemType)
	local Items={}

	if typeof(Root)=="Instance" then
		if Root:IsA("Folder") or Root:IsA("Model") then
			for _,Item in pairs(BoilerPlate.Recurse(Root)) do
				if Item:IsA(ItemType) then 
					table.insert(Items,Item) 
				end
			end
		end
	elseif typeof(Root)=="table" then
		for _,Item in pairs(BoilerPlate.Recurse(Root)) do
			if typeof(Item)==ItemType then 
				table.insert(Items,Item) 
			end
		end
	end

	return Items
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : RecurseFilter
-- @Description : Returns all items that are NOT a given type in a folder/model and all of its subfolders/submodels.
--                If it is a table, it returns all items that are NOT a given type in a table and all items in all
--                of its sub-tables.
-- @Params : Instance &lt;Folder>/table "Root" - The folder/table to recurse through.
--           Variant "ItemType" - The type of the item to filter.
-- @Returns : table "Items" - A table containing all of the filtered items.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function BoilerPlate.RecurseFilter(Root,ItemType)
	local Items={}

	if typeof(Root)=="Instance" then
		if Root:IsA("Folder") or Root:IsA("Model") then
			for _,Item in pairs(BoilerPlate.Recurse(Root)) do
				if not Item:IsA(ItemType) then 
					table.insert(Items,Item) 
				end
			end
		end
	elseif typeof(Root)=="table" then
		for _,Item in pairs(BoilerPlate.Recurse(Root)) do
			if typeof(Item)~=ItemType then 
				table.insert(Items,Item) 
			end
		end
	end

	return Items
end

return BoilerPlate</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="2">
      <Properties>
        <string name="Name">EngineCore</string>
        <string name="Source">--[[
	Dragon Engine Core

	Global backend engine for Phoenix Entertainment, LLC.

	Programmed, designed and developed by @Reshiram110
	Inspiration by @Crazyman32's 'Aero' framework
--]]

---------------------
-- Roblox Services --
---------------------
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--------------
-- REQUIRES --
--------------
local Boilerplate = require(ReplicatedStorage.DragonEngine.Boilerplate)

-------------
-- DEFINES --
-------------
local DragonEngine = {
	Modules = {}, --Holds all of the loaded modules
	Enum = {}, --Contains all custom Enums.
	Config = {}, --Holds the engines settings.

	Version = "0.1.0" --TODO : Replace this with a valueobject that stores the latest git tag inside it via remodel.
}

local ModuleLocations = {} -- Stores the locations of modulescripts to be lazy-loaded

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Boilerplate
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
local function IsModuleIgnored(Module)
	for _,ModuleName in pairs(DragonEngine.Config.Settings.IgnoredModules) do
		if ModuleName == Module.Name then
			return true
		end
	end

	return false
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : GetOutput
-- @Description : Returns output from the engine.
-- @Params : Variant "Value" - The value(s) for the engine to return from this call.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DragonEngine:GetOutput(...)
	local Values = {...}
	local OutputString = "{"

	for Index,Param in pairs(Values) do
		OutputString = OutputString..tostring(Param)
		if Values[Index+1] ~= nil then 
			OutputString = OutputString..", " 
		end
	end
	OutputString = OutputString.."}"
	return "DRAGON_ENGINE_OUTPUT -> "..OutputString
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- ENGINE LOGGING
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Log
-- @Description : Adds the specified text to the engine logs.
-- @Params : string "LogMessage" - The message to add to the logs
--           DragonEngine Enum "LogMessageType" - The type of message being logged
-- @TODO : Design and implement custom logging system with UI
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DragonEngine:Log(LogMessage,LogMessageType)
	if LogMessage == nil then
		print("")
		return
	end
	if LogMessageType == "warning" or LogMessageType == "Warning" then
		warn("[Dragon Engine Server] "..LogMessage)
	elseif LogMessageType == "error" or LogMessageType == "Error" then
		error("[Dragon Engine Server] "..LogMessage)
	else
		print("[Dragon Engine Server] "..LogMessage)
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : DebugLog
-- @Description : Adds the specified text to the engine logs, and will only dispay if debug is set to true.
-- @Params : string "LogMessage" - The message to add to the logs
--           DragonEngine Enum "LogMessageType" - The type of message being logged
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DragonEngine:DebugLog(LogMessage,LogMessageType)
	if DragonEngine.Config.Settings.Debug then
		if LogMessage == nil then
			print("")
			return
		end
		if LogMessageType == "warning" or LogMessageType == "Warning" then
			warn("[Dragon Engine Server] "..LogMessage)
		elseif LogMessageType == "error" or LogMessageType == "Error" then
			error("[Dragon Engine Server] "..LogMessage)
		else
			print("[Dragon Engine Server] "..LogMessage)
		end
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Modules
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : GetModule
-- @Description : Gets and returns the specified module from the framework
-- @Params : string "ModuleName" - The name of the module to get from the framework
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DragonEngine:GetModule(ModuleName)

	----------------
	-- Assertions --
	----------------
	assert(ModuleName ~= nil,"[Dragon Engine] GetModule() : string expected for 'ModuleName', got "..typeof(ModuleName).." instead.")

	return self.Modules[ModuleName]
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : LoadModule
-- @Description : Loads the specified module into the framework
-- @Params : Instance &lt;ModuleScript> 'Module' - The module to load
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DragonEngine:LoadModule(Module)

	----------------
	-- Assertions --
	----------------
	assert(Module ~= nil,"[Dragon Engine Server] LoadModule() : ModuleScript expected for 'Module', got nil instead.")
	assert(typeof(Module) == "Instance","[Dragon Engine Server] LoadModule() : ModuleScript expected for 'Module', got "..typeof(Module).." instead.")
	assert(Module:IsA("ModuleScript"),"[Dragon Engine Server] LoadModule() : ModuleScript expected for 'Module', got "..Module.ClassName.." instead.")
	assert(rawget(self.Modules,Module.Name) == nil,"[Dragon Engine Server] LoadModule() : A module with the name '"..Module.Name.."' is already loaded!")

	-------------
	-- Defines --
	-------------
	local ModuleName = Module.Name
	local LoadedModule; --Table holding the class

	-----------------------
	-- Loading the class --
	-----------------------
	self:DebugLog("Loading module '"..ModuleName.."'...")
	local Success,Error = pcall(function() --If the module fails to load/errors, we want to keep the engine going
		LoadedModule = require(Module)
	end)
	if not Success then
		self:Log("Failed to load module '"..ModuleName.."' : "..Error,"Warning")
		return false,Error
	else
		self.Modules[ModuleName] = LoadedModule
		self:DebugLog("Loaded module '"..ModuleName.."'.")
		return true
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : LazyLoadModulesIn
-- @Description : Lazy-loads all modules in the given container into the framework
-- @Params : Instance variant 'Container' - The container to lazy-load the modules from
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DragonEngine:LazyLoadModulesIn(Container)

	----------------
	-- Assertions --
	----------------
	assert(typeof(Container) == "Instance","[Dragon Engine Core] LazyLoadModulesIn() : Instance expected for 'Container', got "..typeof(Container).." instead.")

	table.insert(ModuleLocations,Container)
	self:DebugLog("All modules in '"..Container:GetFullName().."' will be lazyloaded.")
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- ENUMS
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : DefineEnum
-- @Description : Creates an enum with the given name.
-- @Params : string "EnumName" - The name of the enum
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function DragonEngine:DefineEnum(EnumName,EnumTable)

	local function GetEnumItems(CustomEnum)
		local EnumItems = {}

		for _,EnumItemValue in pairs(CustomEnum) do
			if type(EnumItemValue) == "table" then
				for _,v in pairs(GetEnumItems(EnumItemValue)) do
					table.insert(EnumItems,v)
				end
			else
				table.insert(EnumItems,EnumItemValue)
			end
		end

		return EnumItems
	end


	self.Enum[EnumName] = EnumTable
end

--------------------------------
-- Listening for module calls --
--------------------------------
setmetatable(DragonEngine.Modules,{
	__index = function(_,Key)
		for _,ModuleLocation in pairs(ModuleLocations) do
			for _,ModuleScript in pairs(Boilerplate.RecurseFind(ModuleLocation,"ModuleScript")) do
				if ModuleScript.Name == Key then
					if not IsModuleIgnored(ModuleScript.Name) then
						DragonEngine:DebugLog("Lazy-loading module '"..ModuleScript.Name.."'...")
						local LoadSuccess = DragonEngine:LoadModule(ModuleScript)

						if LoadSuccess then
							return DragonEngine:GetModule(ModuleScript.Name)
						else
							DragonEngine:DebugLog("Failed to lazy-load module '"..ModuleScript.Name.."'","Warning")
							return nil
						end
					end
				end
			end
		end
	end
})

return DragonEngine</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="3">
      <Properties>
        <string name="Name">Logo</string>
        <string name="Source">return [[
	
	                                                                 ...::::::::::::.::...                                                                
                                                       . ..:.:::.:.::::::::::::.::::.::::.:.:.                                                        
                                                  :.::::.:.:.:::.:::::::::::::.:::.:.::.:.:.::::::.:..                                                
                                             .::::.:::::.:.:.:::::.:::::.:::.:.:.:.:.:.:.:.:::::::.:::.:.:                                            
                                        :.::::::::.:::::...                                ..:::::::.:.::::::.:                                       
                                     .:.::::::::.:.:                                              ..:.:::::::::.:..                                   
                                  .::.:.:::::::..                                                     ..::::::.:.::..                                 
                               .:.:::.:.::.:                                                               ::.:.:.:::::.                              
                            .::.:.:::.:.                                                                       .:::::::.::.                           
                          .:::.:.:::.                                                                             .::.:.::::.                         
                       ..::::.:.::                                                                                  .:.::::.:.:                       
                     .:.:::::.:.                                               :.                                      .:::.:.::.                     
                    :::.::::..                                               .::..                                       ..::.:.:::                   
                  .::::.::.                                                 .::::.                                  .:..   ..:.::::.:                 
                .:.::::.:.                                                .:::::..              . .:..:..:..:.:.:::.:.:      ..::::::..               
               ::.::::.                                                 .:::::.:.       .::.:::::.::::.:.:.:.:.:::.:.:         .:::::::.              
             .::.:::..                                               ..:::::.:.:     ..::::::::::.:::.:.:.:.:.:::.:.          ..:::::::.:.            
            .:::::.:                                                .::::::.:.:.    .::::::::::.::::.:.:.:.:.:::..          ..:::::::::.:..           
           .::::.:.                                              .:::::::.:.:::    .:::::::::.::::::.:.:.:.:.            .::.::::::::::.:::..         
          :::::.::                                            ..::::::::.:.:.     .::::::::.:::::::..              ..:::::.::::::::::::::.:.:         
        .::::::.                                            .:::::::::.:.:.:.     :..                      .:..:.:::::::.:::::::::::::::.:.:::.       
        ::.::::                                          .:.:::::::::.:.:..                        .:::.::.::::.:::::::.::::::::::::::.:.:.::::       
       :.:.::.                                        .::.:::::::::.:.:.:.                          ..:.::::::.::::::.:.:::::::::::::.:  .::::.:      
     .:.:.:::                                      .::.:::::::::::.:.:.: .:.:.::.:.:.:.:.:..:.           .::.:::::::.:.:::::::::::::.     ::::.:.     
     ::.:.::.                                    .::::.::::::::::.:.:.:.:.:.::::.:.:.:.::::.:.::::.:.        :::::.:.:::::::::.:.         .:::.:.:    
    .::.:.:                                    .::::::.::::::::.:.:.:.:.:.::::::.:.:.::::::.:.::.:::::.:..                              .:.:::.:::.   
   .::.:.:                                   .::::::.:.::::::.:.:.:.:.:.::::::::.:.:.::::.:.:.:.::::.:.:::.:.                       ..:::.:::.:::::   
   :.:.:.:                                 ..:.::::.:.:::::.:.:.:.:.:.::::::::::.:.:.:::.:.:.:.:::::.:::.:.::::          . . ..:.:.::.:::.:::.:::::.  
  ..:.:.:.                                .::.:.:::.::::::.:.:.:.:.:.:::::::::.:.:.:.:::.:.:.:.:::::::.:.:.:::.::.      :::::.:.:.:::::::.:::.::::.:. 
  .:.:.:.                               .:.:::.::::.::::.:.:.:.:.:.:::::::::.:.:.:.:.:::.:.:.:.::::::.:.:.:::.:::::..     :::.:.:::::::.:.:::.:::.::. 
  .:.:.:                              :.:.::::.::.:.:::.:.:.:.:.:.:::::::::.:.:.:.:.:::.:.:.:.:::::.:.:.:::.:.:::::.:.:    .:.:.:::::::.:.:::..::.:::.
 ::.::.:                            :.::.:::::.:.:.:::.:.:.:.:.:.::::::::.:.:.:.:.:::.:.:.:.::::::.:.:.::::.:.:::::.:.::.    :.::::::::.:.:.   ::.:::.
 :.::::.                          .::.:.::::::.:.:::.:.:.:.:.:.:.::::::.:.:.:.:.:.:::.:.:.:.::::.:.:.::::::.:.:::::.:.::::     ::::::.:        .:.:::.
.:.::::                         .::.:.::::::::.:::.:.:.:.:.:.:.:.::::.:.:.:.:.:.:.:::.:.:.:.:::.:.:.:::::.:.:.:::::..                         ..:.:::.
:.:::::                       .:.:::.:::::::.:..   .:.:.:.:.:.:.::::.:.:.:.:.:.:.::::.:.:.:.:::.:.::::::.:.:.::::::.:.                    ..:::.:.::::
::::::.                      .:.::::.:::::::.    .::.:.:.:.:.:.:::::.:.:.:.:.:.::::::.:.             ..:.:.::::::::.::.:     ::::.:::::::.:.:::.:.::::
:::::..                         ::::.:::::     .::.:.:.:.:.:.:.:::::.:.:.:.:.:.:..      ..:.:.:..          .:::::.:.:::::.     .::::::::.:.::::.:.::.:
::::::.                        .::::.::::. .:::::::.:.:.:.:.:.::::::.:.:.:..       .:::::.:.::::.:::.:..       :.:.:::::.:::.     ..::.:.::::::.:.:.:.
::::::.                       .:::.:::::::.::::::.:.:.:.:.:.::::::::.:.:..                 .:.:.:.:.:::.::.       :.::.:.:::.:.      ...:::::.:.:.:.::
:::::.:                       .::.::::::.:.::::.:.:.:.:.:.:.::::::.:.:.::                         .:::.:::::::.       :.::::.:::.:..            .::.::
::::::.                     .::.::::::::.:.::.:.:.:.:.:.:.:.:::::.:.:.:::::       .:::::::::.:.      .:::::::::::.        .:.:::.:.::.:.:. .    :.::::
::::.::                    .:.::::::::::.:.:.:.:.:.:.:.:.:.::::::.:.:.::.           .::::::.:::.:.      ::::::::::.:          ..:.::::.:.:      ::.::.
.:::.::.          .       ::.:::::::::::.:.:.:.:.:.:.:.:.::::::::.:.::                 .::.::::::::.      :::::::.:::..                        .:::.:.
 .::.::.          :.:   ..::.:::::::::::.:.:.:.:.:.:.:.:.::::::.:.::                     .::::::::.:::     .::::.::::::..                     :::.:.:.
 ::.:.::         .:::::::.:.::::::::::::.:.:.:.:.:.:.:.:.:::::.:.::.                       ::::::.:.::.:     .::.::::.::::.       ...:.:..:.::.::.:.:.
 .:.:.::         :::::::.:.:::::::::::::.:.:.:.:.:.:.:.:.:::::.::::..                       :::::.:.:.::..    .:.:::.::::::::       .:.:.:.:::.:.:.:..
  .:.:::.       .:::::.:.:.:::::::::::::.:.:.:.:.:.:.:.:.:::::.:::::.                        ::::.:.::::..      .:::.:::::.:::..      ..:.:::.:.:.:.: 
  .:.::.:.      .:::.:.:.:.:::::::::::::.:.:..:..:.:.:.:                                     ::::.:::::.         .::.:::::.:::.:.:        ..:.:.:.:.. 
   .:.:.:.       :.:.:.:.:.:::::::::::::.              .                                     .::.:::::.   .:.      :.:::::.:::.:::.:         .:.:.:.  
   .::.:.:.      ::.:.:.:.:::::::::::::                                                      .:.:::::   ..::.:      .:::.:.:::::.:::.:      .:.:.:.   
    .::.:::.     .:::.:.:::::::::::::                                                        ::.::.   :.:.:.:::       ::.:   ...::.::.     .::.:.:.   
     .::::.:.     ..  .::::::::::::..                                                       .::.    .::.:.:::::        .::.               .:.:.:::    
     .::.:.::.         .:::::::::.:.                                                       .       .:::.:::::::..        :.:.             .::.::.     
      .:.:::::.         :.::::::.:.:.                                                               ::::::::::.::.         .:.           .:::.::      
       .:::::.:.          .:::::.:.:.:.                                                             ::::::::::.::.           .:.        .:::.::       
        :::.:.::..           :::.:.::::::                                                           .:::::::::.:::.                    :::::.:.       
         .:.:.:.::.               ..:::.::.:                                                        .:::::::::.:::.     ..           .::::::.         
          ..:.:.::.:                                                                                .:::::::.::::.:.     :::.       :.::::::.         
            .:.:.:.::.                                                                              .::::::.:::::::.     :.:.:::. :.:::.::.           
             .:.:.:.:::.                                                                           .::.::::.::::::.:     ::.:::.:::.:::.::            
               ::.:::.:::.                                                                         .::.:::.:::::.:::     :.:::.:::.::::.              
                .::::.::.::..                                                                      :.:.::::::::.::::.    .::::::.:.:::.               
                  .:.:.:.:.::..                                                                    ::.:::::::.:.:::..     ::::.:.:.::                 
                   ..:.:.::::.::.                                                                 .::::::::.:.:.::::.    ::::.:.:.:                   
                      .::::::.:.::.:                                                             .:.:::::.:.:.:.::.:.  ..::::.:.:                     
                       .:::::.:.:.:::.:.                                                        .:.::::::.:.:.:.:.:::::.:.:::.:                       
                          :::.:.::::.:::::..                                                    .::::::::.:.:.:.::::::.:.:::.                         
                            :.::::::.:::::.:::..                                              .::::::::.:.:.:.::::::::.::::                           
                               :::::.:::::.:.:.::.:.:..                                      .:::::::.:.:.:.::::::::::..                              
                                 .::.:::::.:.:.:.:.:.:::.::.:.:..:.:..:..:.:.:.:.:.::..    .::::::::.:.:.:.:::::::::.                                 
                                    ..::::.:.:.:.:.:.:::.:::.::::.:::.:.:.:.:::.:.:.:     .:::::::.:.:.:.::::::::..                                   
                                        .:.:.:.:.:.:.:::.:::.:::.:::.:.:.:.:::.:.:..    :::.:::::.:.:.:.:::::::                                       
                                            ..:.:.:.:::.::::.:::.:::.:.:.:.:::.:.:.:.::.::.::::::.:.:.:.::                                            
                                                 ..::.:.::.:.:::.:::.:.:.:.:::.:.:::::::.::::::::.:.:.                                                
                                                       ....:.:::.:::.:.:.:.:::.:::::::.:::::.:..                                                      
]]</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="4">
      <Properties>
        <string name="Name">Settings</string>
      </Properties>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">ClientPaths</string>
          <string name="Source">--[[
	Clientpaths

	Contains resource paths for the client sided engine.
]]

---------------------
-- Roblox Services --
---------------------
local ReplicatedStorage=game:GetService("ReplicatedStorage")
local StarterPlayer = game:GetService("StarterPlayer")

return {
	ModulePaths = {
		Shared = {
			ReplicatedStorage.DragonEngine.lib.Classes,
			ReplicatedStorage.DragonEngine.lib.Utils
		}
	},

	ControllerPaths = {
		StarterPlayer.StarterPlayerScripts.DragonEngine.Controllers
	}
}</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">EngineSettings</string>
          <string name="Source">--[[
	Dragon Engine settings module
	
	This module contains all the configurable settings for the engine.
	Please note that any misconfigurations may crash the engine.
	
	SETTINGS
	========
	ShowLogoInOutput (Bool) : Determines whether or not the dragon engine logo is displayed apon startup.
	
	Debug (Bool) : Determines whether or not any debug output displayed via DragonEngine:DebugLog() will be displayed.
	
	LogMaxLength (Int) : The max amount of logs to store.

	Enums (Table) : Contains all custom enum values.
--]]

return{
	ShowLogoInOutput = false,
	Debug = false,

	IgnoredModules = {"ExampleService","ExampleController"},

	["Enums"]={
		["ServiceResponse"]={
			["BadRequest"]="ERR_BAD_REQUEST",
			["ServerError"]="ERR_INTERNAL_SERVER_ERROR",
			["RequestGranted"]="REQUEST_GRANTED",
			["RequestDenied"]="REQUEST_DENIED",
			["OperationSuccess"]="OPERATION_SUCCESS",
			["OperationFailed"]="OPERATION_FAILED",
		}
	}
}</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">ServerPaths</string>
          <string name="Source">--[[
	ServerPaths

	Contains resource paths for the server sided engine.
]]

---------------------
-- Roblox Services --
---------------------
local ServerScriptService= game:GetService("ServerScriptService")
local ReplicatedStorage=game:GetService("ReplicatedStorage")

return {
	ModulePaths = {
		Shared = {
			ReplicatedStorage.DragonEngine.lib.Classes,
			ReplicatedStorage.DragonEngine.lib.Utils
		}
	},

	ServicePaths = {
		ServerScriptService.DragonEngine.Services
	}
}</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="8">
      <Properties>
        <string name="Name">lib</string>
      </Properties>
      <Item class="Folder" referent="9">
        <Properties>
          <string name="Name">Classes</string>
        </Properties>
        <Item class="ModuleScript" referent="10">
          <Properties>
            <string name="Name">AudioPlayer</string>
            <string name="Source">--[[
	Audio Player

	Acts as a 'music player', allowing the easy deployment of audio on the client and server.

	Programmed by @Reshiram110
]]

local AudioPlayer={}

---------------------
-- Roblox Services --
---------------------
local HttpService=game:GetService("HttpService")
local TweenService=game:GetService("TweenService")

-------------
-- DEFINES --
-------------
local CLASS_DEBUG=false --Determines whether or not debug output will be displayed.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- DEBUG CLASS METHODS
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : SpitPlaylist
-- @Description : Spits the playlist table to the output in JSON format.
-- @Example : AudioPlayer:SpitPlaylist()
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:SpitPlaylist()
	for Index=1,#self.Playlist do
		if self.PlaylistPosition~=Index then
			print(Index.." :   "..HttpService:JSONEncode(self.Playlist[Index]))
		else
			print(Index.." : ->"..HttpService:JSONEncode(self.Playlist[Index]))
		end
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- CLASS METHODS
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : new
-- @Description : Creates and returns a new instance of the audioplayer class.
-- @Returns : table "NewAudioPlayer" - The new instance of the audio player.
-- @Example : local MyAudioPlayer=AudioPlayer.new()
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer.new()
	local NewAudioPlayer={

		--[[ Properties ]]--
		Name="AudioPlayer",

		Playlist={}, --Contains all of the information about the different sounds
		PlaylistPosition=0, --The current position in the playlist.

		CurrentAudio={ --Information about the current song
			Name="",
			ID="rbxassetid://0",
			--AudioOptions={} --Contains properties and other options for the audio.
		},

		AutoPlay=false, --Determines whether or not the audioplayer will autoplay when moving to a new index in the playlist.
		Looped=false, --Determines whether or not the audioplayer will loop through the playlist.

		Sound=Instance.new('Sound',Workspace),

		_Destroyed=false, --Used to prevent further usage after this object is destroyed.

		--[[ Events ]]--
		_Events={
			AudioAdded=Instance.new('BindableEvent'), --Fired when an audio is added to the playlist.
			AudioRemoved=Instance.new('BindableEvent'), --Fired when an audio is removed from the playlist.
		}

	}
	NewAudioPlayer.AudioAdded=NewAudioPlayer._Events.AudioAdded.Event
	NewAudioPlayer.AudioRemoved=NewAudioPlayer._Events.AudioRemoved.Event
	setmetatable(NewAudioPlayer,{__index=AudioPlayer})

	NewAudioPlayer.Sound.Ended:connect(function()
		if NewAudioPlayer.AutoPlay then
			NewAudioPlayer:Next()
		end
	end)

	return NewAudioPlayer
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Destroy
-- @Description : Destroys the audio player.
-- @Example : AudioPlayer:Destroy()
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:Destroy()
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] Destroy() : Cannot destroy an already destroyed audioplayer.")

	self._Destroyed=true

	--[[ Clean up instances ]]--
	self.Sound:Destroy()
	for _,BindableEvent in pairs(self._Events) do
		BindableEvent:Destroy()
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : AddAudioAtIndex
-- @Description : Adds an audio with the given name and ID at the specified playlist index to the playlist.
-- @Params : int "IndexNumber" - Then index of the song to add to the playlist.
--           string "AudioName" - The name to assign to the audio being added.
--           string "ID" - The rbxasset id of the audio being added.
-- @Example : AudioPlayer:AddAudioAtIndex(#AudioPlayer.Playlist+1,"LobbyMusic","18300397")
--            AudioPlayer:AddAudio(#AudioPlayer.Playlist+1,"LobbyMusic","rbxassetid://183003997")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:AddAudioAtIndex(IndexNumber,AudioName,ID)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] AddAudioAtIndex() : Cannot add audio to destroyed audioplayer.")
	assert(IndexNumber~=nil,"[Audio Player '"..self.Name.."'] AddAudioAtIndex() : IndexNumber expected, got nil.")
	assert(typeof(IndexNumber)=="number","[Audio Player '"..self.Name.."'] AddAudioAtIndex() : number expected for IndexNumber, got "..typeof(IndexNumber).." instead.")
	if IndexNumber~=1 then
		assert(self.Playlist[IndexNumber-1]~=nil,"[Audio Player '"..self.Name.."'] AddAudioAtIndex() : Index out of bounds.")
	end
	assert(AudioName~=nil,"[Audio Player '"..self.Name.."'] AddAudioAtIndex() : AudioName expected, got nil.")
	assert(typeof(AudioName)=="string","[Audio Player '"..self.Name.."'] AddAudioAtIndex() : string expected for AudioName, got "..typeof(AudioName).." instead.")
	assert(ID~=nil,"[Audio Player '"..self.Name.."'] AddAudioAtIndex() : Audio ID expected, got nil.")
	assert(typeof(ID)=="string","[Audio Player '"..self.Name.."'] AddAudioAtIndex(): String expected for ID, got "..typeof(ID).." instead.")
	assert(self:FindAudioByName(AudioName)==false,"[Audio Player '"..self.Name.."'] AddAudioAtIndex() : An audio with the name '"..AudioName.."' already exists!")

	----------------------
	-- Adding the audio --
	----------------------
	if string.find(ID,"rbxassetid://")==nil then
		ID="rbxassetid://"..ID
	end
	table.insert(self.Playlist,IndexNumber,{
		Name=(AudioName or "NewAudio"),
		ID=ID,
	})

	------------------------------------------------
	-- Update current audio and playlist position --
	------------------------------------------------
	if IndexNumber&lt;=self.PlaylistPosition then --Adjust playlist position to point to current audio.
		self.PlaylistPosition=self.PlaylistPosition+1
	end
	if self.PlaylistPosition==0 then --First audio added.
		self:JumpToIndex(1)
	end

	if CLASS_DEBUG then
		print("")
		print("[Audio Player '"..self.Name.."'] Audio added.")
		print("Added audio : "..HttpService:JSONEncode(self.Playlist[IndexNumber]))
		print("New audio list :")
		self:SpitPlaylist()
		print("")
	end

	self._Events.AudioAdded:Fire(AudioName,IndexNumber)
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : AddAudio
-- @Description : Adds an audio with the given name and ID at the end of the playlist.
-- @Params : string "AudioName" - The name to assign to the audio being added.
--           string "ID" - The rbxasset id of the audio being added.
-- @Example : AudioPlayer:AddAudio("LobbyMusic","18300397")
--            AudioPlayer:AddAudio("LobbyMusic","rbxassetid://183003997")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:AddAudio(AudioName,ID)
	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] AddAudio() : Cannot add audio to destroyed audioplayer.")
	assert(AudioName~=nil,"[Audio Player '"..self.Name.."'] AddAudio() : AudioName expected, got nil.")
	assert(typeof(AudioName)=="string","[Audio Player '"..self.Name.."'] AddAudio() : string expected for AudioName, got "..typeof(AudioName).." instead.")
	assert(ID~=nil,"[Audio Player '"..self.Name.."'] AddAudio() : Audio ID expected, got nil.")
	assert(typeof(ID)=="string","[Audio Player '"..self.Name.."'] AddAudio(): String expected for ID, got "..typeof(ID).." instead.")
	assert(self:FindAudioByName(AudioName)==false,"[Audio Player '"..self.Name.."'] AddAudioAtIndex() : An audio with the name '"..AudioName.."' already exists!")

	------------------------
	-- Adding the audio --
	------------------------
	self:AddAudioAtIndex(#self.Playlist+1,AudioName,ID)
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : RemoveAudioAtIndex
-- @Description : Removes an audio at the specified playlist index from the playlist.
-- @Params : int "IndexNumber" - Then index of the song to remove from the playlist.
-- @Example : AudioPlayer:RemoveAudioAtIndex(2)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:RemoveAudioAtIndex(IndexNumber)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] RemoveAudioAtIndex() : Cannot remove audio from destroyed audioplayer.")
	assert(IndexNumber~=nil,"[Audio Player '"..self.Name.."'] RemoveAudioAtIndex() : IndexNumber expected, got nil.")
	assert(typeof(IndexNumber)=="number","[Audio Player '"..self.Name.."'] number expected for IndexNumber, got "..typeof(IndexNumber).." instead.")
	assert(self.Playlist[IndexNumber]~=nil,"[Audio Player '"..self.Name.."'] RemoveAudioAtIndex() : Index out of bounds.")

	-------------
	-- DEFINES --
	-------------
	local AudioName=self.Playlist[IndexNumber].Name

	------------------------
	-- Removing the audio --
	------------------------
	if CLASS_DEBUG then
		print("")
		print("[Audio Player '"..self.Name.."'] Audio removed.")
		print("Removed audio : "..HttpService:JSONEncode(self.Playlist[IndexNumber]))
	end

	table.remove(self.Playlist,IndexNumber)

	------------------------------------------------
	-- Update current audio and playlist position --
	------------------------------------------------
	if IndexNumber&lt;self.PlaylistPosition then --Adjust playlist position to point to current audio.
		self.PlaylistPosition=self.PlaylistPosition-1
	elseif IndexNumber==self.PlaylistPosition then --Current audio was removed.
	    if #self.Playlist==0 then --Destroyed audio was the only audio in the playlist.
			self.CurrentSong={Name="",ID="rbxassetid://0"}
			self.PlaylistPosition=0
		elseif self.PlaylistPosition>#self.Playlist then --Destroyed audio was last in playlist.
			self:JumpToIndex(#self.Playlist)
		else
			self:JumpToIndex(self.PlaylistPosition)
		end
	end

	if CLASS_DEBUG then
		print("New audio list :")
		self:SpitPlaylist()
		print("")
	end

	self._Events.AudioRemoved:Fire(AudioName,IndexNumber)
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : RemoveAudio
-- @Description : Removes an audio with the given name from the playlist.
-- @Params : string "AudioName" - The name of the audio to be removed from the playlist.
-- @Example : AudioPlayer:RemoveAudio("LobbyMusic")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:RemoveAudio(AudioName)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] RemoveAudio() : Cannot remove audio from destroyed audioplayer.")
	assert(AudioName~=nil,"[Audio Player '"..self.Name.."'] RemoveAudio() : Name expected, got nil.")
	assert(typeof(AudioName)=="string","[Audio Player '"..self.Name.."'] RemoveAudio() : string expected for Name, got "..typeof(AudioName).." instead.")

	-------------
	-- DEFINES --
	-------------
	local AudioFound,AudioIndex=self:FindAudioByName(AudioName)

	------------------------
	-- Removing the audio --
	------------------------
	assert(AudioFound==true,"[Audio Player '"..self.Name.."'] RemoveAudio() : Could not remove audio '"..AudioName.."', audio was not found.")
	self:RemoveAudioAtIndex(AudioIndex)
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : RemoveAllAudio
-- @Description : Removes all audio from the playlist.
-- @Example : AudioPlayer:RemoveAllAudio()
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:RemoveAllAudio()

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] RemoveAudio() : Cannot remove audio from destroyed audioplayer.")

	------------------------
	-- Removing all audio --
	------------------------
	for Count=1,#self.Playlist do
		self:RemoveAudioAtIndex(1)
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Play
-- @Description : Plays the audio that is at the current playlist position.
-- @Params : OPTIONAL table "AudioSettings" - A dictionary table containing the properties to apply to the audio.
--                                            Can also include a tween.
-- @Example : AudioPlayer:Play({
--                Volume=0,
--                Tween={
--                    TweenInfo.new(5,Enum.EasingStyle.Linear),
--                    {Volume=1}
--                }
--            })
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:Play(AudioSettings)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] Play() : Cannot play an audio of a destroyed audio player.")
	if AudioSettings~=nil then
		assert(typeof(AudioSettings)=="table","[Audio Player '"..self.Name.."'] Play() : table expected for AudioSettings, got "..typeof(AudioSettings).." instead.")
	end

	-----------------------
	-- Playing the audio --
	-----------------------
	self:Stop()

	--[[ Apply audio properties if specified ]]--
	if AudioSettings~=nil then
		for PropertyName,PropertyValue in pairs(AudioSettings) do
			if PropertyName~="Tween" then
				self.Sound[PropertyName]=PropertyValue
			end
		end

		--[[ Running tween if specified ]]--
		if AudioSettings.Tween~=nil then
			local AudioTween=TweenService:Create(
				self.Sound,
				unpack(AudioSettings.Tween)
			)

			AudioTween:Play()
		end
	end

	self.Sound.SoundId=self.CurrentAudio.ID
	self.Sound:Play()
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : PlayAudioAtIndex
-- @Description : Plays an audio in the audio playlist at the specified index, with the given options.
-- @Params : int "IndexNumber" - The index of the song to play.
--           OPTIONAL table "AudioSettings" - A dictionary table containing the properties to apply to the audio.
--                                            Can also include a tween.
-- @Example : AudioPlayer:PlayAudioAtIndex(2,{
--                Volume=0,
--                Tween={
--                    TweenInfo.new(5,Enum.EasingStyle.Linear),
--                    {Volume=1}
--                }
--            })
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:PlayAudioAtIndex(IndexNumber,AudioSettings)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] PlayAudioAtIndex() : Cannot play an audio of a destroyed audio player.")
	assert(IndexNumber~=nil,"[Audio Player '"..self.Name.."'] PlayAudioAtIndex() : IndexNumber expected, got nil.")
	assert(typeof(IndexNumber)=="number","[Audio Player '"..self.Name.."'] PlayAudioAtIndex() : number expcted for IndexNumber, got "..typeof(IndexNumber).." instead.")
	assert(self.Playlist[IndexNumber]~=nil,"[Audio Player '"..self.Name.."'] PlayAudioAtIndex() : Index out of bounds.")
	if AudioSettings~=nil then
		assert(typeof(AudioSettings)=="table","[Audio Player '"..self.Name.."'] PlayAudioAtIndex() : table expected for AudioSettings, got "..typeof(AudioSettings).." instead.")
	end

	-----------------------
	-- Playing the audio --
	-----------------------
	self:JumpToIndex(IndexNumber)
	self:Play(AudioSettings)
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : PlayAudio
-- @Description : Plays an audio in the audio playlist with the given name, with the given options.
-- @Params : string "AudioName" - The name of the song to play.
--           OPTIONAL table "AudioSettings" - A dictionary table containing the properties to apply to the audio.
--                                            Can also include a tween.
-- @Example : AudioPlayer:PlayAudio("LobbyMusic",{
--                Volume=0,
--                Tween={
--                    TweenInfo.new(5,Enum.EasingStyle.Linear),
--                    {Volume=1}
--                }
--            })
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:PlayAudio(AudioName,AudioSettings)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] PlayAudio() : Cannot play an audio of a destroyed audio player.")
	assert(AudioName~=nil,"[Audio Player '"..self.Name.."'] PlayAudio() : AudioName expected, got nil.")
	assert(typeof(AudioName)=="string","[Audio Player '"..self.Name.."'] PlayAudio() : string expected for AudioName, got "..typeof(AudioName).." instead.")
	if AudioSettings~=nil then
		assert(typeof(AudioSettings)=="table","[Audio Player '"..self.Name.."'] PlayAudioAtIndex() : table expected for AudioSettings, got "..typeof(AudioSettings).." instead.")
	end

	-------------
	-- DEFINES --
	-------------
	local AudioFound,AudioIndex=self:FindAudioByName(AudioName)

	-----------------------
	-- Playing the audio --
	-----------------------
	assert(AudioFound==true,"[Audio Player '"..self.Name.."'] PlayAudio() : Could not find an audio with the name '"..AudioName.."'.")
	self:JumpToIndex(AudioIndex)
	self:Play(AudioSettings)
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Stop
-- @Description : Stops the currently playing audio.
-- @Params : OPTIONAL table "Tween" - A table containing the properties for a tween that will run before the
--                                    audio is stopped.
-- @Example : AudioPlayer:Stop()
--            AudioPlayer:Stop({
--                TweenInfo.new(5,Enum.EasingStyle.Linear),
--                {Volume=1}
--            })
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:Stop(Tween)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] Stop() : Cannot stop an audio of a destroyed audio player.")

	------------------------
	-- Stopping the audio --
	------------------------

	--[[ Running tween if specified ]]--
	if Tween~=nil then
		local AudioTween=TweenService:Create(
			self.Sound,
			unpack(Tween)
		)

		AudioTween:Play()
		spawn(function() --We spawn the function so the calling thread doesn't yield.
			AudioTween.Completed:wait()
			self.Sound:Stop()
			self.Sound.TimePosition=0
		end)
	else
		self.Sound:Stop()
		self.Sound.TimePosition=0
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Resume
-- @Description : Resumes the currently paused audio.
-- @Params : OPTIONAL table "AudioSettings" - A dictionary table containing the properties to apply to the audio.
--                                            Can also include a tween.
-- @Example : AudioPlayer:Resume({
--                Volume=0,
--                Tween={
--                    TweenInfo.new(5,Enum.EasingStyle.Linear),
--                    {Volume=1}
--                }
--            })
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:Resume(AudioSettings)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] Resume()) : Cannot resume an audio of a destroyed audio player.")
	if AudioSettings~=nil then
		assert(typeof(AudioSettings)=="table","[Audio Player '"..self.Name.."'] Resume() : table expected for AudioSettings, got "..typeof(AudioSettings).." instead.")
	end

	------------------------
	-- Resuming the audio --
	------------------------

	--[[ Apply audio properties if specified ]]--
	if AudioSettings~=nil then
		for PropertyName,PropertyValue in pairs(AudioSettings) do
			if PropertyName~="Tween" then
				self.Sound[PropertyName]=PropertyValue
			end
		end

		--[[ Running tween if specified ]]--
		if AudioSettings.Tween~=nil then
			local AudioTween=TweenService:Create(
				self.Sound,
				unpack(AudioSettings.Tween)
			)

			AudioTween:Play()
		end
	end

	self.Sound:Resume()
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Pause
-- @Description : Pauses the currently playing audio.
-- @Params : OPTIONAL table "Tween" - A table containing the properties for a tween that will run before the
--                                    audio is paused.
-- @Example : AudioPlayer:Pause({
--                TweenInfo.new(5,Enum.EasingStyle.Linear),
--                {Volume=1}
--            })
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:Pause(Tween)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] Pause() : Cannot pause an audio of a destroyed audio player.")

	-----------------------
	-- Pausing the audio --
	-----------------------

	--[[ Running tween if specified ]]--
	if Tween~=nil then
		local AudioTween=TweenService:Create(
			self.Sound,
			unpack(Tween)
		)

		AudioTween:Play()
		spawn(function() --We spawn the function so the calling thread doesn't yield.
			AudioTween.Completed:wait()
			self.Sound:Pause()
		end)
	else
		self.Sound:Pause()
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : JumpToIndex
-- @Description : Sets the current song to the specified index in the playlist.
--                If audio is currently being played, the audio will be stopped.
--                If autoplay is true, the song at the specified index will be automatically played.
-- @Params : int "IndexNumber" - The index to jump to in the playlist.
-- @Example : AudioPlayer:JumpToIndex(2)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:JumpToIndex(IndexNumber)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] JumpToIndex() : Cannot jump to an index of a destroyed audio player.")
	assert(IndexNumber~=nil,"[Audio Player '"..self.Name.."'] JumpToIndex() : IndexNumber expected, got nil.")
	assert(typeof(IndexNumber)=="number","[Audio Player '"..self.Name.."'] JumpToIndex() : number expcted for IndexNumber, got "..typeof(IndexNumber).." instead.")
	assert(self.Playlist[IndexNumber]~=nil,"[Audio Player '"..self.Name.."'] JumpToIndex() : Index out of bounds.")

	----------------------
	-- Jumping to index --
	----------------------
	if CLASS_DEBUG then
		print("")
		print("[Audio Player '"..self.Name.."'] Jumping to index "..IndexNumber..".")
		print("")
	end

	self:Stop()
	self.PlaylistPosition=IndexNumber
	self.CurrentAudio=self.Playlist[IndexNumber]

	if self.AutoPlay then self:Play() end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Next
-- @Description : Jumps to the next song in the playlist if available.
--                If the looped property of the audioplayer is true, it will wrap to the beginning of the playlist.
-- @Example : AudioPlayer:Next()
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:Next()

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] Next() : Cannot go to next index in destroyed audioplayer.")

	if self.Playlist[self.PlaylistPosition+1]~=nil then
		self:JumpToIndex(self.PlaylistPosition+1)
	else
		if self.Looped then
			self:JumpToIndex(1)
		else
			warn("[Audio Player '"..self.Name.."'] Next() : Reached end of playlist, did not jump to next index.")
		end
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Previous
-- @Description : Jumps to the previous song in the playlist if available.
--                If the looped property of the audioplayer is true, it will wrap to the end of the playlist.
-- @Example : AudioPlayer:Previous()
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:Previous()

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] Previous() : Cannot go to previous index in destroyed audioplayer.")

	if self.Playlist[self.PlaylistPosition-1]~=nil then
		self:JumpToIndex(self.PlaylistPosition-1)
	else
		if self.Looped then
			self:JumpToIndex(#self.Playlist)
		else
			warn("[Audio Player '"..self.Name.."'] Previous() : Reached beginning of playlist, did not jump to previous index.")
		end
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : FindAudioByName
-- @Description : Finds an audio in the playlist with the given name and returns its position in the playlist.
-- @Params : string "AudioName" - The name of the audio to find.
-- @Returns : bool "Found" - Determines whether or not the audio was found.
--            int "Index" - The index of where the audio is in the playlist. Is nil if the requested audio is not found.
-- @Example : local SongFound=AudioPlayera:FindAudioByName("LobbyMusic")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function AudioPlayer:FindAudioByName(AudioName)

	----------------
	-- ASSERTIONS --
	----------------
	assert(self._Destroyed==false,"[Audio Player '"..self.Name.."'] FindAudioByName() : Cannot find audio in destroyed audioplayer.")
	assert(AudioName~=nil,"[Audio Player '"..self.Name.."'] FindAudioByName() : AudioName expected, got nil.")
	assert(typeof(AudioName)=="string","[Audio Player '"..self.Name.."'] FindAudioByName() : string expected for AudioName, got "..typeof(AudioName).." instead.")

	-----------------------
	-- Finding the audio --
	-----------------------
	for Index=1,#self.Playlist do
		if self.Playlist[Index].Name==AudioName then return true,Index end
	end

	return false
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- CLASS INITIALIZATION
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
if CLASS_DEBUG then warn("[Audio Player] Debug mode enabled. Logging will be verbose.") end

return AudioPlayer</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="11">
          <Properties>
            <string name="Name">BitBuffer</string>
            <string name="Source">--[[
	
==========================================================================
==                                	API                                 ==

Constructor: BitBuffer.Create()

Read/Write pairs for reading data from or writing data to the BitBuffer:
	BitBuffer:WriteUnsigned(bitWidth, value)
	BitBuffer:ReadUnsigned(bitWidth)
		Read / Write an unsigned value with a given number of bits. The 
		value must be a positive integer. For instance, if bitWidth is
		4, then there will be 4 magnitude bits, for a value in the
		range [0, 2^4-1] = [0, 15]
		
	BitBuffer:WriteSigned(bitWidth, value)
	BitBuffer:ReadSigned(bitWidth)
		Read / Write a a signed value with a given number of bits. For
		instance, if bitWidth is 4 then there will be 1 sign bit and
		3 magnitude bits, a value in the range [-2^3+1, 2^3-1] = [-7, 7]
		
	BitBuffer:WriteFloat(mantissaBitWidth, exponentBitWidth, value)
	BitBuffer:ReadFloat(mantissaBitWidth, exponentBitWidth)
		Read / Write a floating point number with a given mantissa and
		exponent size in bits.
		
	BitBuffer:WriteFloat32(value)
	BitBuffer:ReadFloat32()
	BitBuffer:WriteFloat64(value)
	BitBuffer:ReadFloat64()
		Read and write the common types of floating point number that
		are used in code. If you want to 100% accurately save an
		arbitrary Lua number, then you should use the Float64 format. If
		your number is known to be smaller, or you want to save space
		and don't need super high precision, then a Float32 will often
		suffice. For instance, the Transparency of an object will do
		just fine as a Float32.
		
	BitBuffer:WriteBool(value)
	BitBuffer:ReadBool()
		Read / Write a boolean (true / false) value. Takes one bit worth
		of space to store.
		
	BitBuffer:WriteString(str)
	BitBuffer:ReadString()
		Read / Write a variable length string. The string may contain
		embedded nulls. Only 7 bits / character will be used if the
		string contains no non-printable characters (greater than 0x80).
		
	BitBuffer:WriteBrickColor(color)
	BitBuffer:ReadBrickColor()
		Read / Write a roblox BrickColor. Provided as an example of 
		reading / writing a derived data type.
		
	BitBuffer:WriteRotation(cframe)
	BitBuffer:ReadRotation()
		Read / Write the rotation part of a given CFrame. Encodes the 
		rotation in question into 64bits, which is a good size to get
		a pretty dense packing, but still while having errors well within 
		the threshold that Roblox uses for stuff like MakeJoints() 
		detecting adjacency. Will also perfectly reproduce rotations which
		are orthagonally aligned, or inverse-power-of-two rotated on only
		a single axix. For other rotations, the results may not be
		perfectly stable through read-write cycles (if you read/write an
		arbitrary rotation thousands of times there may be detectable
		"drift")
	
		
From/To pairs for dumping out the BitBuffer to another format:
	BitBuffer:ToString()
	BitBuffer:FromString(str)
		Will replace / dump out the contents of the buffer to / from
		a binary chunk encoded as a Lua string. This string is NOT
		suitable for storage in the Roblox DataStores, as they do
		not handle non-printable characters well.
		
	BitBuffer:ToBase64()
	BitBuffer:FromBase64(str)
		Will replace / dump out the contents of the buffer to / from
		a set of Base64 encoded data, as a Lua string. This string
		only consists of Base64 printable characters, so it is
		ideal for storage in Roblox DataStores.
		
Buffer / Position Manipulation
	BitBuffer:ResetPtr()
		Will Reset the point in the buffer that is being read / written
		to back to the start of the buffer.
		
	BitBuffer:Reset()
		Will reset the buffer to a clean state, with no contents.

Example Usage:
	local function SaveToBuffer(buffer, userData)
		buffer:WriteString(userData.HeroName)
		buffer:WriteUnsigned(14, userData.Score) --> 14 bits -> [0, 2^14-1] -> [0, 16383]
		buffer:WriteBool(userData.HasDoneSomething)
		buffer:WriteUnsigned(10, #userData.ItemList) --> [0, 1023]
		for _, itemInfo in pairs(userData.ItemList) do
			buffer:WriteString(itemInfo.Identifier)
			buffer:WriteUnsigned(10, itemInfo.Count) --> [0, 1023]
		end
	end
	local function LoadFromBuffer(buffer, userData)
		userData.HeroName = buffer:ReadString()
		userData.Score = buffer:ReadUnsigned(14)
		userData.HasDoneSomething = buffer:ReadBool()
		local itemCount = buffer:ReadUnsigned(10)
		for i = 1, itemCount do
			local itemInfo = {}
			itemInfo.Identifier = buffer:ReadString()
			itemInfo.Count = buffer:ReadUnsigned(10)
			table.insert(userData.ItemList, itemInfo)
		end
	end
	--...
	local buff = BitBuffer.Create()
	SaveToBuffer(buff, someUserData)
	myDataStore:SetAsync(somePlayer.userId, buff:ToBase64())
	--...
	local data = myDataStore:GetAsync(somePlayer.userId)
	local buff = BitBuffer.Create()
	buff:FromBase64(data)
	LoadFromBuffer(buff, someUserData)
--]]

local BitBuffer = {}

--[[
String Encoding:
	   Char 1   Char 2
str:  LSB--MSB LSB--MSB
Bit#  1,2,...8 9,...,16
--]]

local NumberToBase64; local Base64ToNumber; do
	NumberToBase64 = {}
	Base64ToNumber = {}
	local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	for i = 1, #chars do
		local ch = chars:sub(i, i)
		NumberToBase64[i-1] = ch
		Base64ToNumber[ch] = i-1
	end
end

local PowerOfTwo; do
	PowerOfTwo = {}
	for i = 0, 64 do
		PowerOfTwo[i] = 2^i
	end
end

local BrickColorToNumber; local NumberToBrickColor; do
	BrickColorToNumber = {}
	NumberToBrickColor = {}
	for i = 0, 63 do
		local color = BrickColor.palette(i)
		BrickColorToNumber[color.Number] = i
		NumberToBrickColor[i] = color
	end
end

local floor,insert = math.floor, table.insert
function ToBase(n, b)
    n = floor(n)
    if not b or b == 10 then return tostring(n) end
    local digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    local t = {}
    local sign = ""
    if n &lt; 0 then
        sign = "-"
    n = -n
    end
    repeat
        local d = (n % b) + 1
        n = floor(n / b)
        insert(t, 1, digits:sub(d, d))
    until n == 0
    return sign..table.concat(t, "")
end

function BitBuffer.Create()
	local this = {}
	
	-- Tracking
	local mBitPtr = 0
	local mBitBuffer = {}
	
	function this:ResetPtr()
		mBitPtr = 0
	end
	function this:Reset()
		mBitBuffer = {}
		mBitPtr = 0
	end
	
	-- Set debugging on
	local mDebug = false
	function this:SetDebug(state)
		mDebug = state
	end
	
	-- Read / Write to a string
	function this:FromString(str)
		this:Reset()
		for i = 1, #str do
			local ch = str:sub(i, i):byte()
			for i = 1, 8 do
				mBitPtr = mBitPtr + 1
				mBitBuffer[mBitPtr] = ch % 2
				ch = math.floor(ch / 2)
			end
		end
		mBitPtr = 0
	end
	function this:ToString()
		local str = ""
		local accum = 0
		local pow = 0
		for i = 1, math.ceil((#mBitBuffer) / 8)*8 do
			accum = accum + PowerOfTwo[pow]*(mBitBuffer[i] or 0)
			pow = pow + 1
			if pow >= 8 then
				str = str..string.char(accum)
				accum = 0
				pow = 0
			end
		end
		return str
	end
	
	-- Read / Write to base64
	function this:FromBase64(str)
		this:Reset()
		for i = 1, #str do
			local ch = Base64ToNumber[str:sub(i, i)]
			assert(ch, "Bad character: 0x"..ToBase(str:sub(i, i):byte(), 16))
			for i = 1, 6 do
				mBitPtr = mBitPtr + 1
				mBitBuffer[mBitPtr] = ch % 2
				ch = math.floor(ch / 2)
			end
			assert(ch == 0, "Character value 0x"..ToBase(Base64ToNumber[str:sub(i, i)], 16).." too large")
		end
		this:ResetPtr()
	end
	function this:ToBase64()
		local strtab = {}
		local accum = 0
		local pow = 0
		for i = 1, math.ceil((#mBitBuffer) / 6)*6 do
			accum = accum + PowerOfTwo[pow]*(mBitBuffer[i] or 0)
			pow = pow + 1
			if pow >= 6 then
				table.insert(strtab, NumberToBase64[accum])
				accum = 0
				pow = 0
			end
		end
		return table.concat(strtab)
	end	
	
	-- Dump
	function this:Dump()
		local str = ""
		local str2 = ""
		local accum = 0
		local pow = 0
		for i = 1, math.ceil((#mBitBuffer) / 8)*8 do
			str2 = str2..(mBitBuffer[i] or 0)
			accum = accum + PowerOfTwo[pow]*(mBitBuffer[i] or 0)
			--print(pow..": +"..PowerOfTwo[pow].."*["..(mBitBuffer[i] or 0).."] -> "..accum)
			pow = pow + 1
			if pow >= 8 then
				str2 = str2.." "
				str = str.."0x"..ToBase(accum, 16).." "
				accum = 0
				pow = 0
			end
		end
		print("Bytes:", str)
		print("Bits:", str2)
	end
	
	-- Read / Write a bit
	local function writeBit(v)
		mBitPtr = mBitPtr + 1
		mBitBuffer[mBitPtr] = v
	end
	local function readBit(v)
		mBitPtr = mBitPtr + 1
		return mBitBuffer[mBitPtr]
	end
	
	-- Read / Write an unsigned number
	function this:WriteUnsigned(w, value, printoff)
		assert(w, "Bad arguments to BitBuffer::WriteUnsigned (Missing BitWidth)")
		assert(value, "Bad arguments to BitBuffer::WriteUnsigned (Missing Value)")
		assert(value >= 0, "Negative value to BitBuffer::WriteUnsigned")
		assert(math.floor(value) == value, "Non-integer value to BitBuffer::WriteUnsigned")
		if mDebug and not printoff then
			print("WriteUnsigned["..w.."]:", value)
		end
		-- Store LSB first
		for i = 1, w do
			writeBit(value % 2)
			value = math.floor(value / 2)
		end
		assert(value == 0, "Value "..tostring(value).." has width greater than "..w.."bits")
	end 
	function this:ReadUnsigned(w, printoff)
		local value = 0
		for i = 1, w do
			value = value + readBit() * PowerOfTwo[i-1]
		end
		if mDebug and not printoff then
			print("ReadUnsigned["..w.."]:", value)
		end
		return value
	end
	
	-- Read / Write a signed number
	function this:WriteSigned(w, value)
		assert(w and value, "Bad arguments to BitBuffer::WriteSigned (Did you forget a bitWidth?)")
		assert(math.floor(value) == value, "Non-integer value to BitBuffer::WriteSigned")
		if mDebug then
			print("WriteSigned["..w.."]:", value)
		end
		-- Write sign
		if value &lt; 0 then
			writeBit(1)
			value = -value
		else
			writeBit(0)
		end
		-- Write value
		this:WriteUnsigned(w-1, value, true)
	end
	function this:ReadSigned(w)
		-- Read sign
		local sign = (-1)^readBit()
		-- Read value
		local value = this:ReadUnsigned(w-1, true)
		if mDebug then
			print("ReadSigned["..w.."]:", sign*value)
		end
		return sign*value
	end
	
	-- Read / Write a string. May contain embedded nulls (string.char(0))
	function this:WriteString(s)
		-- First check if it's a 7 or 8 bit width of string
		local bitWidth = 7
		for i = 1, #s do
			if s:sub(i, i):byte() > 127 then
				bitWidth = 8
				break
			end
		end
		
		-- Write the bit width flag
		if bitWidth == 7 then
			this:WriteBool(false)
		else
			this:WriteBool(true) -- wide chars
		end
	
		-- Now write out the string, terminated with "0x10, 0b0"
		-- 0x10 is encoded as "0x10, 0b1"
		for i = 1, #s do
			local ch = s:sub(i, i):byte()
			if ch == 0x10 then
				this:WriteUnsigned(bitWidth, 0x10)
				this:WriteBool(true)
			else
				this:WriteUnsigned(bitWidth, ch)
			end
		end
		
		-- Write terminator
		this:WriteUnsigned(bitWidth, 0x10)
		this:WriteBool(false)
	end
	function this:ReadString()
		-- Get bit width
		local bitWidth;
		if this:ReadBool() then
			bitWidth = 8
		else
			bitWidth = 7
		end
		
		-- Loop
		local str = ""
		while true do
			local ch = this:ReadUnsigned(bitWidth)
			if ch == 0x10 then
				local flag = this:ReadBool()
				if flag then
					str = str..string.char(0x10)
				else
					break
				end
			else
				str = str..string.char(ch)
			end
		end
		return str
	end
	
	-- Read / Write a bool
	function this:WriteBool(v)
		if mDebug then
			print("WriteBool[1]:", v and "1" or "0")
		end
		if v then
			this:WriteUnsigned(1, 1, true)
		else
			this:WriteUnsigned(1, 0, true)
		end
	end
	function this:ReadBool()
		local v = (this:ReadUnsigned(1, true) == 1)
		if mDebug then
			print("ReadBool[1]:", v and "1" or "0")
		end
		return v
	end
	
	-- Read / Write a floating point number with |wfrac| fraction part
	-- bits, |wexp| exponent part bits, and one sign bit.
	function this:WriteFloat(wfrac, wexp, f)
		assert(wfrac and wexp and f)
		
		-- Sign
		local sign = 1
		if f &lt; 0 then
			f = -f
			sign = -1
		end
		
		-- Decompose
		local mantissa, exponent = math.frexp(f)
		if exponent == 0 and mantissa == 0 then
			this:WriteUnsigned(wfrac + wexp + 1, 0)
			return
		else
			mantissa = ((mantissa - 0.5)/0.5 * PowerOfTwo[wfrac])
		end
		
		-- Write sign
		if sign == -1 then
			this:WriteBool(true)
		else
			this:WriteBool(false)
		end
		
		-- Write mantissa
		mantissa = math.floor(mantissa + 0.5) -- Not really correct, should round up/down based on the parity of |wexp|
		this:WriteUnsigned(wfrac, mantissa)
		
		-- Write exponent
		local maxExp = PowerOfTwo[wexp-1]-1
		if exponent > maxExp then
			exponent = maxExp
		end
		if exponent &lt; -maxExp then
			exponent = -maxExp
		end
		this:WriteSigned(wexp, exponent)	
	end
	function this:ReadFloat(wfrac, wexp)
		assert(wfrac and wexp)
		
		-- Read sign
		local sign = 1
		if this:ReadBool() then
			sign = -1
		end
		
		-- Read mantissa
		local mantissa = this:ReadUnsigned(wfrac)
		
		-- Read exponent
		local exponent = this:ReadSigned(wexp)
		if exponent == 0 and mantissa == 0 then
			return 0
		end
		
		-- Convert mantissa
		mantissa = mantissa / PowerOfTwo[wfrac] * 0.5 + 0.5
		
		-- Output
		return sign * math.ldexp(mantissa, exponent)
	end
	
	-- Read / Write single precision floating point
	function this:WriteFloat32(f)
		this:WriteFloat(23, 8, f)
	end
	function this:ReadFloat32()
		return this:ReadFloat(23, 8)
	end
	
	-- Read / Write double precision floating point
	function this:WriteFloat64(f)
		this:WriteFloat(52, 11, f)
	end
	function this:ReadFloat64()
		return this:ReadFloat(52, 11)
	end
	
	-- Read / Write a BrickColor
	function this:WriteBrickColor(b)
		local pnum = BrickColorToNumber[b.Number]
		if not pnum then
			warn("Attempt to serialize non-pallete BrickColor `"..tostring(b).."` (#"..b.Number.."), using Light Stone Grey instead.")
			pnum = BrickColorToNumber[BrickColor.new(1032).Number]
		end
		this:WriteUnsigned(6, pnum)
	end
	function this:ReadBrickColor()
		return NumberToBrickColor[this:ReadUnsigned(6)]
	end
	
	-- Read / Write a rotation as a 64bit value.
	local function round(n)
		return math.floor(n + 0.5)
	end
	function this:WriteRotation(cf)
		local lookVector = cf.lookVector
		local azumith = math.atan2(-lookVector.X, -lookVector.Z)
		local ybase = (lookVector.X^2 + lookVector.Z^2)^0.5
		local elevation = math.atan2(lookVector.Y, ybase)
		local withoutRoll = CFrame.new(cf.p) * CFrame.Angles(0, azumith, 0) * CFrame.Angles(elevation, 0, 0)
		local x, y, z = (withoutRoll:inverse()*cf):toEulerAnglesXYZ()
		local roll = z
		-- Atan2 -> in the range [-pi, pi] 
		azumith   = round((azumith   /  math.pi   ) * (2^21-1))
		roll      = round((roll      /  math.pi   ) * (2^20-1))
		elevation = round((elevation / (math.pi/2)) * (2^20-1))
		--
		this:WriteSigned(22, azumith)
		this:WriteSigned(21, roll)
		this:WriteSigned(21, elevation)
	end
	function this:ReadRotation()
		local azumith   = this:ReadSigned(22)
		local roll      = this:ReadSigned(21)
		local elevation = this:ReadSigned(21)
		--
		azumith =    math.pi    * (azumith / (2^21-1))
		roll =       math.pi    * (roll    / (2^20-1))
		elevation = (math.pi/2) * (elevation / (2^20-1))
		--
		local rot = CFrame.Angles(0, azumith, 0)
		rot = rot * CFrame.Angles(elevation, 0, 0)
		rot = rot * CFrame.Angles(0, 0, roll)
		--
		return rot
	end
	
	return this
end

return BitBuffer</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="12">
          <Properties>
            <string name="Name">CameraShaker</string>
            <string name="Source">-- Camera Shaker
-- Crazyman32
-- February 26, 2018

--[[
	
	CameraShaker.CameraShakeInstance
	
	cameraShaker = CameraShaker.new(renderPriority, callbackFunction)
	
	CameraShaker:Start()
	CameraShaker:Stop()
	CameraShaker:Shake(shakeInstance)
	CameraShaker:ShakeSustain(shakeInstance)
	CameraShaker:ShakeOnce(magnitude, roughness [, fadeInTime, fadeOutTime, posInfluence, rotInfluence])
	CameraShaker:StartShake(magnitude, roughness [, fadeInTime, posInfluence, rotInfluence])
	
	
	
	EXAMPLE:
	
		local camShake = CameraShaker.new(Enum.RenderPriority.Camera.Value, function(shakeCFrame)
			camera.CFrame = playerCFrame * shakeCFrame
		end)
		
		camShake:Start()
		
		-- Explosion shake:
		camShake:Shake(CameraShaker.Presets.Explosion)
		
		wait(1)
		
		-- Custom shake:
		camShake:ShakeOnce(3, 1, 0.2, 1.5)
	
	
	
	NOTE:
	
		This was based entirely on the EZ Camera Shake asset for Unity3D. I was given written
		permission by the developer, Road Turtle Games, to port this to Roblox.
		
		Original asset link: https://assetstore.unity.com/packages/tools/camera/ez-camera-shake-33148
	
	
--]]



local CameraShaker = {}
CameraShaker.__index = CameraShaker

local profileBegin = debug.profilebegin
local profileEnd = debug.profileend
local profileTag = "CameraShakerUpdate"

local V3 = Vector3.new
local CF = CFrame.new
local ANG = CFrame.Angles
local RAD = math.rad
local v3Zero = V3()

local CameraShakeInstance = require(script.CameraShakeInstance)
local CameraShakeState = CameraShakeInstance.CameraShakeState

local defaultPosInfluence = V3(0.15, 0.15, 0.15)
local defaultRotInfluence = V3(1, 1, 1)


CameraShaker.CameraShakeInstance = CameraShakeInstance
CameraShaker.Presets = require(script.CameraShakePresets)


function CameraShaker.new(renderPriority, callback)
	
	assert(type(renderPriority) == "number", "RenderPriority must be a number (e.g.: Enum.RenderPriority.Camera.Value)")
	assert(type(callback) == "function", "Callback must be a function")
	
	local self = setmetatable({
		_running = false;
		_renderName = "CameraShaker";
		_renderPriority = renderPriority;
		_posAddShake = v3Zero;
		_rotAddShake = v3Zero;
		_camShakeInstances = {};
		_removeInstances = {};
		_callback = callback;
	}, CameraShaker)
	
	return self
	
end


function CameraShaker:Start()
	if (self._running) then return end
	self._running = true
	local callback = self._callback
	game:GetService("RunService"):BindToRenderStep(self._renderName, self._renderPriority, function(dt)
		profileBegin(profileTag)
		local cf = self:Update(dt)
		profileEnd()
		callback(cf)
	end)
end


function CameraShaker:Stop()
	if (not self._running) then return end
	game:GetService("RunService"):UnbindFromRenderStep(self._renderName)
	self._running = false
end


function CameraShaker:Update(dt)
	
	local posAddShake = v3Zero
	local rotAddShake = v3Zero
	
	local instances = self._camShakeInstances
	
	-- Update all instances:
	for i = 1,#instances do
		
		local c = instances[i]
		local state = c:GetState()
		
		if (state == CameraShakeState.Inactive and c.DeleteOnInactive) then
			self._removeInstances[#self._removeInstances + 1] = i
		elseif (state ~= CameraShakeState.Inactive) then
			posAddShake = posAddShake + (c:UpdateShake(dt) * c.PositionInfluence)
			rotAddShake = rotAddShake + (c:UpdateShake(dt) * c.RotationInfluence)
		end
		
	end
	
	-- Remove dead instances:
	for i = #self._removeInstances,1,-1 do
		local instIndex = self._removeInstances[i]
		table.remove(instances, instIndex)
		self._removeInstances[i] = nil
	end
	
	return CF(posAddShake) *
			ANG(0, RAD(rotAddShake.Y), 0) *
			ANG(RAD(rotAddShake.X), 0, RAD(rotAddShake.Z))
	
end


function CameraShaker:Shake(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:ShakeSustain(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	shakeInstance:StartFadeIn(shakeInstance.fadeInDuration)
	return shakeInstance
end


function CameraShaker:ShakeOnce(magnitude, roughness, fadeInTime, fadeOutTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:StartShake(magnitude, roughness, fadeInTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	shakeInstance:StartFadeIn(fadeInTime)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


return CameraShaker</string>
          </Properties>
          <Item class="ModuleScript" referent="13">
            <Properties>
              <string name="Name">CameraShakeInstance</string>
              <string name="Source">-- Camera Shake Instance
-- Crazyman32
-- February 26, 2018

--[[
	
	cameraShakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
--]]



local CameraShakeInstance = {}
CameraShakeInstance.__index = CameraShakeInstance

local V3 = Vector3.new
local NOISE = math.noise


CameraShakeInstance.CameraShakeState = {
	FadingIn = 0;
	FadingOut = 1;
	Sustained = 2;
	Inactive = 3;
}


function CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
	if (fadeInTime == nil) then fadeInTime = 0 end
	if (fadeOutTime == nil) then fadeOutTime = 0 end
	
	assert(type(magnitude) == "number", "Magnitude must be a number")
	assert(type(roughness) == "number", "Roughness must be a number")
	assert(type(fadeInTime) == "number", "FadeInTime must be a number")
	assert(type(fadeOutTime) == "number", "FadeOutTime must be a number")
	
	local self = setmetatable({
		Magnitude = magnitude;
		Roughness = roughness;
		PositionInfluence = V3();
		RotationInfluence = V3();
		DeleteOnInactive = true;
		roughMod = 1;
		magnMod = 1;
		fadeOutDuration = fadeOutTime;
		fadeInDuration = fadeInTime;
		sustain = (fadeInTime > 0);
		currentFadeTime = (fadeInTime > 0 and 0 or 1);
		tick = Random.new():NextNumber(-100, 100);
		_camShakeInstance = true;
	}, CameraShakeInstance)
	
	return self
	
end


function CameraShakeInstance:UpdateShake(dt)
	
	local _tick = self.tick
	local currentFadeTime = self.currentFadeTime
	
	local offset = V3(
		NOISE(_tick, 0) * 0.5,
		NOISE(0, _tick) * 0.5,
		NOISE(_tick, _tick) * 0.5
	)
	
	if (self.fadeInDuration > 0 and self.sustain) then
		if (currentFadeTime &lt; 1) then
			currentFadeTime = currentFadeTime + (dt / self.fadeInDuration)
		elseif (self.fadeOutDuration > 0) then
			self.sustain = false
		end
	end
	
	if (not self.sustain) then
		currentFadeTime = currentFadeTime - (dt / self.fadeOutDuration)
	end
	
	if (self.sustain) then
		self.tick = _tick + (dt * self.Roughness * self.roughMod)
	else
		self.tick = _tick + (dt * self.Roughness * self.roughMod * currentFadeTime)
	end
	
	self.currentFadeTime = currentFadeTime
	
	return offset * self.Magnitude * self.magnMod * currentFadeTime
	
end


function CameraShakeInstance:StartFadeOut(fadeOutTime)
	if (fadeOutTime == 0) then
		self.currentFadeTime = 0
	end
	self.fadeOutDuration = fadeOutTime
	self.fadeInDuration = 0
	self.sustain = false
end


function CameraShakeInstance:StartFadeIn(fadeInTime)
	if (fadeInTime == 0) then
		self.currentFadeTime = 1
	end
	self.fadeInDuration = fadeInTime or self.fadeInDuration
	self.fadeOutDuration = 0
	self.sustain = true
end


function CameraShakeInstance:GetScaleRoughness()
	return self.roughMod
end


function CameraShakeInstance:SetScaleRoughness(v)
	self.roughMod = v
end


function CameraShakeInstance:GetScaleMagnitude()
	return self.magnMod
end


function CameraShakeInstance:SetScaleMagnitude(v)
	self.magnMod = v
end


function CameraShakeInstance:GetNormalizedFadeTime()
	return self.currentFadeTime
end


function CameraShakeInstance:IsShaking()
	return (self.currentFadeTime > 0 or self.sustain)
end


function CameraShakeInstance:IsFadingOut()
	return ((not self.sustain) and self.currentFadeTime > 0)
end


function CameraShakeInstance:IsFadingIn()
	return (self.currentFadeTime &lt; 1 and self.sustain and self.fadeInDuration > 0)
end


function CameraShakeInstance:GetState()
	if (self:IsFadingIn()) then
		return CameraShakeInstance.CameraShakeState.FadingIn
	elseif (self:IsFadingOut()) then
		return CameraShakeInstance.CameraShakeState.FadingOut
	elseif (self:IsShaking()) then
		return CameraShakeInstance.CameraShakeState.Sustained
	else
		return CameraShakeInstance.CameraShakeState.Inactive
	end
end


return CameraShakeInstance</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="14">
            <Properties>
              <string name="Name">CameraShakePresets</string>
              <string name="Source">-- Camera Shake Presets
-- Crazyman32
-- February 26, 2018

--[[
	
	CameraShakePresets.Bump
	CameraShakePresets.Explosion
	CameraShakePresets.Earthquake
	CameraShakePresets.BadTrip
	CameraShakePresets.HandheldCamera
	CameraShakePresets.Vibration
	CameraShakePresets.RoughDriving
	
--]]



local CameraShakeInstance = require(script.Parent.CameraShakeInstance)

local CameraShakePresets = {
	
	
	-- A high-magnitude, short, yet smooth shake.
	-- Should happen once.
	Bump = function()
		local c = CameraShakeInstance.new(2.5, 4, 0.1, 0.75)
		c.PositionInfluence = Vector3.new(0.15, 0.15, 0.15)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
	-- An intense and rough shake.
	-- Should happen once.
	Explosion = function()
		local c = CameraShakeInstance.new(5, 10, 0, 1.5)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(4, 1, 1)
		return c
	end;
	
	
	-- A continuous, rough shake
	-- Sustained.
	Earthquake = function()
		local c = CameraShakeInstance.new(0.6, 3.5, 2, 10)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(1, 1, 4)
		return c
	end;
	
	
	-- A bizarre shake with a very high magnitude and low roughness.
	-- Sustained.
	BadTrip = function()
		local c = CameraShakeInstance.new(10, 0.15, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0.15)
		c.RotationInfluence = Vector3.new(2, 1, 4)
		return c
	end;
	
	
	-- A subtle, slow shake.
	-- Sustained.
	HandheldCamera = function()
		local c = CameraShakeInstance.new(1, 0.25, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 0.5, 0.5)
		return c
	end;
	
	
	-- A very rough, yet low magnitude shake.
	-- Sustained.
	Vibration = function()
		local c = CameraShakeInstance.new(0.4, 20, 2, 2)
		c.PositionInfluence = Vector3.new(0, 0.15, 0)
		c.RotationInfluence = Vector3.new(1.25, 0, 4)
		return c
	end;
	
	
	-- A slightly rough, medium magnitude shake.
	-- Sustained.
	RoughDriving = function()
		local c = CameraShakeInstance.new(1, 2, 1, 1)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
}


return setmetatable({}, {
	__index = function(t, i)
		local f = CameraShakePresets[i]
		if (type(f) == "function") then
			return f()
		end
		error("No preset found with index \"" .. i .. "\"")
	end;
})</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="15">
          <Properties>
            <string name="Name">Date</string>
            <string name="Source">-- Date
-- Crazyman32
-- September 12, 2017

--[=[
	Represents a date at a specific time. On the server, this will
	return UTC time. On the client, this will return local time.
	Note that the server-side in Play-Solo testing will also return
	local time.
	You can optionally force UTC within the Date.new constructor.
	REQUIRE:
		local Date = require(thisModule)
	
	CONSTRUCTORS:
		local date = Date.new([seconds [, useUtc]])
		local date = Date.fromJSON(jsonString)
	METHODS:
		date:ToJSON()
		date:ToSeconds()
		date:GetTimezoneHourOffset()
		date:Format(strFormat)
		date:ToUTC()
		date:ToLocal()
		date:ToISOString()
		date:ToDateString()
		date:ToTimeString()
		date:ToString()
	PROPERTIES:
		date.Hour
		date.Minute
		date.Weekday
		date.Day
		date.Month
		date.Year
		date.Second
		date.Millisecond
		date.Yearday
		date.IsDST
	NOTE ON SAVING:
		You should use 'date:ToSeconds()' for saving. It can
		represent the date in the smallest format. While using
		'date:ToJSON()' will work too, it has a higher data
		footprint. Example:
		SAVE:
			local date = Date.new()
			dataStore:SetAsync("myDate", date:ToSeconds())
		LOAD:
			local myDateSeconds = dataStore:GetAsync("myDate")
			local date = Date.new(myDateSeconds)
	
--]=]



local Date = {}
Date.__index = Date


local useUTC = game:GetService("RunService"):IsServer()


local WEEKDAYS = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
local WEEKDAYS_SHORT = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}

local MONTHS = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
local MONTHS_SHORT = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}


-- Single-level table copy:
function CopyTable(t)
	local tCopy = {}
	for k,v in pairs(t) do
		tCopy[k] = v
	end
	return tCopy
end


function Date.new(seconds, useUtcOverride)

	if (seconds ~= nil) then
		assert(type(seconds) == "number", "'seconds' argument #1 must be a number")
	else
		seconds = tick()
	end

	local utc = useUTC
	if (useUtcOverride ~= nil) then
		utc = useUtcOverride
	end

	local d = os.date(utc and "!*t" or "*t", seconds)

	local self = setmetatable({
		Hour = d.hour;
		Minute = d.min;
		Weekday = d.wday;
		Day = d.day;
		Month = d.month;
		Year = d.year;
		Second = d.sec;
		Millisecond = math.floor((seconds % 1) * 1000);
		Yearday = d.yday;
		IsDST = d.isdst;
		_d = d;
		_s = seconds;
	}, Date)

	return self

end


function Date.fromJSON(jsonStr)
	assert(type(jsonStr) == "string", "'jsonStr' argument #1 must be a string")
	local success, data = pcall(function()
		return game:GetService("HttpService"):JSONDecode(jsonStr)
	end)
	if (not success) then
		error("Failed to decode JSON string: " .. tostring(data))
	end
	local seconds
	if (data._s) then
		seconds = data._s
	else
		seconds = os.time(data)
	end
	return Date.new(seconds)
end


function Date:ToJSON()
	local data = CopyTable(self._d)
	data._s = self._s
end


function Date:ToSeconds()
	return self._s
end


function Date:GetTimezoneHourOffset()
	local dUTC = os.date("!*t", self._s)
	return (self._d.hour - dUTC.hour)
end


function Date:ToISOString()
	local utc = self:ToUTC()
	local d = utc._d
	return ("%.2i-%.2i-%.2iT%.2i:%.2i:%.2i.%.3i"):format(
		d.year,
		d.month,
		d.day,
		d.hour,
		d.min,
		d.sec,
		math.floor((utc._s % 1) * 1000)
	)
end


function Date:ToDateString()
	local d = self._d
	return ("%s %s %i %i"):format(
		WEEKDAYS_SHORT[d.wday],
		MONTHS_SHORT[d.month],
		d.day,
		d.year
	)
end


function Date:ToTimeString()
	local d = self._d
	return ("%.2i:%.2i:%.2i"):format(
		d.hour,
		d.min,
		d.sec
	)
end


function Date:ToString()
	return (self:ToDateString() .. " " .. self:ToTimeString())
end


function Date:ToUTC()
	return Date.new(self._s, true)
end


function Date:ToLocal()
	return Date.new(self._s, false)
end


-- See GNU date commands:
-- https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/
function Date:Format(str)
	local d = self._d
	local h12 = d.hour
	if (h12 > 12) then
		h12 = h12 - 12
	end
	if (h12 == 0) then
		h12 = 0
	end
	str = str
		:gsub("%%a", WEEKDAYS_SHORT[d.wday])
		:gsub("%%A", WEEKDAYS[d.wday])
		:gsub("%%b", MONTHS_SHORT[d.month])
		:gsub("%%B", MONTHS[d.month])
		:gsub("%%c", self:ToString())
		:gsub("%%C", ((d.year - (d.year % 1000)) / 100) + 1)
		:gsub("%%d", ("%.2i"):format(d.day))
		:gsub("%%D", ("%.2i/%.2i/%s"):format(d.month, d.day, tostring(d.year):sub(-2)))
		:gsub("%%F", ("%i-%.2i-%.2i"):format(d.year, d.month, d.day))
		:gsub("%%H", ("%.2i"):format(d.hour))
		:gsub("%%k", ("%.2i"):format(d.hour))
		:gsub("%%I", ("%.2i"):format(h12))
		:gsub("%%l", ("%.2i"):format(h12))
		:gsub("%%j", ("%.3i"):format(d.yday))
		:gsub("%%m", ("%.2i"):format(d.month))
		:gsub("%%M", ("%.2i"):format(d.min))
		:gsub("%%n", "\n")
		:gsub("%%p", (d.hour >= 12 and "PM" or "AM"))
		:gsub("%%P", (d.hour >= 12 and "pm" or "am"))
		:gsub("%%r", ("%.2i:%.2i:%.2i %s"):format(h12, d.min, d.sec, (d.hour >= 12 and "PM" or "AM")))
		:gsub("%%R", ("%.2i:%.2i"):format(d.hour, d.min))
		:gsub("%%s", math.floor(self._s))
		:gsub("%%S", ("%.2i"):format(d.sec))
		:gsub("%%t", "\t")
		:gsub("%%T", ("%.2i:%.2i:%.2i"):format(d.hour, d.min, d.sec))
		:gsub("%%w", ("%.2i"):format(d.wday))
		:gsub("%%y", tostring(d.year):sub(-2))
		:gsub("%%Y", tostring(d.year))
	return str

end


Date.New = Date.new
Date.FromJSON = Date.fromJSON
Date.__tostring = Date.ToString
Date.__metatable = "locked"


function Date.__lt(d1, d2)
	return (d1._s &lt; d2._s)
end


function Date.__le(d1, d2)
	return (d1._s &lt;= d2._s)
end


function Date.__eq(d1, d2)
	return (d1._s == d2._s)
end


function Date.__unm(d)
	return Date.new(-d._s)
end


return Date</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="16">
          <Properties>
            <string name="Name">ElectricArcs</string>
            <string name="Source">--[[	Arc.lua
		Implementation of the main Arc class of this library that the user interacts.
		This module is licensed under MIT, refer to the LICENSE file or:
		https://github.com/buildthomas/ElectricArc/blob/master/LICENSE
]]

local Arc = {}
Arc.__index = Arc

local Util = require(script.Util)
local Constants = require(script.Constants)
local System = require(script.System)

-- Error format strings
local ERROR_TYPE_FORMAT = "bad argument #%d to '%s' (%s expected, got %s)"
local ERROR_BAD_ARGUMENT = "bad argument #%d to '%s' (%s)"

function Arc:GetEnabled()
	return System.contains(self)
end

function Arc:SetEnabled(value)
	if value then
		System.add(self)
	else
		System.remove(self)
	end
end

function Arc:GetCFrame()
	return self.cframe
end

function Arc:SetCFrame(cfr)
    self.cframe = cfr
    self.changed = true
end

function Arc:GetRange()
    return self.cframe.p, self.cframe * Vector3.new(self.length, 0, 0)
end

function Arc:SetRange(source, drain)
	local axis = drain - source
	if axis.magnitude &lt; 0.001 then
		axis = Vector3.new(0, 0, -0.001)
	end
    self.length = axis.magnitude
	self.cframe = Util.makeOrientation(source, axis)
    self.changed = true
end

function Arc:GetColor()
    return self.color
end

function Arc:SetColor(color)
    self.color = color
end

function Arc:GetTopColor()
    return self.topColor
end

function Arc:SetTopColor(topColor)
    self.topColor = topColor
end

function Arc:GetNumArcs()
	return self.numArcs
end

function Arc:Destroy()
    -- Remove self from system
    System.remove(self)

    -- Destroying instances
    self.part:Destroy()
    self.segmentsFolder:Destroy()
end

function Arc:GetFatnessMultiplier()
	return self.fatnessMultiplier
end

function Arc:SetFatnessMultiplier(fatnessMultiplier)
	self.fatnessMultiplier = fatnessMultiplier
end

function Arc.new(source, drain, color, topColor, numArcs, fatnessMultiplier, enabled)
    if source ~= nil and typeof(source) ~= "Vector3" then
        error(ERROR_TYPE_FORMAT:format(1, "new", "Vector3", typeof(source)), 2)
    elseif drain ~= nil and typeof(drain) ~= "Vector3" then
        error(ERROR_TYPE_FORMAT:format(2, "new", "Vector3", typeof(drain)), 2)
    elseif color ~= nil and typeof(color) ~= "Color3" then
        error(ERROR_TYPE_FORMAT:format(3, "new", "Color3", typeof(color)), 2)
    elseif topColor ~= nil and typeof(topColor) ~= "Color3" then
        error(ERROR_TYPE_FORMAT:format(4, "new", "Color3", typeof(topColor)), 2)
    elseif numArcs ~= nil and type(numArcs) ~= "number" then
        error(ERROR_TYPE_FORMAT:format(5, "new", "number", typeof(numArcs)), 2)
    elseif numArcs ~= nil and numArcs &lt; 1 then
		error(ERROR_BAD_ARGUMENT:format(5, "new", "number of arcs should be >= 1"), 2)
	elseif fatnessMultiplier ~= nil and type(fatnessMultiplier) ~= "number" then
        error(ERROR_TYPE_FORMAT:format(6, "new", "number", typeof(fatnessMultiplier)), 2)
    elseif fatnessMultiplier ~= nil and fatnessMultiplier &lt; 0 then
        error(ERROR_BAD_ARGUMENT:format(6, "new", "multiplier should be >= 0"), 2)
	elseif enabled ~= nil and type(enabled) ~= "boolean" then
        error(ERROR_TYPE_FORMAT:format(6, "new", "boolean", typeof(enabled)), 2)
	end

	source = source or Vector3.new()
	drain = drain or Vector3.new()
	color = color or Constants.DEFAULT_COLOR
	topColor = topColor or Constants.DEFAULT_TOP_COLOR
	numArcs = numArcs or Constants.DEFAULT_NUM_ARCS
	fatnessMultiplier = fatnessMultiplier or 1

    local self = setmetatable({}, Arc)

    -- Helper variable, vector offset from source to drain
    local axis = (drain - source)

    self.id = Util.getGlobalId()
    self.cframe = Util.makeOrientation(source, axis) -- Orientation (rotation + position) of source of effect
    self.length = axis.magnitude -- Length of effect between its end points
    self.color = color -- Basis color of the effect
    self.topColor = topColor -- Brightest color that will appear
    self.arc = 1 -- Which arc is being animated (loops)
    self.numArcs = numArcs -- Number of arcs at any time inside the effect
	self.arcRenderAmount = 0 -- Number of arcs left to render in next heartbeat (can be a real value)
	self.fatnessMultiplier = fatnessMultiplier -- multiply the computed fatnesses by this number for this arc
    self.visible = true -- Whether effect is on-screen

	-- Part that all effects are attached to, with a light in it
	local sourcePart = Instance.new("Part")
	sourcePart.Name = Constants.PART_NAME_TEMPLATE:format(self.id)
	sourcePart.Anchored = true
	sourcePart.CanCollide = false
	sourcePart.Locked = true
	sourcePart.Archivable = false
	sourcePart.Transparency = 1
	sourcePart.TopSurface = Enum.SurfaceType.Smooth
	sourcePart.BottomSurface = Enum.SurfaceType.Smooth
	sourcePart.Size = Vector3.new(0.05, 0.05, 0.05)
    sourcePart.CFrame = self.cframe
	self.part = sourcePart

	local emitter = Instance.new("Attachment")
	emitter.Name = "Emitter"
	emitter.CFrame = CFrame.new(self.length/2, 0, 0)
	emitter.Parent = sourcePart

	local emitterLight = Instance.new("PointLight")
	emitterLight.Name = "PointLight"
	emitterLight.Brightness = 5
	emitterLight.Color = Color3.new(0, 0, 0):lerp(color, Constants.LIGHT_COLOR_MODIFIER)
	emitterLight.Range = 0
	emitterLight.Shadows = true
	emitterLight.Enabled = Constants.USE_POINTLIGHT
	emitterLight.Parent = emitter

    -- Preparing a pool of particles to be used for the effect
    self.segments = {}
    self.segmentsFolder = Instance.new("Folder")
    self.segmentsFolder.Name = Constants.SEGMENT_FOLDER_NAME_TEMPLATE:format(self.id)
    for i = 1, (numArcs * Constants.SEGMENT_PER_ARC_MAX) do
        local segment = Instance.new("ImageHandleAdornment", self.segmentsFolder)
        segment.Name = Constants.SEGMENT_NAME_TEMPLATE:format(i)
        segment.Image = Constants.ARC_TEXTURE
        segment.Adornee = self.part
        segment.Size = Vector2.new(0, 0)
        segment.ZIndex = 0
        self.segments[i] = segment
    end

    -- Initialize tables that hold the definitions of the individual (animated) arcs
    self.step = {}
    self.amountSegments = {}
    self.totalSteps = {}
    self.path = {}
	self.brightness = {}

    -- Arc paths
    self.axisKeyPoints0 = {}
    self.axisKeyPoints1 = {}
    self.pathT0 = {}
    self.pathT1 = {}
    for arc = 1, numArcs do
        self.pathT0[arc] = {} -- Starting path t=0
        self.pathT1[arc] = {} -- Ending path t=1
        self.step[arc] = 0
        self.amountSegments[arc] = -1 -- Initially the arc has no defined segment count
    end

	if enabled or (enabled == nil and Constants.DEFAULT_ENABLED) then
		-- Add to system if enabled at creation
		System.add(self)
	end

    return self
end

function Arc.link(source, drain, color, topColor, numArcs, fatnessMultiplier, enabled)
	if typeof(source) ~= "Instance" or not source:IsA("Attachment") then
        error(ERROR_TYPE_FORMAT:format(1, "attach", "Attachment", typeof(source)), 2)
    elseif typeof(drain) ~= "Instance" or not drain:IsA("Attachment") then
        error(ERROR_TYPE_FORMAT:format(2, "attach", "Attachment", typeof(drain)), 2)
    elseif color ~= nil and typeof(color) ~= "Color3" then
        error(ERROR_TYPE_FORMAT:format(3, "attach", "Color3", typeof(color)), 2)
    elseif topColor ~= nil and typeof(topColor) ~= "Color3" then
        error(ERROR_TYPE_FORMAT:format(4, "attach", "Color3", typeof(topColor)), 2)
    elseif numArcs ~= nil and type(numArcs) ~= "number" then
        error(ERROR_TYPE_FORMAT:format(5, "attach", "number", typeof(numArcs)), 2)
    elseif numArcs ~= nil and numArcs &lt; 1 then
        error(ERROR_BAD_ARGUMENT:format(5, "attach", "the number of arcs should be >= 1"), 2)
	elseif enabled ~= nil and type(enabled) ~= "boolean" then
        error(ERROR_TYPE_FORMAT:format(6, "attach", "boolean", typeof(enabled)), 2)
	end

	local self = Arc.new(
		source.WorldPosition,
		drain.WorldPosition,
		color,
		topColor,
		numArcs,
		fatnessMultiplier,
		false
	)
	self.dynamic = true
	self.source = source
	self.drain = drain

	if enabled or (enabled == nil and Constants.DEFAULT_ENABLED) then
		-- Add to system if enabled at creation now that self.dynamic is set
		System.add(self)
	end

	return self
end

-- Aliases
Arc.New = Arc.new
Arc.Link = Arc.link

return Arc</string>
          </Properties>
          <Item class="ModuleScript" referent="17">
            <Properties>
              <string name="Name">Constants</string>
              <string name="Source">--[[	Constants.lua
		Contains all constants used by the Arc library.
		This module is licensed under MIT, refer to the LICENSE file or:
		https://github.com/buildthomas/ElectricArc/blob/master/LICENSE
]]

return {

	DEFAULT_COLOR = Color3.new(0.4, 0.8, 1);        -- The darkest color of arcs
	DEFAULT_TOP_COLOR = Color3.new(1, 1, 1);        -- The brightest color of arcs
	DEFAULT_NUM_ARCS = 6;                           -- Default number of arcs
	DEFAULT_ENABLED = true;                         -- Whether enabled at creation

	USE_POINTLIGHT = true;                          -- Whether the arc will have a PointLight in it that flickers
	                                                -- (turning off might improve performance since less lighting updates)

	ARC_TEXTURE = "rbxassetid://750609714";         -- White texture of an arc segment (glowing line)
	ARC_FATNESS_SIZE_MODIFIER = 0.035;              -- Determines fatness based on arc length
	ARC_FATNESS_OVERLAP_RATIO = 0.0625;             -- If segments need to overlap slightly, and how much compared to width
	ARC_STRONG_BRIGHTNESS_THRESHOLD = 0.98;         -- Above which value should brightness be for it to be a strong arc
	ARC_FATNESS_STRONG_MULTIPLIER = 2;              -- How much fatter are strong arcs compared to weak ones
	ARC_MIN_FATNESS = 0.4;
	ARC_MAX_FATNESS = 5;

	LIGHT_COLOR_MODIFIER = 0.8;                     -- Background light properties

	ARCS_MAIN_FOLDER = "ArcParticles";              -- Name of particle and basepart storage in PlayerGui/workspace

	PART_NAME_TEMPLATE = "arc_%05d";                -- Name format of source part
	SEGMENT_FOLDER_NAME_TEMPLATE = "segments_%05d"; -- Name format of top-level segments folder
	SEGMENT_NAME_TEMPLATE = "segment_%05d";         -- Name format of individual segment effects

	AUTO_THROTTLE_FRAME_INTERVAL = 0.500;           -- Interval in seconds over which FPS is calculated for auto-throttling
	AUTO_THROTTLE_INCREMENT = 0.05;                 -- Increment of arc update rate per up/down-throttle
	AUTO_THROTTLE_TARGET = 55;                      -- FPS to target for auto-throttling

	THROTTLE_DISTANCE_MODIFIER_MIN = 20;            -- Minimum for throttle distance modifier
	THROTTLE_DISTANCE_MODIFIER_MAX = 100;           -- Maximum for throttle distance modifier
	-- Lower value = faster drop-off on update rate depending on distance = better performance

	SEGMENT_PER_ARC_MIN = 4;                        -- Minimum number of segments per arc
	SEGMENT_PER_ARC_MAX = 20;                       -- Maximum number of segments per arc

	SEGMENT_THROTTLING_DISTANCE = 100;              -- Distance after which # of segments per arc will start throttling

	MAX_DISTANCE = 1000;                            -- Distance from camera after which no further updating occurs

	ARCS_PER_UPDATE = 2;                            -- How many arcs to update per arc instance

	TWEEN_STEPS_MIN = 2;                            -- Minimum number of tween steps. Cannot be less than 2
	TWEEN_STEPS_MAX = 4;                            -- When an arc has >2 steps, it lerps between path1 and path2

	SEGMENT_MINMAX_RATIO = 24;                      -- Range of arc segment length, as ratio max:min
	                                                -- (ratio is actually this + 1, so 25)

	SEGMENT_ANGULAR_CHANGE_MAX = 0.20 * math.pi;    -- How much an arc segment can rotate about the axis from start to end

	RARE_CHANCE = 0.025;                            -- Chance of an arc being a very long duration, extra fat wandering arc
	RARE_CHANCE_DURATION_MULT = 3;                  -- How much longer rare fat arcs last compared to typical duration

	FOV_FUDGE_FACTOR = 1.25;                        -- Factor to allow for width of arc and viewing of light pool
	                                                -- without seeing animation frozen

}</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="18">
            <Properties>
              <string name="Name">System</string>
              <string name="Source">--[[	System.lua
		Handles internal updating of the graphical effects of the arcs,
		as well as performing throttling for performance.
		This module is licensed under MIT, refer to the LICENSE file or:
		https://github.com/buildthomas/ElectricArc/blob/master/LICENSE
]]

local System = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Constants = require(script.Parent.Constants)
local Util = require(script.Parent.Util)

-- List of running Arc instances
local arcInstances = {}
local dynamicInstances = {}
local numInstances = 0

local heartbeatConnection

-- Create superfolder for all particle folders
local PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
local MainFolder = PlayerGui:FindFirstChild(Constants.ARCS_MAIN_FOLDER)
if not MainFolder then
	MainFolder = Instance.new("ScreenGui")
	MainFolder.Name = Constants.ARCS_MAIN_FOLDER
	MainFolder.Parent = PlayerGui
end
MainFolder.ResetOnSpawn = false

-- Create superfolder for all part folders
local MainPartFolder = workspace:FindFirstChild(Constants.ARCS_MAIN_FOLDER)
if not MainPartFolder then
	MainPartFolder = Instance.new("Folder")
	MainPartFolder.Name = Constants.ARCS_MAIN_FOLDER
	MainPartFolder.Parent = workspace
end

-- Instancing method caching
local vec3 = Vector3.new
local vec2 = Vector2.new
local cframe = CFrame.new
local angles = CFrame.Angles

-- Frequently used instances caching
local zeroVector = vec3(0, 0, 0)
local uz = vec3(0,0,1)
local ux = vec3(1,0,0)

-- Math functions/constants caching
local random = math.random
local floor = math.floor
local acos = math.acos
local rad = math.rad
local min = math.min
local max = math.max
local abs = math.abs
local twopi = math.pi * 2.0
local dot = zeroVector.Dot
local cross = zeroVector.Cross

local autoThrottleRatio = 0.5       -- Current auto-throttling rate
local throttleDistanceModifier = 60 -- Studs distance from camera at which distance-throttling will start
local segmentPerArc = 12            -- Current number of segments per arc (lower number = better performance)

-- Tracking variables for auto-throttling
local frameCount = 0
local frameTick = tick()

local difSegmentsPerArc = Constants.SEGMENT_PER_ARC_MAX - Constants.SEGMENT_PER_ARC_MIN
local difDistanceModifier = Constants.THROTTLE_DISTANCE_MODIFIER_MAX - Constants.THROTTLE_DISTANCE_MODIFIER_MIN

-- Internal method for updating the arcs for a heartbeat
-- (mostly courtesy of AllYourBlox)

local function updateArc(self)
	-- Combined brightness of the arcs on the current render frame, used to update point light
	local totalBrightness = 0

	-- Table cache references
	local step = self.step
	local totalSteps = self.totalSteps
	local brightness = self.brightness
	local axisKeyPoints0 = self.axisKeyPoints0
	local axisKeyPoints1 = self.axisKeyPoints1
	local pathT0 = self.pathT0
	local pathT1 = self.pathT1

	-- Loop from 1 to floor(self.arcRenderAmount)
	for _ = 1, self.arcRenderAmount do

		-- Cache references for current arc
		local arc = self.arc
		local amountSegments

		-- If this is the first step in the animation of an arc, generate the start and end paths
		if step[arc] == 0 then

			-- Determine the resolution in segments for this new arc
			amountSegments = floor(max(2, segmentPerArc * min(1, Constants.SEGMENT_THROTTLING_DISTANCE / self.distance)))
			self.amountSegments[arc] = amountSegments

			-- Randomize how many tween steps this arc will last, with random roll for
			-- chance of an occasional long-duration hot wandering arc
			local rareChance = (random() &lt; Constants.RARE_CHANCE) and 1 or 0
			totalSteps[arc] =
				(Constants.TWEEN_STEPS_MIN + floor(random() * (Constants.TWEEN_STEPS_MAX - Constants.TWEEN_STEPS_MIN)))
				* (1 + rareChance * (Constants.RARE_CHANCE_DURATION_MULT - 1))
			brightness[arc] = (rareChance > 0) and 1 or random()

			-- Midpoint radius of the arc "envelope" is proportional to the length of the arc
			local maxRadius = (0.025 * (totalSteps[arc] / Constants.TWEEN_STEPS_MAX) + 0.05 * (1 + random()))

			-- Random start direction of the first arc segment
			local segmentAngle = random() * twopi

			-- Pick random points along the axis for the discs where arc path points lie
			axisKeyPoints0[1] = 0
			axisKeyPoints1[1] = 0
			for i = 2, amountSegments do
				axisKeyPoints0[i] = axisKeyPoints0[i-1] + 1 + random() * Constants.SEGMENT_MINMAX_RATIO
				axisKeyPoints1[i] = axisKeyPoints1[i-1] + 1 + random() * Constants.SEGMENT_MINMAX_RATIO
			end

			-- Normalize the points to the range [0,1]
			for i = 2, amountSegments do
				axisKeyPoints0[i] = axisKeyPoints0[i] / axisKeyPoints0[amountSegments]
				axisKeyPoints1[i] = axisKeyPoints1[i] / axisKeyPoints1[amountSegments]
			end

			-- Calculate the path points
			local ur, r

			-- pathT0
			for i = 1, amountSegments do
				ur = angles(segmentAngle, 0, 0) * uz

				-- r is the distance of the path point from the axis line segment, and this formula is the shape of the envelope
				-- of the arc (0 at the endpoints, maxRadius at the middle, with clamping so that long arcs don't get too wide)
				r = min(maxRadius * 0.5, (0.5 - abs(0.5 - axisKeyPoints0[i])) * 4 * maxRadius * (0.25 + 0.75 * random()))
				pathT0[arc][i] = axisKeyPoints0[i] * ux + r * ur
				segmentAngle = segmentAngle + random(-1, 1) * Constants.SEGMENT_ANGULAR_CHANGE_MAX
			end

			-- pathT1
			-- A long duration arc will lerp from a narrower arc to a wider one, end here refers to t=1 animation end state
			local endRadiusMult = 1.0 + 0.5 * (totalSteps[arc] - Constants.TWEEN_STEPS_MIN)
				/ (Constants.TWEEN_STEPS_MAX * Constants.RARE_CHANCE_DURATION_MULT - Constants.TWEEN_STEPS_MIN)
			for i = 1, amountSegments do
				ur = angles(segmentAngle, 0, 0) * uz
				r = min( -- The arc envelope
					maxRadius * 0.5 * endRadiusMult,
					(0.5 - abs(0.5 - axisKeyPoints1[i])) * 4 * maxRadius * (0.25 + 0.75 * random())
				)
				pathT1[arc][i] = axisKeyPoints1[i] * ux + r * ur
				segmentAngle = segmentAngle + random(-1,1) * Constants.SEGMENT_ANGULAR_CHANGE_MAX
				self.segments[i + (arc-1) * Constants.SEGMENT_PER_ARC_MAX].Parent = self.segmentsFolder
			end

			-- Unparent unneeded segments from the game hierarchy to improve performance
			for i = amountSegments + 1, Constants.SEGMENT_PER_ARC_MAX do
				self.segments[i + (arc-1) * Constants.SEGMENT_PER_ARC_MAX].Parent = nil
			end

		else
			-- Existing arc, just import the segment count
			amountSegments = self.amountSegments[arc]
		end

		-- Initialize values
		totalBrightness = 0
		local prevEndpoint = zeroVector
		local t = step[arc] / (totalSteps[arc]-1)
		totalBrightness = totalBrightness + brightness[arc]

		-- Lerp color towards specified top color based on brightness
		local color = self.color:lerp(self.topColor, brightness[arc])

		-- Fatness of arc based on its brightness and length, capped on min/max
		local fatness = math.clamp(
			self.fatnessMultiplier * self.length * Constants.ARC_FATNESS_SIZE_MODIFIER
				* (brightness[arc] > Constants.ARC_STRONG_BRIGHTNESS_THRESHOLD and Constants.ARC_FATNESS_STRONG_MULTIPLIER or 1),
			Constants.ARC_MIN_FATNESS,
			Constants.ARC_MAX_FATNESS
		)

		-- Relative position of camera w.r.t. this effect:
		local camPos = self.cframe:inverse() * workspace.CurrentCamera.CFrame.p

		-- Loop over segment count for this arc, and simply update animation:
		for i = 1, amountSegments do

			-- Lerp from pathT0 to pathT1, adjusted by arcLength:
			local endpoint = self.length * (t * pathT1[arc][i] + (1-t) * pathT0[arc][i])

			-- Get image texture handle for this segment:
			local imgAdornment = self.segments[i + (arc-1) * Constants.SEGMENT_PER_ARC_MAX]

			-- Offset from last point to current one
			local diff = endpoint - prevEndpoint

			-- Calculate position and up/left/front vectors
			local po = (prevEndpoint + endpoint)/2
			local up = diff.unit
			local lf = cross(camPos - po, up).unit
			local fr = cross(lf, up).unit

			-- Update handle
			imgAdornment.Size = vec2(fatness, diff.magnitude + fatness * Constants.ARC_FATNESS_OVERLAP_RATIO)
			imgAdornment.Color3 = color
			imgAdornment.CFrame = cframe(
				po.x, po.y, po.z,
				lf.x, up.x, fr.x,
				lf.y, up.y, fr.y,
				lf.z, up.z, fr.z
			)

			-- Update prevEndpoint
			prevEndpoint = endpoint

		end

		-- Update step count for current arc and then move to next arc to update
		step[arc] = (step[arc] + 1) % totalSteps[arc]
		self.arc = (arc % self.numArcs) + 1

	end

	-- Update brightness of light in emitter part
	self.part.Emitter.PointLight.Brightness = totalBrightness / self.numArcs

	-- Subtract integer part from the amount of arcs to be updated
	self.arcRenderAmount = self.arcRenderAmount % 1
end

-- Global update loop on heartbeat
-- (for performance / user-friendliness reasons, it is better to do a global loop over all
-- objects at Heartbeat rather than exposing an API method to update individual objects)
local function onHeartbeat()
	-- Cache camera-related values and references
	local camera = workspace.CurrentCamera
	local camPos = camera.CFrame.p
	local look = camera.CFrame.lookVector

	local fov = Constants.FOV_FUDGE_FACTOR * rad(camera.FieldOfView * camera.ViewportSize.x / camera.ViewportSize.y) / 2.0

	for v, _ in pairs(dynamicInstances) do
		local source = v.source.WorldPosition
		local axis = v.drain.WorldPosition - source
		if axis.magnitude &lt; 0.001 then
			axis = Vector3.new(0, 0, -0.001)
		end
		v.length = axis.magnitude
		v.cframe = Util.makeOrientation(source, axis)
		v.part.CFrame = v.cframe
		v.part.Emitter.CFrame = CFrame.new(v.length/2, 0, 0)
		v.part.Emitter.PointLight.Range = v.length
	end

	-- Check if objects are on/off-screen
	for v, _ in pairs(arcInstances) do
		local camToSource = v.cframe.p - camPos
		local camToDrain = v.cframe * vec3(v.length, 0, 0) - camPos

		-- Check if on-screen:
		if acos(dot(camToSource.unit, look)) > fov and acos(dot(camToDrain.unit, look)) > fov then
			-- Else, make visible and reparent, if not already done
			-- Not on-screen, turn invisible and unparent if not already
			if v.visible then
				v.visible = false
				v.segmentsFolder.Parent = nil
			end
		elseif not v.visible then
			v.visible = true
			v.segmentsFolder.Parent = MainFolder
		end

		-- Set average distance to camera for throttling purposes
		v.distance = (camToSource.magnitude + camToDrain.magnitude) / 2
	end

	-- Check if objects should be updated and do so
	for v, _ in pairs(arcInstances) do
		-- Only update enabled and visible objects
		if v.visible then
			-- Update CFrame/Size of instances if object values were changed
			if v.changed then
				v.part.CFrame = v.cframe
				v.part.Emitter.CFrame = CFrame.new(v.length/2, 0, 0)
				v.part.Emitter.PointLight.Range = v.length
				v.changed = false
			end

			-- Update amount of arcs that can be rendered in this step (can be real, not just integer)
			if v.distance &lt; Constants.MAX_DISTANCE then
				v.arcRenderAmount = v.arcRenderAmount + min(
					v.numArcs / 3,
					Constants.ARCS_PER_UPDATE * min(1, throttleDistanceModifier / v.distance)
				)
				updateArc(v)
			end
		end
	end

	-- Increase frame count
	frameCount = frameCount + 1

	-- Calculate time since last throttling check
	local deltaTime = tick() - frameTick

	-- Check if auto-throttling window has passed
	if deltaTime > Constants.AUTO_THROTTLE_FRAME_INTERVAL then
		-- Update auto-throttling ratio based on observed FPS w.r.t. target FPS
		autoThrottleRatio = max(0, min(1, autoThrottleRatio + Constants.AUTO_THROTTLE_INCREMENT
				* (frameCount / deltaTime - Constants.AUTO_THROTTLE_TARGET)))

		-- Update variables dependent on auto-throttling rate
		segmentPerArc = floor(Constants.SEGMENT_PER_ARC_MIN + (difSegmentsPerArc * autoThrottleRatio) + 0.5)
		throttleDistanceModifier = Constants.THROTTLE_DISTANCE_MODIFIER_MIN
			+ (difDistanceModifier * autoThrottleRatio)

		-- Reset tracking variables
		frameCount = 0
		frameTick = tick()
	end
end

local function updateConnection()
	if numInstances &lt;= 0 then
		if heartbeatConnection then
			heartbeatConnection:Disconnect()
			heartbeatConnection = nil
		end
	else
		if not heartbeatConnection then
			heartbeatConnection = RunService.Heartbeat:Connect(onHeartbeat)
		end
	end
end

-- Adding an arc to the running system
function System.add(arc)
	if not arcInstances[arc] then
		arcInstances[arc] = true
		numInstances = numInstances + 1
		arc.segmentsFolder.Parent = MainFolder
		arc.part.Parent = MainPartFolder
		if arc.dynamic then
			dynamicInstances[arc] = true
		end
		updateConnection()
	end
end

function System.contains(arc)
	return arcInstances[arc] ~= nil
end

-- Removing an arc from the running system
function System.remove(arc)
	if arcInstances[arc] then
		arcInstances[arc] = nil
		dynamicInstances[arc] = nil
		numInstances = numInstances - 1
		arc.segmentsFolder.Parent = nil
		arc.part.Parent = nil
		updateConnection()
	end
end

return System</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="19">
            <Properties>
              <string name="Name">Util</string>
              <string name="Source">--[[	Util.lua
		Some utility functions used by the other files in the Arc library.
		This module is licensed under MIT, refer to the LICENSE file or:
		https://github.com/buildthomas/ElectricArc/blob/master/LICENSE
]]

local Util = {}

local GLOBAL_ID = 0

-- Obtaining a unique ID for every call
function Util.getGlobalId()
	GLOBAL_ID = GLOBAL_ID + 1
	return GLOBAL_ID
end

-- Shorthands
local vec3 = Vector3.new
local cframe = CFrame.new
local zeroVector = vec3(0, 0, 0)
local uz = vec3(0, 0, 1)
local ux = vec3(1, 0, 0)
local sqrt = math.sqrt
local dot = zeroVector.Dot
local cross = zeroVector.Cross

--[[
-- Unused because too expensive to be worth the benefit since you'd have to call it often
local function RealignArcToCamera(self)
    local relativeCamPos = self.cframe:inverse() * workspace.CurrentCamera.CFrame.p
    for _, v in pairs(self.segments) do
        local c = v.CFrame
        local po = c.p
        local up = c.upVector
        local lf = cross(relativeCamPos - po, up).unit
        local fr = cross(lf, up).unit
        v.CFrame = cframe(po.x, po.y, po.z, lf.x, up.x, fr.x, lf.y, up.y, fr.y, lf.z, up.z, fr.z)
    end
end
]]

-- Making a CFrame value from an origin position and unit direction:
function Util.makeOrientation(sourcePos, dir)
    -- Construct CFrame to rotate parts from x-axis alignment (where they are constructed) to
    -- the world orientation of the arc from a quaternion rotation that describes the
    -- rotation of ux-->axis
    dir = dir.unit

    -- Proportionate angle between ux and direction:
    local angleUxAxis = dot(ux, dir)

    if (angleUxAxis > 0.99999) then
        return cframe(sourcePos, sourcePos - uz)
    elseif (angleUxAxis &lt; -0.99999) then
        return cframe(sourcePos, sourcePos + uz)
    else
        local q = cross(ux, dir)
        local qw = 1 + angleUxAxis
        local qnorm = sqrt(q.magnitude ^ 2 + qw * qw)
        q = q / qnorm
        qw = qw / qnorm
        return cframe(sourcePos.x, sourcePos.y, sourcePos.z, q.x, q.y, q.z, qw)
    end
end

return Util</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="20">
          <Properties>
            <string name="Name">Event</string>
            <string name="Source">-- Event
-- Crazyman32
-- March 17, 2017

--[[
	
	event = Event.new()
	
	
	event:Fire(...)
	event:Wait()
	event:DisconnectAll()
	
	connection = event:Connect(func)
		connection.Connected
		connection:Disconnect()
	
	event:Destroy()
	
--]]



local CO_WRAP = coroutine.wrap
local BLANK_FUNC = function() end


local Event = {}
Event.__index = Event

local Connection = {}
Connection.__index = Connection


function Event.new()
	
	local self = setmetatable({
		_connections = {};
		_destroyed = false;
		_firing = false;
	}, Event)
	
	return self
	
end


function Event:Fire(...)
	self._firing = true
	local connections = self._connections
	for i = 1,#connections do
		local f = connections[i]._func
		CO_WRAP(f)(...)
	end
	self._firing = false
end


function Event:Wait()
	local c, returnArgs = nil, nil
	local be = Instance.new("BindableEvent")
	c = self:Connect(function(...)
		c:Disconnect()
		returnArgs = {...}
		be:Fire()
	end)
	be.Event:Wait()
	be:Destroy()
	return unpack(returnArgs)
end


function Event:Connect(func)
	assert(not self._destroyed, "Cannot connect to destroyed event")
	assert(type(func) == "function", "Argument must be function")
	local connection = Connection.new(func, self)
	table.insert(self._connections, connection)
	return connection
end


function Event:DisconnectAll()
	local function DisconnectAll()
		for _,c in pairs(self._connections) do
			c.IsConnected = false
		end
		self._connections = {}
	end
	if (self._firing) then
		for _,c in pairs(self._connections) do
			c._func = BLANK_FUNC
		end
		spawn(function()
			DisconnectAll()
		end)
	else
		DisconnectAll()
	end
end


function Event:Disconnect(connection)
	local function Disconnect()
		for i,c in pairs(self._connections) do
			if (c == connection) then
				table.remove(self._connections, i)
				break
			end
		end
	end
	if (self._firing) then		
		connection._func = BLANK_FUNC
		spawn(Disconnect)
	else
		Disconnect()
	end
end


function Event:Destroy()
	if (self._destroyed) then return end
	self._destroyed = true
	self:DisconnectAll()
end


function Connection.new(func, event)
	local self = setmetatable({
		Connected = true;
		_func = func;
		_event = event;
	}, Connection)
	return self
end


function Connection:Disconnect()
	if (not self.Connected) then return end
	self.Connected = false
	self._event:Disconnect(self)
end


return Event</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="21">
          <Properties>
            <string name="Name">Timer</string>
            <string name="Source">--[[
	Timer Class
	
	Acts as a simple timer, with basic count up/count down capabilities, with events.
	
	Programmed by @Reshiram110
	
	Last updated : 10-17-2018 @ 2:17 AM EST
--]]

---------------------
-- Roblox Services --
---------------------
local RunService=game:GetService("RunService")

-------------
-- DEFINES --
-------------
local Timer={}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : RunTimer
-- @Description : Runs the timer until the time position reaches Max_Time or Min_Time, or until Timer.Running is false.
--                Whether or not it increments/decrements the TimePosition is determined by Timer.Mode.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
local function RunTimer(Timer)
	Timer.IsRunning=true
	Timer.Events.Started:Fire()
	
	local LastStartTick=tick()
	
	while Timer.IsRunning do
		local Delta=RunService.Heartbeat:wait()
		
		if Timer.Mode=="Up" then
			Timer.TimePosition=math.min(Timer.TimePosition+(Delta*Timer.Speed),Timer.MaxTime)
		elseif Timer.Mode=="Down" then
			Timer.TimePosition=math.max(Timer.TimePosition-(Delta*Timer.Speed),Timer.MinTime)
		else --Invalid mode.
			warn("[Timer] Timer '"..Timer.Name.."' was set to an invalid mode : '"..Timer.Mode.."'")
			Timer.IsRunning=false
		end
		
		if tick()-LastStartTick>=Timer.TickInterval then --Fire the tick signal, the tick interval is up
			Timer.Events.Tick:Fire()
			LastStartTick=tick()
		end
		
		if Timer.TimePosition==Timer.MaxTime or Timer.TimePosition==Timer.MinTime then Timer.IsRunning=false end
	end
	Timer.Events.Stopped:Fire()
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : New
-- @Description : Creates a new instance of the timer class and returns it.
-- @Params : string "Name" - The name of the timer.
--           string "Timer_Mode" - The mode of the timer.
--           Number "Max_Time" - The maximum time value of the timer.
--           Number "Tick_Interval" - The interval (in seconds) to update the timer.
--           Number "Speed" - The speed at which the timer runs.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Timer.new(Name,Timer_Mode,Max_Time,Tick_Interval,Speed)
	local NewTimer={
		Name=Name or "Timer",
		MinTime=0,
		MaxTime=Max_Time or math.huge,
		TickInterval=Tick_Interval or 1,
		Speed=Speed or 1,
		
		TimePosition=Max_Time or 0,
		Mode=Timer_Mode or "Down",
		IsRunning=false,
		
		Events={
			Started=Instance.new('BindableEvent'),
			Stopped=Instance.new('BindableEvent'),
			Tick=Instance.new('BindableEvent'),
		},
	}
	NewTimer.Started=NewTimer.Events.Started.Event
	NewTimer.Stopped=NewTimer.Events.Stopped.Event
	NewTimer.Tick=NewTimer.Events.Tick.Event
	if (NewTimer.Mode~="Down" and NewTimer.Mode~="Up") then NewTimer.Mode="Down" end
	
	setmetatable(NewTimer,{__index=Timer})
	
	return NewTimer
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : GetTimestamp
-- @Description : Returns the current timestamp of the timer in the specified format.
-- @Params : string "Format" - The format to return the timestamp in. Acceptable formats are as follows:
--                             HMS - Hours, minutes and seconds | HH:MM:SS
--                             MS - Minutes and seconds only | MM:SS
--                             S - Seconds only | SS
--                             M - Minutes only | MM
--                             H - Hours only | HH
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Timer:GetTimestamp(Format)
	local Seconds=self.TimePosition
	
	if Format=="HMS" then
		local H=string.format("%02.f",math.floor(Seconds/3600))
		local M=string.format("%02.f",math.floor(Seconds/60-(H*60)))
		local S=string.format("%02.f",math.floor(Seconds-H*3600-M*60))
		return H..":"..M..":"..S
	elseif Format=="MS" then
		local M=string.format("%02.f",math.floor(Seconds/60))
		local S=string.format("%02.f",math.floor(Seconds-M*60))
		return M..":"..S
	elseif Format=="S" then
		local S=string.format("%02.f",math.floor(Seconds))
		return S
	elseif Format=="M" then
		local M=string.format("%02.f",math.floor(Seconds/60))
		return M
	elseif Format=="H" then
		local H=string.format("%02.f",math.floor(Seconds/3600))
		return H
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Start
-- @Description : Starts the timer.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Timer:Start()
	self:Reset()
	coroutine.wrap(RunTimer)(self)
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Stop
-- @Description : Stops the timer.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Timer:Stop()
	if self.IsRunning then
		self.IsRunning=false
		self.Stopped:wait()
	end
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Resume
-- @Description : Resumes the timer.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Timer:Resume()
	coroutine.wrap(RunTimer)(self)
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- @Name : Reset
-- @Description : Resets the timer.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function Timer:Reset()
	self:Stop()
	if self.Mode=="Up" then
		self.TimePosition=self.MinTime
	elseif self.Mode=="Down" then
		self.TimePosition=self.MaxTime
	else --Invalid mode
		warn("[Timer] Timer '"..self.Name.."' was set to an invalid mode : '"..self.Mode.."'")
	end
end

return Timer</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="22">
        <Properties>
          <string name="Name">Utils</string>
        </Properties>
        <Item class="ModuleScript" referent="23">
          <Properties>
            <string name="Name">AssetUtils</string>
            <string name="Source">local AssetUtils={}

function AssetUtils:PreloadAsync(Asset,Type)
	local ContentProvider=game:GetService("ContentProvider")

	if Type=="Texture" then
		ContentProvider:PreloadAsync({"rbxassetid://"..Asset})
	elseif Type=="Sound" or Type=="Audio" then
		local Audio=Instance.new('Sound')
		Audio.SoundId="rbxassetid://"..Asset
		ContentProvider:PreloadAsync({Audio})
		Audio:Destroy()
	elseif Type=="Mesh" then
		local Mesh=Instance.new('SpecialMesh')
		Mesh.MeshId=Asset
		ContentProvider:PreloadAsync({Mesh})
		Mesh:Destroy()
	end
end

return AssetUtils</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="24">
          <Properties>
            <string name="Name">Instance</string>
            <string name="Source">local InstanceUtils={}

for _,Module in pairs(script:GetChildren()) do
	InstanceUtils[Module.Name]=require(Module)
end

return InstanceUtils</string>
          </Properties>
          <Item class="ModuleScript" referent="25">
            <Properties>
              <string name="Name">GetInstanceFromPath</string>
              <string name="Source">return function(Path)
	local Objects={}
	local ObjectReference=game
	
	for Object in string.gmatch(Path,"%w+") do
		if Object~="game" then
			table.insert(Objects,Object)
		end
	end
	
	for _,Object in next,Objects do
		ObjectReference=ObjectReference[Object]
	end
	
	return ObjectReference
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="26">
            <Properties>
              <string name="Name">WrapInstance</string>
              <string name="Source">return function(RealObject)
	local wrapped, Custom;
	local Childs = setmetatable({}, {
		__index = function(t, k)
			--print("__index of Childs:", t, k)
			local stat, val = pcall(function() return RealObject[k] end)
			if stat then
				if type(val) == "function" then
					-- return a wrapper
					return function(a, ...)
						if a == wrapped and k:lower() == "remove" or k:lower() == "destroy" then
							AddChild(nil, wrapped, Custom)
						end
						RealObject[k](RealObject, ...)
					end
				else
					return RealObject[k]
				end
			else
				return RealObject[k] -- this will error, but we want it to
			end
		end,
		__newindex = function() error("This table is read-only") end
	})
	Custom = setmetatable({
			Children = Childs,
			Parent = "nil"		
		}, {
		__index = Childs, 
		__call = function() return RealObject end, 
		__metatable = "The metatable is locked"
	})
	wrapped = setmetatable({}, {
		__index = function(t, k)
			if k == "FindFirstChild" then
				return FindFirstChild
			elseif k == "GetChildren" then
				return GetChildren
			else
				return Custom[k]
			end
		end, 
		__call = function() return RealObject end, 
		__tostring = function() return tostring(RealObject) end,
		__newindex = function(t, k, v)
			if k == "Parent" then
				AddChild(v, t, Custom)
				return
			end
			local stat = pcall(function() return RealObject[k] end)
			if stat then 
				-- Property exists in real object
				-- if name, change name in Childs table
				if k == "Name" then
					if t.Parent ~= "nil" then
						rawset(t.Parent.Children, v, t)
--						print("Changed entry [", v, "] to", t)
						rawset(t.Parent.Children, tostring(t), nil)
--						print("Changed entry [", tostring(t), "] to nil")
--						for _, v in pairs(t.Parent.Children) do
--							print(_)
--						end
					end
				end
				RealObject[k] = v
--				print("Changed name to", RealObject.Name)
--				print("Verification (raw):", rawget(Childs, v))
--				print("Varification (std):", Childs[v])
			else
				-- Property is not real. Add to custom props
				Custom[k] = v 
			end
		end,
		__metatable = "The metatable is locked",
	})
	return wrapped
end</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="27">
          <Properties>
            <string name="Name">Math</string>
            <string name="Source">--[[
	Math library
	
	Contains useful math functions
--]]

-------------
-- DEFINES --
-------------
local Rand=Random.new()

local Math={}

function Math:GetRandomVec3FromPart(Part)
    local x = Part.Position.X
	local xS = Part.Size.X / 2
	local y = Part.Position.Y
	local z = Part.Position.Z
	local zS = Part.Size.Z / 2
	local pos = Vector3.new(Rand:NextNumber(math.min(x - xS), math.max(xS + x)), y, Rand:NextNumber(math.min(z - zS), math.max(zS + z)))
	return pos
end

return Math</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="28">
          <Properties>
            <string name="Name">Rig</string>
            <string name="Source">--[[
	Rig Utilities
	
	Contains useful functions for the manipulation of character rigs.
--]]

local RigUtils={}

function RigUtils:GetAttachmentFromCharacter(Character,AttachmentName)
	local RigType=""
	local Attachments={
		["HairAttachment"]={["R6"]="Head",["R15"]="Head"},
		["HatAttachment"]={["R6"]="Head",["R15"]="Head"},
		["FaceFrontAttachment"]={["R6"]="Head",["R15"]="Head"},
		["FaceCenterAttachment"]={["R6"]="Head",["R15"]="Head"},
		["NeckAttachment"]={["R6"]="Torso",["R15"]="UpperTorso"},
		["BodyFrontAttachment"]={["R6"]="Torso",["R15"]="UpperTorso"},
		["BodyBackAttachment"]={["R6"]="Torso",["R15"]="UpperTorso"},
		["LeftCollarAttachment"]={["R6"]="Torso",["R15"]="UpperTorso"},
		["RightCollarAttachment"]={["R6"]="Torso",["R15"]="UpperTorso"},
		["WaistFrontAttachment"]={["R6"]="Torso",["R15"]="LowerTorso"},
		["WaistCenterAttachment"]={["R6"]="Torso",["R15"]="LowerTorso"},
		["WaistBackAttachment"]={["R6"]="Torso",["R15"]="LowerTorso"},
		["LeftShoulderAttachment"]={["R6"]="Left Arm",["R15"]="LeftUpperArm"},
		["LeftGripAttachment"]={["R6"]="Left Arm",["R15"]="LeftHand"},
		["RightShoulderAttachment"]={["R6"]="Right Arm",["R15"]="RightUpperArm"},
		["RightGripAttachment"]={["R6"]="Right Arm",["R15"]="RightHand"},
		["LeftFootAttachment"]={["R6"]="Left Leg",["R15"]="LeftFoot"},
		["RightFootAttachment"]={["R6"]="Right Leg",["R15"]="RightFoot"},
		["RootAttachment"]={["R6"]="HumanoidRootPart",["R15"]="None"},
		--[[R15 exclusive attachments]]--
		["RootRigAttachment"]={["R6"]="None",["R15"]="HumanoidRootPart"},
		["LeftWristRigAttachment"]={["R6"]="None",["R15"]="LeftHand"},
		["LeftElbowRigAttachment"]={["R6"]="None",["R15"]="LeftLowerArm"},
		["LeftWristRigAttachment"]={["R6"]="None",["R15"]="LeftLowerArm"},
		["LeftShoulderRigAttachment"]={["R6"]="None",["R15"]="LeftUpperArm"},
		["LeftElbowRigAttachment"]={["R6"]="None",["R15"]="LeftUpperArm"},
		["RightWristRigAttachment"]={["R6"]="None",["R15"]="RightHand"},
		["RightElbowRigAttachment"]={["R6"]="None",["R15"]="RightLowerArm"},
		["RightWristRigAttachment"]={["R6"]="None",["R15"]="RightLowerArm"},
		["RightShoulderRigAttachment"]={["R6"]="None",["R15"]="RightUpperArm"},
		["RightElbowRigAttachment"]={["R6"]="None",["R15"]="RightUpperArm"},
		["WaistRigAttachment"]={["R6"]="None",["R15"]="UpperTorso"},
		["NeckRigAttachment"]={["R6"]="None",["R15"]="UpperTorso"},
		["LeftShoulderRigAttachment"]={["R6"]="None",["R15"]="UpperTorso"},
		["RightShoulderRigAttachment"]={["R6"]="None",["R15"]="UpperTorso"},
		["LeftAnkleRigAttachment"]={["R6"]="None",["R15"]="LeftFoot"},
		["LeftKneeRigAttachment"]={["R6"]="None",["R15"]="LeftLowerLeg"},
		["LeftAnkleRigAttachment"]={["R6"]="None",["R15"]="LowerLeftLeg"},
		["LeftHipRigAttachment"]={["R6"]="None",["R15"]="LeftUpperLeg"},
		["LeftKneeRigAttachment"]={["R6"]="None",["R15"]="LeftUpperLeg"},
		["RightAnkleRigAttachment"]={["R6"]="None",["R15"]="RightFoot"},
		["RightKneeRigAttachment"]={["R6"]="None",["R15"]="RightLowerLeg"},
		["RightAnkleRigAttachment"]={["R6"]="None",["R15"]="RightLowerLeg"},
		["RightHipRigAttachment"]={["R6"]="None",["R15"]="RightUpperLeg"},
		["RightKneeRigAttachment"]={["R6"]="None",["R15"]="RightUpperLeg"},
		["RootRigAttachment"]={["R6"]="None",["R15"]="LowerTorso"},
		["WaistRigAttachment"]={["R6"]="None",["R15"]="LowerTorso"},
		["LeftHipRigAttachment"]={["R6"]="None",["R15"]="LowerTorso"},
		["RightHipRigAttachment"]={["R6"]="None",["R15"]="LowerTorso"},
		["NeckRigAttachment"]={["R6"]="None",["R15"]="Head"}
	}
	
	if Character.Humanoid.RigType==Enum.HumanoidRigType.R6 then RigType="R6" end
	if Character.Humanoid.RigType==Enum.HumanoidRigType.R15 then RigType="R15" end
	local Attachment=Character[Attachments[AttachmentName][RigType]][AttachmentName]
	return Attachment
end

return RigUtils</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="29">
          <Properties>
            <string name="Name">String</string>
          </Properties>
          <Item class="ModuleScript" referent="30">
            <Properties>
              <string name="Name">Compression</string>
              <string name="Source">--[[
MIT License
Copyright (c) 2016 Rochet2
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
]]

local char = string.char
local type = type
local select = select
local sub = string.sub
local tconcat = table.concat

local basedictcompress = {}
local basedictdecompress = {}
for i = 0, 255 do
    local ic, iic = char(i), char(i, 0)
    basedictcompress[ic] = iic
    basedictdecompress[iic] = ic
end

local function dictAddA(str, dict, a, b)
    if a >= 256 then
        a, b = 0, b+1
        if b >= 256 then
            dict = {}
            b = 1
        end
    end
    dict[str] = char(a,b)
    a = a+1
    return dict, a, b
end

local function compress(input)
    if type(input) ~= "string" then
        return nil, "string expected, got "..type(input)
    end
    local len = #input
    if len &lt;= 1 then
        return "u"..input
    end

    local dict = {}
    local a, b = 0, 1

    local result = {"c"}
    local resultlen = 1
    local n = 2
    local word = ""
    for i = 1, len do
        local c = sub(input, i, i)
        local wc = word..c
        if not (basedictcompress[wc] or dict[wc]) then
            local write = basedictcompress[word] or dict[word]
            if not write then
                return nil, "algorithm error, could not fetch word"
            end
            result[n] = write
            resultlen = resultlen + #write
            n = n+1
            if  len &lt;= resultlen then
                return "u"..input
            end
            dict, a, b = dictAddA(wc, dict, a, b)
            word = c
        else
            word = wc
        end
    end
    result[n] = basedictcompress[word] or dict[word]
    resultlen = resultlen+#result[n]
    n = n+1
    if  len &lt;= resultlen then
        return "u"..input
    end
    return tconcat(result)
end

local function dictAddB(str, dict, a, b)
    if a >= 256 then
        a, b = 0, b+1
        if b >= 256 then
            dict = {}
            b = 1
        end
    end
    dict[char(a,b)] = str
    a = a+1
    return dict, a, b
end

local function decompress(input)
    if type(input) ~= "string" then
        return nil, "string expected, got "..type(input)
    end

    if #input &lt; 1 then
        return nil, "invalid input - not a compressed string"
    end

    local control = sub(input, 1, 1)
    if control == "u" then
        return sub(input, 2)
    elseif control ~= "c" then
        return nil, "invalid input - not a compressed string"
    end
    input = sub(input, 2)
    local len = #input

    if len &lt; 2 then
        return nil, "invalid input - not a compressed string"
    end

    local dict = {}
    local a, b = 0, 1

    local result = {}
    local n = 1
    local last = sub(input, 1, 2)
    result[n] = basedictdecompress[last] or dict[last]
    n = n+1
    for i = 3, len, 2 do
        local code = sub(input, i, i+1)
        local lastStr = basedictdecompress[last] or dict[last]
        if not lastStr then
            return nil, "could not find last from dict. Invalid input?"
        end
        local toAdd = basedictdecompress[code] or dict[code]
        if toAdd then
            result[n] = toAdd
            n = n+1
            dict, a, b = dictAddB(lastStr..sub(toAdd, 1, 1), dict, a, b)
        else
            local tmp = lastStr..sub(lastStr, 1, 1)
            result[n] = tmp
            n = n+1
            dict, a, b = dictAddB(tmp, dict, a, b)
        end
        last = code
    end
    return tconcat(result)
end

return {
    Compress = compress,
    Decompress = decompress,
}</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="31">
            <Properties>
              <string name="Name">MD5</string>
              <string name="Source">local md5 = {
  _VERSION     = "md5.lua 1.1.0",
  _DESCRIPTION = "MD5 computation in Lua (5.1-3, LuaJIT)",
  _URL         = "https://github.com/kikito/md5.lua",
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2013 Enrique García Cota + Adam Baldwin + hanzao + Equi 4 Software

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

-- bit lib implementions

local char, byte, format, rep, sub =
  string.char, string.byte, string.format, string.rep, string.sub
local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift

local ok, bit = pcall(require, 'bit')
if ok then
  bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift
else
  ok, bit = pcall(require, 'bit32')

  if ok then

    bit_not = bit.bnot

    local tobit = function(n)
      return n &lt;= 0x7fffffff and n or -(bit_not(n) + 1)
    end

    local normalize = function(f)
      return function(a,b) return tobit(f(tobit(a), tobit(b))) end
    end

    bit_or, bit_and, bit_xor = normalize(bit.bor), normalize(bit.band), normalize(bit.bxor)
    bit_rshift, bit_lshift = normalize(bit.rshift), normalize(bit.lshift)

  else

    local function tbl2number(tbl)
      local result = 0
      local power = 1
      for i = 1, #tbl do
        result = result + tbl[i] * power
        power = power * 2
      end
      return result
    end

    local function expand(t1, t2)
      local big, small = t1, t2
      if(#big &lt; #small) then
        big, small = small, big
      end
      -- expand small
      for i = #small + 1, #big do
        small[i] = 0
      end
    end

    local to_bits -- needs to be declared before bit_not

    bit_not = function(n)
      local tbl = to_bits(n)
      local size = math.max(#tbl, 32)
      for i = 1, size do
        if(tbl[i] == 1) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end
      return tbl2number(tbl)
    end

    -- defined as local above
    to_bits = function (n)
      if(n &lt; 0) then
        -- negative
        return to_bits(bit_not(math.abs(n)) + 1)
      end
      -- to bits table
      local tbl = {}
      local cnt = 1
      local last
      while n > 0 do
        last      = n % 2
        tbl[cnt]  = last
        n         = (n-last)/2
        cnt       = cnt + 1
      end

      return tbl
    end

    bit_or = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 and tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_and = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 or tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_xor = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i] ~= tbl_n[i]) then
          tbl[i] = 1
        else
          tbl[i] = 0
        end
      end

      return tbl2number(tbl)
    end

    bit_rshift = function(n, bits)
      local high_bit = 0
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
        high_bit = 0x80000000
      end

      local floor = math.floor

      for i=1, bits do
        n = n/2
        n = bit_or(floor(n), high_bit)
      end
      return floor(n)
    end

    bit_lshift = function(n, bits)
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
      end

      for i=1, bits do
        n = n*2
      end
      return bit_and(n, 0xFFFFFFFF)
    end
  end
end

-- convert little-endian 32-bit int to a 4-char string
local function lei2str(i)
  local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
  return f(0)..f(8)..f(16)..f(24)
end

-- convert raw string to big-endian int
local function str2bei(s)
  local v=0
  for i=1, #s do
    v = v * 256 + byte(s, i)
  end
  return v
end

-- convert raw string to little-endian int
local function str2lei(s)
  local v=0
  for i = #s,1,-1 do
    v = v*256 + byte(s, i)
  end
  return v
end

-- cut up a string in little-endian ints of given size
local function cut_le_str(s,...)
  local o, r = 1, {}
  local args = {...}
  for i=1, #args do
    table.insert(r, str2lei(sub(s, o, o + args[i] - 1)))
    o = o + args[i]
  end
  return r
end

local swap = function (w) return str2bei(lei2str(w)) end

-- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
-- 10/02/2001 jcw@equi4.com

local CONSTS = {
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
}

local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
local z=function (ff,a,b,c,d,x,s,ac)
  a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
  -- be *very* careful that left shift does not cause rounding!
  return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
end

local function transform(A,B,C,D,X)
  local a,b,c,d=A,B,C,D
  local t=CONSTS

  a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
  d=z(f,d,a,b,c,X[ 1],12,t[ 2])
  c=z(f,c,d,a,b,X[ 2],17,t[ 3])
  b=z(f,b,c,d,a,X[ 3],22,t[ 4])
  a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
  d=z(f,d,a,b,c,X[ 5],12,t[ 6])
  c=z(f,c,d,a,b,X[ 6],17,t[ 7])
  b=z(f,b,c,d,a,X[ 7],22,t[ 8])
  a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
  d=z(f,d,a,b,c,X[ 9],12,t[10])
  c=z(f,c,d,a,b,X[10],17,t[11])
  b=z(f,b,c,d,a,X[11],22,t[12])
  a=z(f,a,b,c,d,X[12], 7,t[13])
  d=z(f,d,a,b,c,X[13],12,t[14])
  c=z(f,c,d,a,b,X[14],17,t[15])
  b=z(f,b,c,d,a,X[15],22,t[16])

  a=z(g,a,b,c,d,X[ 1], 5,t[17])
  d=z(g,d,a,b,c,X[ 6], 9,t[18])
  c=z(g,c,d,a,b,X[11],14,t[19])
  b=z(g,b,c,d,a,X[ 0],20,t[20])
  a=z(g,a,b,c,d,X[ 5], 5,t[21])
  d=z(g,d,a,b,c,X[10], 9,t[22])
  c=z(g,c,d,a,b,X[15],14,t[23])
  b=z(g,b,c,d,a,X[ 4],20,t[24])
  a=z(g,a,b,c,d,X[ 9], 5,t[25])
  d=z(g,d,a,b,c,X[14], 9,t[26])
  c=z(g,c,d,a,b,X[ 3],14,t[27])
  b=z(g,b,c,d,a,X[ 8],20,t[28])
  a=z(g,a,b,c,d,X[13], 5,t[29])
  d=z(g,d,a,b,c,X[ 2], 9,t[30])
  c=z(g,c,d,a,b,X[ 7],14,t[31])
  b=z(g,b,c,d,a,X[12],20,t[32])

  a=z(h,a,b,c,d,X[ 5], 4,t[33])
  d=z(h,d,a,b,c,X[ 8],11,t[34])
  c=z(h,c,d,a,b,X[11],16,t[35])
  b=z(h,b,c,d,a,X[14],23,t[36])
  a=z(h,a,b,c,d,X[ 1], 4,t[37])
  d=z(h,d,a,b,c,X[ 4],11,t[38])
  c=z(h,c,d,a,b,X[ 7],16,t[39])
  b=z(h,b,c,d,a,X[10],23,t[40])
  a=z(h,a,b,c,d,X[13], 4,t[41])
  d=z(h,d,a,b,c,X[ 0],11,t[42])
  c=z(h,c,d,a,b,X[ 3],16,t[43])
  b=z(h,b,c,d,a,X[ 6],23,t[44])
  a=z(h,a,b,c,d,X[ 9], 4,t[45])
  d=z(h,d,a,b,c,X[12],11,t[46])
  c=z(h,c,d,a,b,X[15],16,t[47])
  b=z(h,b,c,d,a,X[ 2],23,t[48])

  a=z(i,a,b,c,d,X[ 0], 6,t[49])
  d=z(i,d,a,b,c,X[ 7],10,t[50])
  c=z(i,c,d,a,b,X[14],15,t[51])
  b=z(i,b,c,d,a,X[ 5],21,t[52])
  a=z(i,a,b,c,d,X[12], 6,t[53])
  d=z(i,d,a,b,c,X[ 3],10,t[54])
  c=z(i,c,d,a,b,X[10],15,t[55])
  b=z(i,b,c,d,a,X[ 1],21,t[56])
  a=z(i,a,b,c,d,X[ 8], 6,t[57])
  d=z(i,d,a,b,c,X[15],10,t[58])
  c=z(i,c,d,a,b,X[ 6],15,t[59])
  b=z(i,b,c,d,a,X[13],21,t[60])
  a=z(i,a,b,c,d,X[ 4], 6,t[61])
  d=z(i,d,a,b,c,X[11],10,t[62])
  c=z(i,c,d,a,b,X[ 2],15,t[63])
  b=z(i,b,c,d,a,X[ 9],21,t[64])

  return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
         bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
end

----------------------------------------------------------------

local function md5_update(self, s)
  self.pos = self.pos + #s
  s = self.buf .. s
  for ii = 1, #s - 63, 64 do
    local X = cut_le_str(sub(s,ii,ii+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)
    assert(#X == 16)
    X[0] = table.remove(X,1) -- zero based!
    self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
  end
  self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
  return self
end

local function md5_finish(self)
  local msgLen = self.pos
  local padLen = 56 - msgLen % 64

  if msgLen % 64 > 56 then padLen = padLen + 64 end

  if padLen == 0 then padLen = 64 end

  local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
  md5_update(self, s)

  assert(self.pos % 64 == 0)
  return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
end

----------------------------------------------------------------

function md5.new()
  return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
           pos = 0,
           buf = '',
           update = md5_update,
           finish = md5_finish }
end

function md5.tohex(s)
  return format("%08x%08x%08x%08x", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
end

function md5.sum(s)
  return md5.new():update(s):finish()
end

function md5.sumhexa(s)
  return md5.tohex(md5.sum(s))
end

return md5</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="32">
          <Properties>
            <string name="Name">Table</string>
            <string name="Source">-- Table Util
-- Crazyman32
-- September 13, 2017

--[[
	
	TableUtil.Copy(Table tbl)
	TableUtil.Sync(Table tbl, Table templateTbl)
	TableUtil.Print(Table tbl, String label, Boolean deepPrint)
	TableUtil.FastRemove(Table tbl, Number index)
	TableUtil.FastRemoveFirstValue(Table tbl, Variant value)
	TableUtil.Map(Table tbl, Function callback)
	TableUtil.Filter(Table tbl, Function callback)
	TableUtil.Reduce(Table tbl, Function callback [, Number initialValue])
	TableUtil.IndexOf(Table tbl, Variant item)
	TableUtil.Reverse(Table tbl)
	TableUtil.Shuffle(Table tbl)
	TableUtil.IsEmpty(Table tbl)
	TableUtil.EncodeJSON(Table tbl)
	TableUtil.DecodeJSON(String json)

	EXAMPLES:

		Copy:

			Performs a deep copy of the given table.

			local tbl = {"a", "b", "c"}
			local tblCopy = TableUtil.Copy(tbl)


		Sync:

			Synchronizes a table to a template table. If the table does not have an
			item that exists within the template, it gets added. If the table has
			something that the template does not have, it gets removed.

			local tbl1 = {kills = 0; deaths = 0; points = 0}
			local tbl2 = {points = 0}
			TableUtil.Sync(tbl2, tbl1)  -- In words: "Synchronize table2 to table1"
			print(tbl2.deaths)


		Print:

			Prints out the table to the output in an easy-to-read format. Good for
			debugging tables. If deep printing, avoid cyclical references.

			local tbl = {a = 32; b = 64; c = 128; d = {x = 0; y = 1; z = 2}}
			TableUtil.Print(tbl, "My Table", true)


		FastRemove:

			Removes an item from an array at a given index. Only use this if you do
			NOT care about the order of your array. This works by simply popping the
			last item in the array and overwriting the given index with the last
			item. This is O(1), compared to table.remove's O(n) speed.

			local tbl = {"hello", "there", "this", "is", "a", "test"}
			TableUtil.FastRemove(tbl, 2)   -- Remove "there" in the array
			print(table.concat(tbl, " "))  -- > hello this is a test


		FastRemoveFirstValue:

			Calls FastRemove on the first index that holds the given value.

			local tbl = {"abc", "hello", "hi", "goodbye", "hello", "hey"}
			local removed, atIndex = TableUtil.FastRemoveFirstValue(tbl, "hello")
			if (removed) then
				print("Removed at index " .. atIndex)
				print(table.concat(tbl, " "))  -- > abc hi goodbye hello hey
			else
				print("Did not find value")
			end

		
		Map:

			This allows you to construct a new table by calling the given function
			on each item in the table.

			local peopleData = {
				{firstName = "Bob"; lastName = "Smith"};
				{firstName = "John"; lastName = "Doe"};
				{firstName = "Jane"; lastName = "Doe"};
			}

			local people = TableUtil.Map(peopleData, function(item)
				return {Name = item.firstName .. " " .. item.lastName}
			end)

			-- 'people' is now an array that looks like: { {Name = "Bob Smith"}; ... }


		Filter:

			This allows you to create a table based on the given table and a filter
			function. If the function returns 'true', the item remains in the new
			table; if the function returns 'false', the item is discluded from the
			new table.

			local people = {
				{Name = "Bob Smith"; Age = 42};
				{Name = "John Doe"; Age = 34};
				{Name = "Jane Doe"; Age = 37};
			}

			local peopleUnderForty = TableUtil.Filter(people, function(item)
				return item.Age &lt; 40
			end)


		Reduce:

			This allows you to reduce an array to a single value. Useful for quickly
			summing up an array.

			local tbl = {40, 32, 9, 5, 44}
			local tblSum = TableUtil.Reduce(tbl, function(accumulator, value)
				return accumulator + value
			end)
			print(tblSum)  -- > 130


		IndexOf:

			Returns the index of the given item in the table. If not found, this
			will return nil.

			local tbl = {"Hello", 32, true, "abc"}
			local abcIndex = TableUtil.IndexOf("abc")     -- > 4
			local helloIndex = TableUtil.IndexOf("Hello") -- > 1
			local numberIndex = TableUtil.IndexOf(64)     -- > nil


		Reverse:

			Creates a reversed version of the array. Note: This is a shallow
			copy, so existing references will remain within the new table.

			local tbl = {2, 4, 6, 8}
			local rblReversed = TableUtil.Reverse(tbl)  -- > {8, 6, 4, 2}


		Shuffle:

			Shuffles (i.e. randomizes) an array. This uses the Fisher-Yates algorithm.

			local tbl = {1, 2, 3, 4, 5, 6, 7, 8, 9}
			TableUtil.Shuffle(tbl)
			print(table.concat(tbl, ", "))  -- e.g. > 3, 6, 9, 2, 8, 4, 1, 7, 5
	
--]]



local TableUtil = {}

local http = game:GetService("HttpService")


local function CopyTable(t)
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = {}
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = CopyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end


local function Sync(tbl, templateTbl)

	assert(type(tbl) == "table", "First argument must be a table")
	assert(type(templateTbl) == "table", "Second argument must be a table")
	
	-- If 'tbl' has something 'templateTbl' doesn't, then remove it from 'tbl'
	-- If 'tbl' has something of a different type than 'templateTbl', copy from 'templateTbl'
	-- If 'templateTbl' has something 'tbl' doesn't, then add it to 'tbl'
	for k,v in pairs(tbl) do
		
		local vTemplate = templateTbl[k]
		
		-- Remove keys not within template:
		if (vTemplate == nil) then
			tbl[k] = nil
			
		-- Synchronize data types:
		elseif (type(v) ~= type(vTemplate)) then
			if (type(vTemplate) == "table") then
				tbl[k] = CopyTable(vTemplate)
			else
				tbl[k] = vTemplate
			end
		
		-- Synchronize sub-tables:
		elseif (type(v) == "table") then
			Sync(v, vTemplate)
		end
		
	end
	
	-- Add any missing keys:
	for k,vTemplate in pairs(templateTbl) do
		
		local v = tbl[k]
		
		if (v == nil) then
			if (type(vTemplate) == "table") then
				tbl[k] = CopyTable(vTemplate)
			else
				tbl[k] = vTemplate
			end
		end
		
	end
	
end


local function FastRemove(t, i)
	local n = #t
	t[i] = t[n]
	t[n] = nil
end


local function Map(t, f)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be an array")
	local newT = {}
	for k,v in pairs(t) do
		newT[k] = f(v, k, t)
	end
	return newT
end


local function Filter(t, f)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be an array")
	local newT = {}
	if (#t > 0) then
		local n = 0
		for i = 1,#t do
			local v = t[i]
			if (f(v, i, t)) then
				n = (n + 1)
				newT[n] = v
			end
		end
	else
		for k,v in pairs(t) do
			if (f(v, k, t)) then
				newT[k] = v
			end
		end
	end
	return newT
end


local function Reduce(t, f, init)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be an array")
	assert(init == nil or type(init) == "number", "Third argument must be a number or nil")
	local result = (init or 0)
	for k,v in pairs(t) do
		result = f(result, v, k, t)
	end
	return result
end


local function Print(tbl, label, deepPrint)

	assert(type(tbl) == "table", "First argument must be a table")
	assert(label == nil or type(label) == "string", "Second argument must be a string or nil")
	
	label = (label or "TABLE")
	
	local strTbl = {}
	local indent = " - "
	
	-- Insert(string, indentLevel)
	local function Insert(s, l)
		strTbl[#strTbl + 1] = (indent:rep(l) .. s .. "\n")
	end
	
	local function AlphaKeySort(a, b)
		return (tostring(a.k) &lt; tostring(b.k))
	end
	
	local function PrintTable(t, lvl, lbl)
		Insert(lbl .. ":", lvl - 1)
		local nonTbls = {}
		local tbls = {}
		local keySpaces = 0
		for k,v in pairs(t) do
			if (type(v) == "table") then
				table.insert(tbls, {k = k, v = v})
			else
				table.insert(nonTbls, {k = k, v = "[" .. typeof(v) .. "] " .. tostring(v)})
			end
			local spaces = #tostring(k) + 1
			if (spaces > keySpaces) then
				keySpaces = spaces
			end
		end
		table.sort(nonTbls, AlphaKeySort)
		table.sort(tbls, AlphaKeySort)
		for _,v in pairs(nonTbls) do
			Insert(tostring(v.k) .. ":" .. (" "):rep(keySpaces - #tostring(v.k)) .. v.v, lvl)
		end
		if (deepPrint) then
			for _,v in pairs(tbls) do
				PrintTable(v.v, lvl + 1, tostring(v.k) .. (" "):rep(keySpaces - #tostring(v.k)) .. " [Table]")
			end
		else
			for _,v in pairs(tbls) do
				Insert(tostring(v.k) .. ":" .. (" "):rep(keySpaces - #tostring(v.k)) .. "[Table]", lvl)
			end
		end
	end
	
	PrintTable(tbl, 1, label)
	
	print(table.concat(strTbl, ""))
	
end


local function IndexOf(tbl, item)
	for i = 1,#tbl do
		if (tbl[i] == item) then
			return i
		end
	end
	return nil
end


local function Reverse(tbl)
	local tblRev = {}
	local n = #tbl
	for i = 1,n do
		tblRev[i] = tbl[n - i + 1]
	end
	return tblRev
end


local function Shuffle(tbl)
	assert(type(tbl) == "table", "First argument must be a table")
	for i = #tbl, 2, -1 do
		local j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
end


local function IsEmpty(tbl)
	return (next(tbl) == nil)
end


local function EncodeJSON(tbl)
	return http:JSONEncode(tbl)
end


local function DecodeJSON(str)
	return http:JSONDecode(str)
end


local function FastRemoveFirstValue(t, v)
	local index = IndexOf(t, v)
	if (index) then
		FastRemove(t, index)
		return true, index
	end
	return false, nil
end


TableUtil.Copy = CopyTable
TableUtil.Sync = Sync
TableUtil.FastRemove = FastRemove
TableUtil.FastRemoveFirstValue = FastRemoveFirstValue
TableUtil.Print = Print
TableUtil.Map = Map
TableUtil.Filter = Filter
TableUtil.Reduce = Reduce
TableUtil.IndexOf = IndexOf
TableUtil.Reverse = Reverse
TableUtil.Shuffle = Shuffle
TableUtil.IsEmpty = IsEmpty
TableUtil.EncodeJSON = EncodeJSON
TableUtil.DecodeJSON = DecodeJSON

for _,Module in pairs(script:GetChildren()) do
	TableUtil[Module.Name]=require(Module)
end

return TableUtil</string>
          </Properties>
          <Item class="ModuleScript" referent="33">
            <Properties>
              <string name="Name">ConvertFolderToTable</string>
              <string name="Source">local function ConvertFolderToTable(Folder)
	local Tab={}
	local Keyname;
	local Value;

	for i,v in pairs(Folder:GetChildren()) do
		if v:IsA("Folder") then
			Value=ConvertFolderToTable(v)
			Keyname=v.Name
		else
			Keyname=v.Name
			Value=v.Value
		end
		Tab[Keyname]=Value
	end
	return Tab
end

return ConvertFolderToTable</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="34">
            <Properties>
              <string name="Name">ConvertTableToFolder</string>
              <string name="Source">local function ConvertTableToFolder(Original_Table)
    local Folder=Instance.new('Folder')
	local Object;

    for Index,Value in pairs(Original_Table) do
        if typeof(Value)=="table" then
            Object=ConvertTableToFolder(Value)
        else
            if typeof(Value)=="number" then
                Object=Instance.new('NumberValue')
            end
            if typeof(Value)=="string" then
                Object=Instance.new('StringValue')
            end
            if typeof(Value)=="boolean" then
                Object=Instance.new('BoolValue')
            end
            if typeof(Value)=="Instance" then
                Object=Instance.new('ObjectValue')
            end
            Object.Value=Value
        end
        Object.Name=Index
        Object.Parent=Folder
    end
    return Folder
end

return ConvertTableToFolder</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="35">
            <Properties>
              <string name="Name">MakeReadOnly</string>
              <string name="Source">return setmetatable({}, {
    __index = tab,
    __newindex = function(tab, key, value)
        error("Attempt to modify read-only table")
    end,
    __metatable = false
});</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="36">
            <Properties>
              <string name="Name">Recurse</string>
              <string name="Source">local function Recurse(Table)
    local Items={}

    for _,Item in pairs(Table) do
        if typeof(Item)=="table" then --Recurse through this subtable.
            local SubItems=Recurse(Item)

            for _,SubItem in pairs(SubItems) do
                table.insert(Items,SubItem)
            end
        else --Just a regular value, add it to the items list.
            table.insert(Items,Item)
        end
    end
    return Items
end

return Recurse</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="37">
            <Properties>
              <string name="Name">repr</string>
              <string name="Source">--- repr - Version 1.1
-- Ozzypig - ozzypig.com - http://twitter.com/Ozzypig
-- Check out this thread for more info:
-- https://devforum.roblox.com/t/repr-function-for-printing-tables/276575
--[[

local repr = require(3148021300)

local myTable = {
	hello = "world",
	score = 5,
	isCool = true
}
print(repr(myTable)) --> {hello = "world", isCool = true, score = 5}

]]

local defaultSettings = {
	pretty = false;
	robloxFullName = false;
	robloxProperFullName = true;
	robloxClassName = true;
	tabs = false;
	semicolons = false;
	spaces = 3;
	sortKeys = true;
}

-- lua keywords
local keywords = {["and"]=true, ["break"]=true, ["do"]=true, ["else"]=true,
["elseif"]=true, ["end"]=true, ["false"]=true, ["for"]=true, ["function"]=true,
["if"]=true, ["in"]=true, ["local"]=true, ["nil"]=true, ["not"]=true, ["or"]=true,
["repeat"]=true, ["return"]=true, ["then"]=true, ["true"]=true, ["until"]=true, ["while"]=true}

local function isLuaIdentifier(str)
	if type(str) ~= "string" then return false end
	-- must be nonempty
	if str:len() == 0 then return false end
	-- can only contain a-z, A-Z, 0-9 and underscore
	if str:find("[^%d%a_]") then return false end
	-- cannot begin with digit
	if tonumber(str:sub(1, 1)) then return false end
	-- cannot be keyword
	if keywords[str] then return false end
	return true
end

-- works like Instance:GetFullName(), but invalid Lua identifiers are fixed (e.g. workspace["The Dude"].Humanoid)
local function properFullName(object, usePeriod)
	if object == nil or object == game then return "" end
	
	local s = object.Name
	local usePeriod = true
	if not isLuaIdentifier(s) then
		s = ("[%q]"):format(s)
		usePeriod = false
	end
	
	if not object.Parent or object.Parent == game then
		return s
	else
		return properFullName(object.Parent) .. (usePeriod and "." or "") .. s 
	end
end

local depth = 0
local shown
local INDENT
local reprSettings

local function repr(value, reprSettings)
	reprSettings = reprSettings or defaultSettings
	INDENT = (" "):rep(reprSettings.spaces or defaultSettings.spaces)
	if reprSettings.tabs then
		INDENT = "\t"
	end
	
	local v = value --args[1]
	local tabs = INDENT:rep(depth)
	
	if depth == 0 then
		shown = {}
	end
	if type(v) == "string" then
		return ("%q"):format(v)
	elseif type(v) == "number" then
		if v == math.huge then return "math.huge" end
		if v == -math.huge then return "-math.huge" end
		return tonumber(v)
	elseif type(v) == "boolean" then
		return tostring(v)
	elseif type(v) == "nil" then
		return "nil"
	elseif type(v) == "table" and type(v.__tostring) == "function" then
		return tostring(v.__tostring(v))
	elseif type(v) == "table" and getmetatable(v) and type(getmetatable(v).__tostring) == "function" then
		return tostring(getmetatable(v).__tostring(v))
	elseif type(v) == "table" then
		if shown[v] then return "{CYCLIC}" end
		shown[v] = true
		local str = "{" .. (reprSettings.pretty and ("\n" .. INDENT .. tabs) or "")
		local isArray = true
		for k, v in pairs(v) do
			if type(k) ~= "number" then
				isArray = false
				break
			end
		end
		if isArray then
			for i = 1, #v do
				if i ~= 1 then
					str = str .. (reprSettings.semicolons and ";" or ",") .. (reprSettings.pretty and ("\n" .. INDENT .. tabs) or " ")
				end
				depth = depth + 1
				str = str .. repr(v[i], reprSettings)
				depth = depth - 1
			end
		else
			local keyOrder = {}
			local keyValueStrings = {}
			for k, v in pairs(v) do
				depth = depth + 1
				local kStr = isLuaIdentifier(k) and k or ("[" .. repr(k, reprSettings) .. "]")
				local vStr = repr(v, reprSettings)
				--[[str = str .. ("%s = %s"):format(
					isLuaIdentifier(k) and k or ("[" .. repr(k, reprSettings) .. "]"),
					repr(v, reprSettings)
				)]]
				table.insert(keyOrder, kStr)
				keyValueStrings[kStr] = vStr
				depth = depth - 1
			end
			if reprSettings.sortKeys then table.sort(keyOrder) end
			local first = true
			for _, kStr in pairs(keyOrder) do
				if not first then
					str = str .. (reprSettings.semicolons and ";" or ",") .. (reprSettings.pretty and ("\n" .. INDENT .. tabs) or " ")
				end
				str = str .. ("%s = %s"):format(kStr, keyValueStrings[kStr])
				first = false
			end
		end
		shown[v] = false
		if reprSettings.pretty then
			str = str .. "\n" .. tabs
		end
		str = str .. "}"
		return str
	elseif typeof then
		-- Check Roblox types
		if typeof(v) == "Instance" then
			return  (reprSettings.robloxFullName
				and (reprSettings.robloxProperFullName and properFullName(v) or v:GetFullName())
			 or v.Name) .. (reprSettings.robloxClassName and ((" (%s)"):format(v.ClassName)) or "")
		elseif typeof(v) == "Axes" then
			local s = {}
			if v.X then table.insert(s, repr(Enum.Axis.X, reprSettings)) end
			if v.Y then table.insert(s, repr(Enum.Axis.Y, reprSettings)) end
			if v.Z then table.insert(s, repr(Enum.Axis.Z, reprSettings)) end
			return ("Axes.new(%s)"):format(table.concat(s, ", "))
		elseif typeof(v) == "BrickColor" then
			return ("BrickColor.new(%q)"):format(v.Name)
		elseif typeof(v) == "CFrame" then
			return ("CFrame.new(%s)"):format(table.concat({v:GetComponents()}, ", "))
		elseif typeof(v) == "Color3" then
			return ("Color3.new(%d, %d, %d)"):format(v.r, v.g, v.b)
		elseif typeof(v) == "ColorSequence" then
			if #v.Keypoints > 2 then
				return ("ColorSequence.new(%s)"):format(repr(v.Keypoints, reprSettings))
			else
				if v.Keypoints[1].Value == v.Keypoints[2].Value then
					return ("ColorSequence.new(%s)"):format(repr(v.Keypoints[1].Value, reprSettings))
				else
					return ("ColorSequence.new(%s, %s)"):format(
						repr(v.Keypoints[1].Value, reprSettings),
						repr(v.Keypoints[2].Value, reprSettings)
					)
				end
			end
		elseif typeof(v) == "ColorSequenceKeypoint" then
			return ("ColorSequenceKeypoint.new(%d, %s)"):format(v.Time, repr(v.Value, reprSettings))
		elseif typeof(v) == "DockWidgetPluginGuiInfo" then
			return ("DockWidgetPluginGuiInfo.new(%s, %s, %s, %s, %s, %s, %s)"):format(
				repr(v.InitialDockState, reprSettings),
				repr(v.InitialEnabled, reprSettings),
				repr(v.InitialEnabledShouldOverrideRestore, reprSettings),
				repr(v.FloatingXSize, reprSettings),
				repr(v.FloatingYSize, reprSettings),
				repr(v.MinWidth, reprSettings),
				repr(v.MinHeight, reprSettings)
			)
		elseif typeof(v) == "Enums" then
			return "Enums"
		elseif typeof(v) == "Enum" then
			return ("Enum.%s"):format(tostring(v))
		elseif typeof(v) == "EnumItem" then
			return ("Enum.%s.%s"):format(tostring(v.EnumType), v.Name)
		elseif typeof(v) == "Faces" then
			local s = {}
			for _, enumItem in pairs(Enum.NormalId:GetEnumItems()) do
				if v[enumItem.Name] then
					table.insert(s, repr(enumItem, reprSettings))
				end
			end
			return ("Faces.new(%s)"):format(table.concat(s, ", "))
		elseif typeof(v) == "NumberRange" then
			if v.Min == v.Max then
				return ("NumberRange.new(%d)"):format(v.Min)
			else
				return ("NumberRange.new(%d, %d)"):format(v.Min, v.Max)
			end
		elseif typeof(v) == "NumberSequence" then
			if #v.Keypoints > 2 then
				return ("NumberSequence.new(%s)"):format(repr(v.Keypoints, reprSettings))
			else
				if v.Keypoints[1].Value == v.Keypoints[2].Value then
					return ("NumberSequence.new(%d)"):format(v.Keypoints[1].Value)
				else
					return ("NumberSequence.new(%d, %d)"):format(v.Keypoints[1].Value, v.Keypoints[2].Value)
				end
			end
		elseif typeof(v) == "NumberSequenceKeypoint" then
			if v.Envelope ~= 0 then
				return ("NumberSequenceKeypoint.new(%d, %d, %d)"):format(v.Time, v.Value, v.Envelope)
			else
				return ("NumberSequenceKeypoint.new(%d, %d)"):format(v.Time, v.Value)
			end
		elseif typeof(v) == "PathWaypoint" then
			return ("PathWaypoint.new(%s, %s)"):format(
				repr(v.Position, reprSettings),
				repr(v.Action, reprSettings)
			)
		elseif typeof(v) == "PhysicalProperties" then
			return ("PhysicalProperties.new(%d, %d, %d, %d, %d)"):format(
				v.Density, v.Friction, v.Elasticity, v.FrictionWeight, v.ElasticityWeight
			)
		elseif typeof(v) == "Random" then
			return "&lt;Random>"
		elseif typeof(v) == "Ray" then
			return ("Ray.new(%s, %s)"):format(
				repr(v.Origin, reprSettings),
				repr(v.Direction, reprSettings)
			)
		elseif typeof(v) == "RBXScriptConnection" then
			return "&lt;RBXScriptConnection>"
		elseif typeof(v) == "RBXScriptSignal" then
			return "&lt;RBXScriptSignal>"
		elseif typeof(v) == "Rect" then
			return ("Rect.new(%d, %d, %d, %d)"):format(
				v.Min.X, v.Min.Y, v.Max.X, v.Max.Y
			)
		elseif typeof(v) == "Region3" then
			local min = v.CFrame.p + v.Size * -.5
			local max = v.CFrame.p + v.Size * .5
			return ("Region3.new(%s, %s)"):format(
				repr(min, reprSettings),
				repr(max, reprSettings)
			)
		elseif typeof(v) == "Region3int16" then
			return ("Region3int16.new(%s, %s)"):format(
				repr(v.Min, reprSettings),
				repr(v.Max, reprSettings)
			)
		elseif typeof(v) == "TweenInfo" then
			return ("TweenInfo.new(%d, %s, %s, %d, %s, %d)"):format(
				v.Time, repr(v.EasingStyle, reprSettings), repr(v.EasingDirection, reprSettings),
				v.RepeatCount, repr(v.Reverses, reprSettings), v.DelayTime
			)
		elseif typeof(v) == "UDim" then
			return ("UDim.new(%d, %d)"):format(
				v.Scale, v.Offset
			)
		elseif typeof(v) == "UDim2" then
			return ("UDim2.new(%d, %d, %d, %d)"):format(
				v.X.Scale, v.X.Offset, v.Y.Scale, v.Y.Offset
			)
		elseif typeof(v) == "Vector2" then
			return ("Vector2.new(%d, %d"):format(v.X, v.Y)
		elseif typeof(v) == "Vector2int16" then
			return ("Vector2int16.new(%d, %d)"):format(v.X, v.Y)
		elseif typeof(v) == "Vector3" then
			return ("Vector3.new(%d, %d, %d)"):format(v.X, v.Y, v.Z)
		elseif typeof(v) == "Vector3int16" then
			return ("Vector3int16.new(%d, %d, %d)"):format(v.X, v.Y, v.Z)
		else
			return "&lt;Roblox:" .. typeof(v) .. ">"
		end
	else
		return "&lt;" .. type(v) .. ">"
	end
end

return repr</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="38">
          <Properties>
            <string name="Name">Weather</string>
          </Properties>
          <Item class="ModuleScript" referent="39">
            <Properties>
              <string name="Name">Rain</string>
              <string name="Source">--[[
	
	Rain module v1.0 by buildthomas (July 2018)
	
	This module is licensed under the APLv2:
	http://www.apache.org/licenses/LICENSE-2.0
	
	In short, you may use this code only if you agree to the following:
	* This notice must always be present and may not be modified or removed in any copy of this code or derived code.
	* You may use this in commercial, closed source projects, and you may modify the source code itself.
	
	Refer to the license for a full description.
	
	For questions please reach out on the Developer Forum (@buildthomas)
	or via Twitter (https://www.twitter.com/buildthomasRBX)
	
	------
	
	
	Rain:Enable(&lt;TweenInfo> tweenInfo)
		Enable the rain effects instantly, or over a given easing function if tweenInfo is given.
		
	Rain:Disable(&lt;TweenInfo> tweenInfo)
		Disable the rain effects instantly, or over a given easing function if tweenInfo is given.
		
		
	Rain:SetColor(&lt;Color3> color, &lt;TweenInfo> tweenInfo)
		Set the global color of all rain particles to a given Color3 value.
		Sets the color instantly, or over a given easing function if tweenInfo is given.
		Color sequences are not supported because this would lead to a messy effect.
		The starting value is RAIN_DEFAULT_COLOR.
		
	Rain:SetTransparency(&lt;number> transparency, &lt;TweenInfo> tweenInfo)
		Set the global transparency of all rain effects. 0 = regular visibility, 1 = fully invisible.
		Sets the transparency instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_TRANSPARENCY.
	
	Rain:SetSpeedRatio(&lt;number> ratio, &lt;TweenInfo> tweenInfo)
		Set the vertical falling speed of the rain particles. 0 = still, 1 = max falling speed.
		Sets the speed instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_SPEEDRATIO.
		
	Rain:SetIntensityRatio(&lt;number> ratio, &lt;TweenInfo> tweenInfo)
		Set the intensity of the rain. 0 = no effects, 1 = full effects.
		Sets the intensity instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_INTENSITYRATIO.
		
	Rain:SetLightEmission(&lt;number> ratio, &lt;TweenInfo> tweenInfo)
		Set the global light emission of all rain effects.
		Sets the light emission instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_LIGHTEMISSION.
		
	Rain:SetLightInfluence(&lt;number> transparency, &lt;TweenInfo> tweenInfo)
		Set the global light influence of all rain effects.
		Sets the light influence instantly, or over a given easing function if tweenInfo is given.
		Clamped between 0 and 1, the starting value is RAIN_DEFAULT_LIGHTINFLUENCE.
		
		
	Rain:SetVolume(&lt;number> volume, &lt;TweenInfo> tweenInfo)
		Set the global max volume of rain instantly, or over a given easing function if tweenInfo is given.
		The initial volume of the rain's soundgroup is RAIN_SOUND_BASEVOLUME.
		
		
	Rain:SetCeiling(&lt;Variant&lt;number, nil>> ceiling)
		Set a Y coordinate that marks the ceiling of the world. Above this spot, rain will act as if it's indoors.
		Feed nil to remove any previously set ceiling.
		
		
	Rain:SetDirection(&lt;Vector3> direction, &lt;TweenInfo> tweenInfo)
		Set the direction that rain falls from. The direction parameter should be a unit direction.
		Sets the rain direction instantly, or over a given easing function if tweenInfo is given.
		
	Rain:SetStraightTexture(&lt;string> asset)
	Rain:SetTopDownTexture(&lt;string> asset)
	Rain:SetSplashTexture(&lt;string> asset)
		Adjust textures of the rain effect.
		
	Rain:SetSoundId(&lt;string> asset)
		Adjust sound effect of the rain effect.
		
	Rain:SetCollisionMode(&lt;Rain.CollisionMode> mode, ...)
		Sets the current way collisions are determined for the rain.
		
		Rain.CollisionMode
			A table that should be seen as an enumerator for the collision mode.
			The following values are available:
			* Rain.CollisionMode.None			- All parts in the default collision group will block the rain.
			* Rain.CollisionMode.Whitelist		- Use the whitelist provided by Rain::SetCollisionWhitelist.
			* Rain.CollisionMode.Blacklist		- Use the blacklist provided by Rain::SetCollisionBlacklist.
			* Rain.CollisionMode.Function		- Use the test function provided by Rain::SetCollisionFunction and do deep-casts.
			
		Rain:SetCollisionMode(Rain.CollisionMode.None)
			No parameters.
			
		Rain:SetCollisionMode(Rain.CollisionMode.Whitelist, &lt;Variant&lt;Instance, table>> whitelist)
			The provided value can either be a hierarchy of objects or a table of objects to filter with.
		
		Rain:SetCollisionMode(Rain.CollisionMode.Blacklist, &lt;Variant&lt;Instance, table>> blacklist)
			The provided value can either be a hierarchy of objects or a table of objects to filter out.
			
		Rain:SetCollisionMode(Rain.CollisionMode.Function, &lt;function&lt;BasePart -> boolean>> f)
			If f(part) returns a value that lua evaluates to a true condition, that part can be hit by rain.
			If f(part) returns any other value, that part cannot be hit by the rain.
			
	
--]]

-- Options:

local MIN_SIZE = Vector3.new(0.05,0.05,0.05)				-- Size of main emitter part when rain inactive

local RAIN_DEFAULT_COLOR = Color3.new(1,1,1)				-- Default color3 of all rain elements
local RAIN_DEFAULT_TRANSPARENCY = 0							-- Default transparency scale ratio of all rain elements
local RAIN_DEFAULT_SPEEDRATIO = 1							-- Default speed scale ratio of falling rain effects
local RAIN_DEFAULT_INTENSITYRATIO = 1						-- Default intensity ratio of all rain elements
local RAIN_DEFAULT_LIGHTEMISSION = 0.05						-- Default LightEmission of all rain elements
local RAIN_DEFAULT_LIGHTINFLUENCE = 0.9						-- Default LightInfluence of all rain elements
local RAIN_DEFAULT_DIRECTION = Vector3.new(0,-1,0)			-- Default direction for rain to fall into

local RAIN_TRANSPARENCY_T1 = .25							-- Define the shape (time-wise) of the transparency curves for emitters
local RAIN_TRANSPARENCY_T2 = .75

local RAIN_SCANHEIGHT = 1000								-- How many studs to scan up from camera position to determine whether occluded

local RAIN_EMITTER_DIM_DEFAULT = 40							-- Size of emitter block to the side/up
local RAIN_EMITTER_DIM_MAXFORWARD = 100						-- Size of emitter block forwards when looking at the horizon
local RAIN_EMITTER_UP_MODIFIER = 20							-- Maximum vertical displacement of emitter (when looking fully up/down)

local RAIN_SOUND_ASSET = "rbxassetid://1516791621"
local RAIN_SOUND_BASEVOLUME = 0.2							-- Starting volume of rain sound effect when not occluded
local RAIN_SOUND_FADEIN_TIME = 1							-- Tween in/out times for sound volume
local RAIN_SOUND_FADEOUT_TIME = 1

local RAIN_STRAIGHT_ASSET = "rbxassetid://1822883048"		-- Some properties of the straight rain particle effect
local RAIN_STRAIGHT_ALPHA_LOW = 0.7							-- Minimum particle transparency for the straight rain emitter
local RAIN_STRAIGHT_SIZE = NumberSequence.new(10)
local RAIN_STRAIGHT_LIFETIME = NumberRange.new(0.8)
local RAIN_STRAIGHT_MAX_RATE = 600							-- Maximum rate for the straight rain emitter
local RAIN_STRAIGHT_MAX_SPEED = 60							-- Maximum speed for the straight rain emitter

local RAIN_TOPDOWN_ASSET = "rbxassetid://1822856633"		-- Some properties of the top-down rain particle effect
local RAIN_TOPDOWN_ALPHA_LOW = 0.85							-- Minimum particle transparency for the top-down rain emitter
local RAIN_TOPDOWN_SIZE = NumberSequence.new {
	NumberSequenceKeypoint.new(0, 5.33, 2.75);
	NumberSequenceKeypoint.new(1, 5.33, 2.75);
}			
local RAIN_TOPDOWN_LIFETIME = NumberRange.new(0.8)
local RAIN_TOPDOWN_ROTATION = NumberRange.new(0,360)
local RAIN_TOPDOWN_MAX_RATE = 600							-- Maximum rate for the top-down rain emitter
local RAIN_TOPDOWN_MAX_SPEED = 60							-- Maximum speed for the top-down rain emitter

local RAIN_SPLASH_ASSET = "rbxassetid://1822856633"			-- Some properties of the splash particle effect
local RAIN_SPLASH_ALPHA_LOW = 0.6							-- Minimum particle transparency for the splash emitters
local RAIN_SPLASH_SIZE = NumberSequence.new {				
	NumberSequenceKeypoint.new(0, 0);
	NumberSequenceKeypoint.new(.4, 3);
	NumberSequenceKeypoint.new(1, 0);
}
local RAIN_SPLASH_LIFETIME = NumberRange.new(0.1, 0.15)
local RAIN_SPLASH_ROTATION = NumberRange.new(0,360)
local RAIN_SPLASH_NUM = 20									-- Amount of splashes per frame
local RAIN_SPLASH_CORRECTION_Y = .5							-- Offset from impact position for visual reasons
local RAIN_SPLASH_STRAIGHT_OFFSET_Y = 50					-- Offset against rain direction for straight rain particles from splash position
local RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MIN = 20				-- Min/max vertical offset from camera height for straight rain particles
local RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MAX = 100				-- when no splash position could be found (i.e. no floor at that XZ-column)

local RAIN_OCCLUDED_MINSPEED = 70							-- Minimum speed for the occluded straight rain emitters
local RAIN_OCCLUDED_MAXSPEED = 100							-- Maximum speed for the occluded straight rain emitters
local RAIN_OCCLUDED_SPREAD = Vector2.new(10,10)				-- Spread angle for the occluded straight rain emitters
local RAIN_OCCLUDED_MAXINTENSITY = 2						-- How many occluded straight rain particles are emitted for every splash for max intensity

local RAIN_OCCLUDECHECK_OFFSET_Y = 500						-- Vertical offset from camera height to start scanning downward from for splashes
local RAIN_OCCLUDECHECK_OFFSET_XZ_MIN = -100				-- Range of possible XZ offset values from camera XZ position for the splashes
local RAIN_OCCLUDECHECK_OFFSET_XZ_MAX = 100
local RAIN_OCCLUDECHECK_SCAN_Y = 550						-- Scan magnitude along rain path

local RAIN_UPDATE_PERIOD = 6								-- Update the transparency of the main emitters + volume of rain inside every X frames

local RAIN_VOLUME_SCAN_RADIUS = 35							-- Defining grid for checking how far the camera is away from a spot exposed to rain
local RAIN_VOLUME_SCAN_GRID = {								-- Unit range grid for scanning how far away user is from rain space
	-- range 0.2, 4 pts
	Vector3.new(0.141421363, 0, 0.141421363);
	Vector3.new(-0.141421363, 0, 0.141421363);
	Vector3.new(-0.141421363, 0, -0.141421363);
	Vector3.new(0.141421363, 0, -0.141421363);
	-- range 0.4, 8 pts
	Vector3.new(0.400000006, 0, 0);
	Vector3.new(0.282842726, 0, 0.282842726);
	Vector3.new(2.44929371e-17, 0, 0.400000006);
	Vector3.new(-0.282842726, 0, 0.282842726);
	Vector3.new(-0.400000006, 0, 4.89858741e-17);
	Vector3.new(-0.282842726, 0, -0.282842726);
	Vector3.new(-7.34788045e-17, 0, -0.400000006);
	Vector3.new(0.282842726, 0, -0.282842726);
	-- range 0.6, 10 pts
	Vector3.new(0.600000024, 0, 0);
	Vector3.new(0.485410213, 0, 0.352671146);
	Vector3.new(0.185410202, 0, 0.570633948);
	Vector3.new(-0.185410202, 0, 0.570633948);
	Vector3.new(-0.485410213, 0, 0.352671146);
	Vector3.new(-0.600000024, 0, 7.34788112e-17);
	Vector3.new(-0.485410213, 0, -0.352671146);
	Vector3.new(-0.185410202, 0, -0.570633948);
	Vector3.new(0.185410202, 0, -0.570633948);
	Vector3.new(0.485410213, 0, -0.352671146);
	-- range 0.8, 12 pts
	Vector3.new(0.772740662, 0, 0.207055241);
	Vector3.new(0.565685451, 0, 0.565685451);
	Vector3.new(0.207055241, 0, 0.772740662);
	Vector3.new(-0.207055241, 0, 0.772740662);
	Vector3.new(-0.565685451, 0, 0.565685451);
	Vector3.new(-0.772740662, 0, 0.207055241);
	Vector3.new(-0.772740662, 0, -0.207055241);
	Vector3.new(-0.565685451, 0, -0.565685451);
	Vector3.new(-0.207055241, 0, -0.772740662);
	Vector3.new(0.207055241, 0, -0.772740662);
	Vector3.new(0.565685451, 0, -0.565685451);
	Vector3.new(0.772740662, 0, -0.207055241);
}


-- Enumerators:

local CollisionMode = {
	None = 0;
	Whitelist = 1;
	Blacklist = 2;
	Function = 3;
}


-- Variables &amp; setup:

-- services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local GlobalModifier = Instance.new("NumberValue")			-- modifier for rain visibility for disabling/enabling over time span
GlobalModifier.Value = 1									-- 0 = fully visible, 1 = invisible

local connections = {}										-- Stores connections to RunService signals when enabled

local disabled = true										-- Value to figure out whether we are moving towards a disabled state (useful during tweens)

local rainDirection = RAIN_DEFAULT_DIRECTION				-- Direction that rain falls into

local currentCeiling = nil									-- Y coordinate of ceiling (if present)

local collisionMode = CollisionMode.None					-- Collision mode (from Rain.CollisionMode) for raycasting
local collisionList = nil									-- Blacklist/whitelist for raycasting
local collisionFunc = nil									-- Raycasting test function for when collisionMode == Rain.CollisionMode.Function

local straightLowAlpha = 1									-- Current transparency for straight rain particles
local topdownLowAlpha = 1									-- Current transparency for top-down rain particles
local intensityOccludedRain = 0								-- Current intensity of occluded rain particles
local numSplashes = 0										-- Current number of generated splashes per frame
local volumeTarget = 0										-- Current (target of tween for) sound volume

-- shorthands
local v3 = Vector3.new
local NSK010 = NumberSequenceKeypoint.new(0, 1, 0)
local NSK110 = NumberSequenceKeypoint.new(1, 1, 0)

local volumeScanGrid = {}									-- Pre-generate grid used for raining area distance scanning
for _,v in pairs(RAIN_VOLUME_SCAN_GRID) do
	table.insert(volumeScanGrid, v * RAIN_VOLUME_SCAN_RADIUS)
end
table.sort(volumeScanGrid, function(a,b)					-- Optimization: sort from close to far away for fast evaluation if closeby
	return a.magnitude &lt; b.magnitude
end)

-- sound group for easy main volume tweaking
local SoundGroup = Instance.new("SoundGroup")
SoundGroup.Name = "__RainSoundGroup"
SoundGroup.Volume = RAIN_SOUND_BASEVOLUME
SoundGroup.Archivable = false

local Sound = Instance.new("Sound")
Sound.Name = "RainSound"
Sound.Volume = volumeTarget
Sound.SoundId = RAIN_SOUND_ASSET
Sound.Looped = true
Sound.SoundGroup = SoundGroup
Sound.Parent = SoundGroup
Sound.Archivable = false

-- emitter block around camera used when outside
local Emitter do
	
	Emitter = Instance.new("Part")
	Emitter.Transparency = 1
	Emitter.Anchored = true
	Emitter.CanCollide = false
	Emitter.Locked = false
	Emitter.Archivable = false
	Emitter.TopSurface = Enum.SurfaceType.Smooth
	Emitter.BottomSurface = Enum.SurfaceType.Smooth
	Emitter.Name = "__RainEmitter"
	Emitter.Size = MIN_SIZE
	Emitter.Archivable = false
	
	local straight = Instance.new("ParticleEmitter")
	straight.Name = "RainStraight"
	straight.LightEmission = RAIN_DEFAULT_LIGHTEMISSION
	straight.LightInfluence = RAIN_DEFAULT_LIGHTINFLUENCE
	straight.Size = RAIN_STRAIGHT_SIZE
	straight.Texture = RAIN_STRAIGHT_ASSET
	straight.LockedToPart = true
	straight.Enabled = false
	straight.Lifetime = RAIN_STRAIGHT_LIFETIME
	straight.Rate = RAIN_STRAIGHT_MAX_RATE
	straight.Speed = NumberRange.new(RAIN_STRAIGHT_MAX_SPEED)
	straight.EmissionDirection = Enum.NormalId.Bottom
	straight.Parent = Emitter
	
	local topdown = Instance.new("ParticleEmitter")
	topdown.Name = "RainTopDown"
	topdown.LightEmission = RAIN_DEFAULT_LIGHTEMISSION
	topdown.LightInfluence = RAIN_DEFAULT_LIGHTINFLUENCE
	topdown.Size = RAIN_TOPDOWN_SIZE
	topdown.Texture = RAIN_TOPDOWN_ASSET
	topdown.LockedToPart = true
	topdown.Enabled = false
	topdown.Rotation = RAIN_TOPDOWN_ROTATION
	topdown.Lifetime = RAIN_TOPDOWN_LIFETIME
	topdown.Rate = RAIN_TOPDOWN_MAX_RATE
	topdown.Speed = NumberRange.new(RAIN_TOPDOWN_MAX_SPEED)
	topdown.EmissionDirection = Enum.NormalId.Bottom
	topdown.Parent = Emitter
	
end

local splashAttachments, rainAttachments do
	
	splashAttachments = {}
	rainAttachments = {}
	
	for i = 1, RAIN_SPLASH_NUM do
		
		-- splashes on ground
		local splashAttachment = Instance.new("Attachment")
		splashAttachment.Name = "__RainSplashAttachment"
		local splash = Instance.new("ParticleEmitter")
		splash.LightEmission = RAIN_DEFAULT_LIGHTEMISSION
		splash.LightInfluence = RAIN_DEFAULT_LIGHTINFLUENCE
		splash.Size = RAIN_SPLASH_SIZE
		splash.Texture = RAIN_SPLASH_ASSET
		splash.Rotation = RAIN_SPLASH_ROTATION
		splash.Lifetime = RAIN_SPLASH_LIFETIME
		splash.Transparency = NumberSequence.new {
			NSK010;
			NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, RAIN_SPLASH_ALPHA_LOW, 0);
			NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, RAIN_SPLASH_ALPHA_LOW, 0);
			NSK110;
		}
		splash.Enabled = false
		splash.Rate = 0
		splash.Speed = NumberRange.new(0)
		splash.Name = "RainSplash"
		splash.Parent = splashAttachment
		splashAttachment.Archivable = false
		table.insert(splashAttachments, splashAttachment)
		
		-- occluded rain particle generation
		local rainAttachment = Instance.new("Attachment")
		rainAttachment.Name = "__RainOccludedAttachment"
		local straightOccluded = Emitter.RainStraight:Clone()
		straightOccluded.Speed = NumberRange.new(RAIN_OCCLUDED_MINSPEED, RAIN_OCCLUDED_MAXSPEED)
		straightOccluded.SpreadAngle = RAIN_OCCLUDED_SPREAD
		straightOccluded.LockedToPart = false
		straightOccluded.Enabled = false
		straightOccluded.Parent = rainAttachment
		local topdownOccluded = Emitter.RainTopDown:Clone()
		topdownOccluded.Speed = NumberRange.new(RAIN_OCCLUDED_MINSPEED, RAIN_OCCLUDED_MAXSPEED)
		topdownOccluded.SpreadAngle = RAIN_OCCLUDED_SPREAD
		topdownOccluded.LockedToPart = false
		topdownOccluded.Enabled = false
		topdownOccluded.Parent = rainAttachment
		rainAttachment.Archivable = false
		table.insert(rainAttachments, rainAttachment)
		
	end
	
end


-- Helper methods:

local ignoreEmitterList = { Emitter }

local raycastFunctions = {
	[CollisionMode.None] = function(ray, ignoreCharacter)
		return workspace:FindPartOnRayWithIgnoreList(ray, ignoreCharacter and {Emitter, Players.LocalPlayer and Players.LocalPlayer.Character} or ignoreEmitterList)
	end;
	[CollisionMode.Blacklist] = function(ray)
		return workspace:FindPartOnRayWithIgnoreList(ray, collisionList)
	end;
	[CollisionMode.Whitelist] = function(ray)
		return workspace:FindPartOnRayWithWhitelist(ray, collisionList)
	end;
	[CollisionMode.Function] = function(ray)
		local destination = ray.Origin + ray.Direction
		-- draw multiple raycasts concatenated to each other until no hit / valid hit found
		while ray.Direction.magnitude > 0.001 do
			local part, pos, norm, mat = workspace:FindPartOnRayWithIgnoreList(ray, ignoreEmitterList)
			if not part or collisionFunc(part) then
				return part, pos, norm, mat
			end
			local start = pos + ray.Direction.Unit * 0.001
			ray = Ray.new(start, destination - start)
		end
	end;
}
local raycast = raycastFunctions[collisionMode]

local function connectLoop()
	
	local rand = Random.new()
	
	local inside = true					-- Whether camera is currently in a spot occluded from the sky
	local frame = RAIN_UPDATE_PERIOD	-- Frame counter, and force update cycle right now
	
	-- Update Emitter on RenderStepped since it needs to be synced to Camera
	table.insert(connections, RunService.RenderStepped:connect(function()
		
		-- Check if camera is outside or inside
		local part, position = raycast(Ray.new(workspace.CurrentCamera.CFrame.p, -rainDirection * RAIN_SCANHEIGHT), true)
		
		if (not currentCeiling or workspace.CurrentCamera.CFrame.p.y &lt;= currentCeiling) and not part then
			
			-- Camera is outside and under ceiling
				
			if volumeTarget &lt; 1 and not disabled then
				volumeTarget = 1
				TweenService:Create(Sound, TweenInfo.new(.5), {Volume = 1}):Play()
			end
			
			frame = RAIN_UPDATE_PERIOD
			
			local t = math.abs(workspace.CurrentCamera.CFrame.lookVector:Dot(rainDirection))
			
			local center = workspace.CurrentCamera.CFrame.p
			local right = workspace.CurrentCamera.CFrame.lookVector:Cross(-rainDirection)
			right = right.magnitude > 0.001 and right.unit or -rainDirection
			local forward = rainDirection:Cross(right).unit
			
			Emitter.Size = v3(
				RAIN_EMITTER_DIM_DEFAULT,
				RAIN_EMITTER_DIM_DEFAULT,
				RAIN_EMITTER_DIM_DEFAULT + (1 - t)*(RAIN_EMITTER_DIM_MAXFORWARD - RAIN_EMITTER_DIM_DEFAULT)
			)
			
			Emitter.CFrame =
				CFrame.new(
					center.x, center.y, center.z,
					right.x, -rainDirection.x, forward.x,
					right.y, -rainDirection.y, forward.y,
					right.z, -rainDirection.z, forward.z
				)
				+ (1 - t) * workspace.CurrentCamera.CFrame.lookVector * Emitter.Size.Z/3
				- t * rainDirection * RAIN_EMITTER_UP_MODIFIER
			
			Emitter.RainStraight.Enabled = true
			Emitter.RainTopDown.Enabled = true
			
			inside = false
			
		else
			
			-- Camera is inside / above ceiling
			
			Emitter.RainStraight.Enabled = false
			Emitter.RainTopDown.Enabled = false
		
			inside = true
			
		end
		
	end))

	-- Do the other effects on Stepped
	local signal = RunService:IsRunning() and RunService.Stepped or RunService.RenderStepped
	table.insert(connections, signal:connect(function()
		
		frame = frame + 1
		
		-- Only do some updates once every few frames
		if frame >= RAIN_UPDATE_PERIOD then
			
			-- Measure of how much camera is facing down (0-1)
			local t = math.abs(workspace.CurrentCamera.CFrame.lookVector:Dot(rainDirection))
			
			-- More looking down = see straight particles less and see top-down particles more
			local straightSequence = NumberSequence.new {
				NSK010;
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, (1 - t)*straightLowAlpha + t, 0);
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, (1 - t)*straightLowAlpha + t, 0);
				NSK110;
			}
			local topdownSequence = NumberSequence.new {
				NSK010;
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, t*topdownLowAlpha + (1 - t), 0);
				NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, t*topdownLowAlpha + (1 - t), 0);
				NSK110;
			}
			
			-- Find desired rotation for the straight rain particles
			local mapped = workspace.Camera.CFrame:inverse() * (workspace.Camera.CFrame.p - rainDirection)
			local straightRotation = NumberRange.new(math.deg(math.atan2(-mapped.x, mapped.y)))
			
			if inside then
				
				-- Update emitter properties
				for _,v in pairs(rainAttachments) do
					v.RainStraight.Transparency = straightSequence
					v.RainStraight.Rotation = straightRotation
					v.RainTopDown.Transparency = topdownSequence
				end
				
				if not disabled then
					
					-- Only do occluded volume check if not moving towards disabled state
					
					local volume = 0
					
					if (not currentCeiling or workspace.CurrentCamera.CFrame.p.y &lt;= currentCeiling) then
						
						-- Check how far away camera is from a space open to the sky using volume scan grid
						
						local minDistance = RAIN_VOLUME_SCAN_RADIUS
						local rayDirection = -rainDirection * RAIN_SCANHEIGHT
						
						for i = 1, #volumeScanGrid do -- In order, so first hit is closest
							if not raycast(Ray.new(workspace.CurrentCamera.CFrame * volumeScanGrid[i], rayDirection), true) then
								minDistance = volumeScanGrid[i].magnitude
								break
							end
						end
						
						-- Volume is inversely proportionate to minimum distance
						volume = 1 - minDistance / RAIN_VOLUME_SCAN_RADIUS
						
					end
					
					if math.abs(volume - volumeTarget) > .01 then
						-- Value is sufficiently different from previous target, overwrite it
						volumeTarget = volume
						TweenService:Create(Sound, TweenInfo.new(1), {Volume = volumeTarget}):Play()
					end
					
				end
				
			else
				
				-- Update emitter properties
				Emitter.RainStraight.Transparency = straightSequence
				Emitter.RainStraight.Rotation = straightRotation
				Emitter.RainTopDown.Transparency = topdownSequence
				
			end
			
			-- Reset frame counter
			frame = 0
			
		end
		
		local center = workspace.CurrentCamera.CFrame.p
		local right = workspace.CurrentCamera.CFrame.lookVector:Cross(-rainDirection)
		right = right.magnitude > 0.001 and right.unit or -rainDirection
		local forward = rainDirection:Cross(right).unit
		local transform = CFrame.new(
			center.x, center.y, center.z,
			right.x, -rainDirection.x, forward.x,
			right.y, -rainDirection.y, forward.y,
			right.z, -rainDirection.z, forward.z
		)
		local rayDirection = rainDirection * RAIN_OCCLUDECHECK_SCAN_Y
		
		-- Splash and occlusion effects
		for i = 1, numSplashes do
			
			local splashAttachment = splashAttachments[i]
			local rainAttachment = rainAttachments[i]
			
			-- Sample random splash position
			local x = rand:NextNumber(RAIN_OCCLUDECHECK_OFFSET_XZ_MIN, RAIN_OCCLUDECHECK_OFFSET_XZ_MAX)
			local z = rand:NextNumber(RAIN_OCCLUDECHECK_OFFSET_XZ_MIN, RAIN_OCCLUDECHECK_OFFSET_XZ_MAX)
			local part, position, normal = raycast(Ray.new(transform * v3(x, RAIN_OCCLUDECHECK_OFFSET_Y, z), rayDirection))
			
			if part then
				
				-- Draw a splash at hit
				splashAttachment.Position = position + normal * RAIN_SPLASH_CORRECTION_Y
				splashAttachment.RainSplash:Emit(1)
				
				if inside then
					
					-- Draw occlusion rain particles a little bit above the splash position
					local corrected = position - rainDirection * RAIN_SPLASH_STRAIGHT_OFFSET_Y
					if currentCeiling and corrected.Y > currentCeiling and rainDirection.Y &lt; 0 then
						corrected = corrected + rainDirection * (currentCeiling - corrected.Y) / rainDirection.Y
					end
					rainAttachment.CFrame = transform - transform.p + corrected
					rainAttachment.RainStraight:Emit(intensityOccludedRain)
					rainAttachment.RainTopDown:Emit(intensityOccludedRain)
					
				end
				
			elseif inside then
				
				-- Draw occlusion rain particles on the XZ-position at around the camera's height
				local corrected = transform * v3(x, rand:NextNumber(RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MIN, RAIN_NOSPLASH_STRAIGHT_OFFSET_Y_MAX), z)
				if currentCeiling and corrected.Y > currentCeiling and rainDirection.Y &lt; 0 then
					corrected = corrected + rainDirection * (currentCeiling - corrected.Y) / rainDirection.Y
				end
				rainAttachment.CFrame = transform - transform.p + corrected
				rainAttachment.RainStraight:Emit(intensityOccludedRain)
				rainAttachment.RainTopDown:Emit(intensityOccludedRain)
				
			end
			
		end
		
	end))

end

local function disconnectLoop()
	-- If present, disconnect all RunService connections
	if #connections > 0 then
		for _,v in pairs(connections) do
			v:disconnect()
		end
		connections = {}
	end
end

local function disableSound(tweenInfo)
	
	-- Tween the rain sound to be mute over a given easing function
	volumeTarget = 0
	local tween = TweenService:Create(Sound, tweenInfo, {Volume = 0})
	tween.Completed:connect(function(state)
		if state == Enum.PlaybackState.Completed then
			Sound:Stop()
		end
		tween:Destroy()
	end)
	tween:Play()
	
end

local function disable()
	
	disconnectLoop()
	
	-- Hide Emitter
	Emitter.RainStraight.Enabled = false
	Emitter.RainTopDown.Enabled = false
	Emitter.Size = MIN_SIZE
	
	-- Disable sound now if not tweened into disabled state beforehand
	if not disabled then
		disableSound(TweenInfo.new(RAIN_SOUND_FADEOUT_TIME))
	end
	
end

-- Shorthand for creating a tweenable "variable" using value object
local function makeProperty(valueObjectClass, defaultValue, setter)
	local valueObject = Instance.new(valueObjectClass)
	if defaultValue then
		valueObject.Value = defaultValue
	end
	valueObject.Changed:connect(setter)
	setter(valueObject.Value)
	return valueObject
end

local Color = makeProperty("Color3Value", RAIN_DEFAULT_COLOR, function(value)
	
	local value = ColorSequence.new(value)
	
	Emitter.RainStraight.Color = value
	Emitter.RainTopDown.Color = value
	
	for _,v in pairs(splashAttachments) do
		v.RainSplash.Color = value
	end
	for _,v in pairs(rainAttachments) do
		v.RainStraight.Color = value
		v.RainTopDown.Color = value
	end
	
end)

local function updateTransparency(value)
	
	local opacity = (1 - value) * (1 - GlobalModifier.Value)
	local transparency = 1 - opacity
	
	straightLowAlpha = RAIN_STRAIGHT_ALPHA_LOW * opacity + transparency
	topdownLowAlpha = RAIN_TOPDOWN_ALPHA_LOW * opacity + transparency
	
	local splashSequence = NumberSequence.new {
		NSK010;
		NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T1, opacity*RAIN_SPLASH_ALPHA_LOW + transparency, 0);
		NumberSequenceKeypoint.new(RAIN_TRANSPARENCY_T2, opacity*RAIN_SPLASH_ALPHA_LOW + transparency, 0);
		NSK110;
	}
	
	for _,v in pairs(splashAttachments) do
		v.RainSplash.Transparency = splashSequence
	end
	
end
local Transparency = makeProperty("NumberValue", RAIN_DEFAULT_TRANSPARENCY, updateTransparency)
GlobalModifier.Changed:connect(updateTransparency)

local SpeedRatio = makeProperty("NumberValue", RAIN_DEFAULT_SPEEDRATIO, function(value)
	
	Emitter.RainStraight.Speed = NumberRange.new(value * RAIN_STRAIGHT_MAX_SPEED)
	Emitter.RainTopDown.Speed = NumberRange.new(value * RAIN_TOPDOWN_MAX_SPEED)
	
end)

local IntensityRatio = makeProperty("NumberValue", RAIN_DEFAULT_INTENSITYRATIO, function(value)
	
	Emitter.RainStraight.Rate = RAIN_STRAIGHT_MAX_RATE * value
	Emitter.RainTopDown.Rate = RAIN_TOPDOWN_MAX_RATE * value
	
	intensityOccludedRain = math.ceil(RAIN_OCCLUDED_MAXINTENSITY * value)
	numSplashes = RAIN_SPLASH_NUM * value
	
end)

local LightEmission = makeProperty("NumberValue", RAIN_DEFAULT_LIGHTEMISSION, function(value)
	
	Emitter.RainStraight.LightEmission = value
	Emitter.RainTopDown.LightEmission = value
	
	for _,v in pairs(rainAttachments) do
		v.RainStraight.LightEmission = value
		v.RainTopDown.LightEmission = value
	end
	for _,v in pairs(splashAttachments) do
		v.RainSplash.LightEmission = value
	end
	
end)

local LightInfluence = makeProperty("NumberValue", RAIN_DEFAULT_LIGHTINFLUENCE, function(value)
	
	Emitter.RainStraight.LightInfluence = value
	Emitter.RainTopDown.LightInfluence = value
	
	for _,v in pairs(rainAttachments) do
		v.RainStraight.LightInfluence = value
		v.RainTopDown.LightInfluence = value
	end
	for _,v in pairs(splashAttachments) do
		v.RainSplash.LightInfluence = value
	end
	
end)

local RainDirection = makeProperty("Vector3Value", RAIN_DEFAULT_DIRECTION, function(value)
	if value.magnitude > 0.001 then
		rainDirection = value.unit
	end
end)


-- Exposed API:

local Rain = {}

Rain.CollisionMode = CollisionMode

function Rain:Enable(tweenInfo)
	
	if tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #1 to 'Enable' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	disconnectLoop() -- Just in case :Enable(..) is called multiple times on accident
	
	Emitter.RainStraight.Enabled = true
	Emitter.RainTopDown.Enabled = true
	Emitter.Parent = workspace.CurrentCamera
	
	for i = 1, RAIN_SPLASH_NUM do
		splashAttachments[i].Parent = workspace.Terrain
		rainAttachments[i].Parent = workspace.Terrain
	end
	
	if RunService:IsRunning() then -- don't need sound in studio preview, it won't work anyway
		SoundGroup.Parent = game:GetService("SoundService")
	end
	
	connectLoop()
	
	if tweenInfo then
		TweenService:Create(GlobalModifier, tweenInfo, {Value = 0}):Play()
	else
		GlobalModifier.Value = 0
	end
	
	if not Sound.Playing then
		Sound:Play()
		Sound.TimePosition = math.random()*Sound.TimeLength
	end
	
	disabled = false
	
end

function Rain:Disable(tweenInfo)
	
	if tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #1 to 'Disable' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if tweenInfo then
		local tween = TweenService:Create(GlobalModifier, tweenInfo, {Value = 1})
		tween.Completed:connect(function(state)
			if state == Enum.PlaybackState.Completed then
				-- Only disable the rain completely once the visual effects are faded out
				disable()
			end
			tween:Destroy()
		end)
		tween:Play()
		-- Start tweening out sound now as well
		disableSound(tweenInfo)
	else
		GlobalModifier.Value = 1
		disable()
	end
	
	disabled = true
	
end

function Rain:SetColor(value, tweenInfo)
		
	if typeof(value) ~= "Color3" then
		error("bad argument #1 to 'SetColor' (Color3 expected, got " .. typeof(value) .. ")", 2)
	elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #2 to 'SetColor' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if tweenInfo then
		TweenService:Create(Color, tweenInfo, {Value = value}):Play()
	else
		Color.Value = value
	end
	
end

local function makeRatioSetter(methodName, valueObject)
	-- Shorthand because most of the remaining property setters are very similar
	return function(_, value, tweenInfo)
		
		if typeof(value) ~= "number" then
			error("bad argument #1 to '" .. methodName .. "' (number expected, got " .. typeof(value) .. ")", 2)
		elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
			error("bad argument #2 to '" .. methodName .. "' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
		end
		
		value = math.clamp(value, 0, 1)
		
		if tweenInfo then
			TweenService:Create(valueObject, tweenInfo, {Value = value}):Play()
		else
			valueObject.Value = value
		end
		
	end
end

Rain.SetTransparency = makeRatioSetter("SetTransparency", Transparency)
Rain.SetSpeedRatio = makeRatioSetter("SetSpeedRatio", SpeedRatio)
Rain.SetIntensityRatio = makeRatioSetter("SetIntensityRatio", IntensityRatio)
Rain.SetLightEmission = makeRatioSetter("SetLightEmission", LightEmission)
Rain.SetLightInfluence = makeRatioSetter("SetLightInfluence", LightInfluence)

function Rain:SetVolume(volume, tweenInfo)
	
	if typeof(volume) ~= "number" then
		error("bad argument #1 to 'SetVolume' (number expected, got " .. typeof(volume) .. ")", 2)
	elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #2 to 'SetVolume' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if tweenInfo then
		TweenService:Create(SoundGroup, tweenInfo, {Volume = volume}):Play()
	else
		SoundGroup.Volume = volume
	end
	
end

function Rain:SetDirection(direction, tweenInfo)
	
	if typeof(direction) ~= "Vector3" then
		error("bad argument #1 to 'SetDirection' (Vector3 expected, got " .. typeof(direction) .. ")", 2)
	elseif tweenInfo ~= nil and typeof(tweenInfo) ~= "TweenInfo" then
		error("bad argument #2 to 'SetDirection' (TweenInfo expected, got " .. typeof(tweenInfo) .. ")", 2)
	end
	
	if not (direction.unit.magnitude > 0) then -- intentional statement formatting since NaN comparison
		warn("Attempt to set rain direction to a zero-length vector, falling back on default direction = (" .. tostring(RAIN_DEFAULT_DIRECTION) .. ")")
		direction = RAIN_DEFAULT_DIRECTION
	end
	
	if tweenInfo then
		TweenService:Create(RainDirection, tweenInfo, {Value = direction}):Play()
	else
		RainDirection.Value = direction
	end
	
end

function Rain:SetCeiling(ceiling)
	
	if ceiling ~= nil and typeof(ceiling) ~= "number" then
		error("bad argument #1 to 'SetCeiling' (number expected, got " .. typeof(ceiling) .. ")", 2)
	end
	
	currentCeiling = ceiling
	
end

function Rain:SetStraightTexture(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetStraightTexture' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	Emitter.RainStraight.Texture = asset
	
	for _,v in pairs(rainAttachments) do
		v.RainStraight.Texture = asset
	end
	
end

function Rain:SetTopDownTexture(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetStraightTexture' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	Emitter.RainTopDown.Texture = asset
	
	for _,v in pairs(rainAttachments) do
		v.RainTopDown.Texture = asset
	end
	
end

function Rain:SetSplashTexture(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetStraightTexture' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	for _,v in pairs(splashAttachments) do
		v.RainSplash.Texture = asset
	end
	
end

function Rain:SetSoundId(asset)
	
	if typeof(asset) ~= "string" then
		error("bad argument #1 to 'SetSoundId' (string expected, got " .. typeof(asset) .. ")", 2)
	end
	
	Sound.SoundId = asset
	
end

function Rain:SetCollisionMode(mode, param)
	
	if mode == CollisionMode.None then
		
		-- Regular mode needs no white/blacklist or test function
		collisionList = nil
		collisionFunc = nil
		
	elseif mode == CollisionMode.Blacklist then
		
		if typeof(param) == "Instance" then
			-- Add Emitter anyway, since users will probably not expect collisions with emitter block regardless
			collisionList = {param, Emitter}
		elseif typeof(param) == "table" then
			for i = 1, #param do
				if typeof(param[i]) ~= "Instance" then
					error("bad argument #2 to 'SetCollisionMode' (blacklist contained a " .. typeof(param[i]) .. " on index " .. tostring(i) .. " which is not an Instance)", 2)
				end
			end
			collisionList = {Emitter} -- see above
			for i = 1, #param do
				table.insert(collisionList, param[i])
			end
		else
			error("bad argument #2 to 'SetCollisionMode (Instance or array of Instance expected, got " .. typeof(param) .. ")'", 2)
		end
		
		-- Blacklist does not need a test function
		collisionFunc = nil
		
	elseif mode == CollisionMode.Whitelist then
		
		if typeof(param) == "Instance" then
			collisionList = {param}
		elseif typeof(param) == "table" then
			for i = 1, #param do
				if typeof(param[i]) ~= "Instance" then
					error("bad argument #2 to 'SetCollisionMode' (whitelist contained a " .. typeof(param[i])  .. " on index " .. tostring(i) .. " which is not an Instance)", 2)
				end
			end
			collisionList = {}
			for i = 1, #param do
				table.insert(collisionList, param[i])
			end
		else
			error("bad argument #2 to 'SetCollisionMode (Instance or array of Instance expected, got " .. typeof(param) .. ")'", 2)
		end
		
		-- Whitelist does not need a test function
		collisionFunc = nil
		
	elseif mode == CollisionMode.Function then
		
		if typeof(param) ~= "function" then
			error("bad argument #2 to 'SetCollisionMode' (function expected, got " .. typeof(param) .. ")", 2)
		end
		
		-- Test function does not need a list
		collisionList = nil
		
		collisionFunc = param
		
	else
		error("bad argument #1 to 'SetCollisionMode (Rain.CollisionMode expected, got " .. typeof(param) .. ")'", 2)
	end
	
	collisionMode = mode
	raycast = raycastFunctions[mode]
	
end

return Rain</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="40">
          <Properties>
            <string name="Name">Cmdr</string>
            <string name="Source">local RunService = game:GetService("RunService")
local Util = require(script.Shared:WaitForChild("Util"))

if RunService:IsServer() == false then
	error("Cmdr server module is somehow running on a client!")
end

local Cmdr do
	Cmdr = setmetatable({
		ReplicatedRoot = nil;
		RemoteFunction = nil;
		RemoteEvent = nil;
		Util = Util;
		DefaultCommandsFolder = script.BuiltInCommands;
	}, {
		__index = function (self, k)
			local r = self.Registry[k]
			if r and type(r) == "function" then
				return function (_, ...)
					return r(self.Registry, ...)
				end
			end
		end
	})

	Cmdr.Registry = require(script.Shared.Registry)(Cmdr)
	Cmdr.Dispatcher = require(script.Shared.Dispatcher)(Cmdr)

	require(script.Initialize)(Cmdr)
end

-- Handle command invocations from the clients.
Cmdr.RemoteFunction.OnServerInvoke = function (player, text, options)
	return Cmdr.Dispatcher:EvaluateAndRun(text, player, options)
end

return Cmdr</string>
          </Properties>
          <Item class="Folder" referent="41">
            <Properties>
              <string name="Name">BuiltInCommands</string>
            </Properties>
            <Item class="Folder" referent="42">
              <Properties>
                <string name="Name">Admin</string>
              </Properties>
              <Item class="ModuleScript" referent="43">
                <Properties>
                  <string name="Name">announce</string>
                  <string name="Source">return {
	Name = "announce";
	Aliases = {"m"};
	Description = "Makes a server-wide announcement.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "string";
			Name = "text";
			Description = "The announcement text.";
		},
	};
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="44">
                <Properties>
                  <string name="Name">announceServer</string>
                  <string name="Source">local TextService = game:GetService("TextService")
local Players = game:GetService("Players")

return function (context, text)
	local filterResult = TextService:FilterStringAsync(text, context.Executor.UserId, Enum.TextFilterContext.PublicChat)

	for _, player in ipairs(Players:GetPlayers()) do
		context:SendEvent(player, "Message", filterResult:GetChatForUserAsync(player.UserId), context.Executor)
	end

	return "Created announcement."
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="45">
                <Properties>
                  <string name="Name">bring</string>
                  <string name="Source">return {
	Name = "bring";
	Description = "Brings a player or set of players to you.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "players";
			Description = "The players to bring";
		},
	};
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="46">
                <Properties>
                  <string name="Name">bringServer</string>
                  <string name="Source"><![CDATA[local teleport = require(script.Parent:WaitForChild("teleportServer"))

return function (context, fromPlayers)
	return teleport(context, fromPlayers, context.Executor)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="47">
                <Properties>
                  <string name="Name">kick</string>
                  <string name="Source">return {
	Name = "kick";
	Aliases = {"boot"};
	Description = "Kicks a player or set of players.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "players";
			Description = "The players to kick.";
		},
	};
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="48">
                <Properties>
                  <string name="Name">kickServer</string>
                  <string name="Source">return function (_, players)
	for _, player in pairs(players) do
		player:Kick("Kicked by admin.")
	end

	return ("Kicked %d players."):format(#players)
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="49">
                <Properties>
                  <string name="Name">kill</string>
                  <string name="Source">return {
	Name = "kill";
	Aliases = {"slay"};
	Description = "Kills a player or set of players.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "victims";
			Description = "The players to kill.";
		},
	};
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="50">
                <Properties>
                  <string name="Name">killServer</string>
                  <string name="Source">return function (_, players)
	for _, player in pairs(players) do
		if player.Character then
			player.Character:BreakJoints()
		end
	end

	return ("Killed %d players."):format(#players)
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="51">
                <Properties>
                  <string name="Name">teleport</string>
                  <string name="Source">return {
	Name = "teleport";
	Aliases = {"tp"};
	Description = "Teleports a player or set of players to one target.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "From";
			Description = "The players to teleport";
		},
		{
			Type = "player @ vector3";
			Name = "Destination";
			Description = "The player to teleport to"
		}
	};
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="52">
                <Properties>
                  <string name="Name">teleportServer</string>
                  <string name="Source"><![CDATA[return function (_, fromPlayers, destination)
	local cframe

	if typeof(destination) == "Instance" then
		if destination.Character and destination.Character:FindFirstChild("HumanoidRootPart") then
			cframe = destination.Character.HumanoidRootPart.CFrame
		else
			return "Target player has no character."
		end
	elseif typeof(destination) == "Vector3" then
		cframe = CFrame.new(destination)
	end

	for _, player in ipairs(fromPlayers) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			player.Character.HumanoidRootPart.CFrame = cframe
		end
	end

	return ("Teleported %d players."):format(#fromPlayers)
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="53">
              <Properties>
                <string name="Name">Debug</string>
              </Properties>
              <Item class="ModuleScript" referent="54">
                <Properties>
                  <string name="Name">blink</string>
                  <string name="Source">return {
	Name = "blink";
	Aliases = {"b"};
	Description = "Teleports you to where your mouse is hovering.";
	Group = "DefaultDebug";
	Args = {};

	ClientRun = function(context)
		-- We implement this here because player position is owned by the client.
		-- No reason to bother the server for this!

		local mouse = context.Executor:GetMouse()
		local character = context.Executor.Character

		if not character then
			return "You don't have a character."
		end

		character:MoveTo(mouse.Hit.p)

		return "Blinked!"
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="55">
                <Properties>
                  <string name="Name">position</string>
                  <string name="Source">local Players = game:GetService("Players")

return {
	Name = "position";
	Aliases = {"pos"};
	Description = "Returns Vector3 position of you or other players. Empty string is the player has no character.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "player";
			Name = "Player";
			Description = "The player to report the position of. Omit for your own position.";
			Default = Players.LocalPlayer;
		}
	};

	ClientRun = function(_, player)
		local character = player.Character

		if not character or not character:FindFirstChild("HumanoidRootPart") then
			return ""
		end

		return tostring(character.HumanoidRootPart.Position):gsub("%s", "")
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="56">
                <Properties>
                  <string name="Name">thru</string>
                  <string name="Source">return {
	Name = "thru";
	Aliases = {"t", "through"};
	Description = "Teleports you through whatever your mouse is hovering over, placing you equidistantly from the wall.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "number";
			Name = "Extra distance";
			Description = "Go through the wall an additional X studs.";
			Default = 0;
		}
	};

	ClientRun = function(context, extra)
		-- We implement this here because player position is owned by the client.
		-- No reason to bother the server for this!

		local mouse = context.Executor:GetMouse()
		local character = context.Executor.Character

		if not character or not character:FindFirstChild("HumanoidRootPart") then
			return "You don't have a character."
		end

		local pos = character.HumanoidRootPart.Position
		local diff = (mouse.Hit.p - pos)

		character:MoveTo((diff * 2) + (diff.unit * extra) + pos)

		return "Blinked!"
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="57">
                <Properties>
                  <string name="Name">to</string>
                  <string name="Source">return {
	Name = "to";
	Description = "Teleports you to another player.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "player @ vector3";
			Name = "Destination";
			Description = "The player or location to teleport to."
		}
	};
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="58">
                <Properties>
                  <string name="Name">toServer</string>
                  <string name="Source"><![CDATA[local teleport = require(script.Parent.Parent:WaitForChild("Admin"):WaitForChild("teleportServer"))

return function (context, toPlayer)
	return teleport(context, { context.Executor }, toPlayer)
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="59">
              <Properties>
                <string name="Name">Utility</string>
              </Properties>
              <Item class="ModuleScript" referent="60">
                <Properties>
                  <string name="Name">alias</string>
                  <string name="Source">return {
	Name = "alias";
	Aliases = {};
	Description = "Creates a new, single command out of a command and given arguments.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Alias name";
			Description = "The key or input type you'd like to bind the command to."
		},
		{
			Type = "string";
			Name = "Command string";
			Description = "The command text you want to run. Separate multiple commands with \"&amp;&amp;\". Accept arguments with $1, $2, $3, etc."
		},
	};

	ClientRun = function(context, name, commandString)
		context.Cmdr.Registry:RegisterCommandObject(
			context.Cmdr.Util.MakeAliasCommand(name, commandString),
			true
		)

		return ("Created alias %q"):format(name)
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="61">
                <Properties>
                  <string name="Name">bind</string>
                  <string name="Source">local UserInputService = game:GetService("UserInputService")

return {
	Name = "bind";
	Aliases = {};
	Description = "Binds a command string to a key or mouse input.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "userInput ! bindableResource @ player";
			Name = "Input";
			Description = "The key or input type you'd like to bind the command to."
		},
		{
			Type = "command";
			Name = "Command";
			Description = "The command you want to run on this input"
		},
		{
			Type = "string";
			Name = "Arguments";
			Description = "The arguments for the command";
			Default = "";
		}
	};

	ClientRun = function(context, bind, command, arguments)
		local binds = context:GetStore("CMDR_Binds")

		command = command .. " " .. arguments

		if binds[bind] then
			binds[bind]:Disconnect()
		end

		local bindType = context:GetArgument(1).Type.Name

		if bindType == "userInput" then
			binds[bind] = UserInputService.InputBegan:Connect(function(input, gameProcessed)
				if gameProcessed then
					return
				end

				if input.UserInputType == bind or input.KeyCode == bind then
					context:Reply(context.Dispatcher:EvaluateAndRun(context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, command)))
				end
			end)
		elseif bindType == "bindableResource" then
			return "Unimplemented..."
		elseif bindType == "player" then
			binds[bind] = bind.Chatted:Connect(function(message)
				local args = { message }
				local chatCommand = context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, context.Cmdr.Util.SubstituteArgs(command, args))
				context:Reply(("%s $ %s : %s"):format(
					bind.Name,
					chatCommand,
					context.Dispatcher:EvaluateAndRun(chatCommand)
				), Color3.fromRGB(244, 92, 66))
			end)
		end


		return "Bound command to input."
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="62">
                <Properties>
                  <string name="Name">clear</string>
                  <string name="Source"><![CDATA[local Players = game:GetService("Players")

return {
	Name = "clear",
	Aliases = {},
	Description = "Clear all lines above the entry line of the Cmdr window.",
	Group = "DefaultUtil",
	Args = {},
	ClientRun = function()
		local player = Players.LocalPlayer
		local gui = player:WaitForChild("PlayerGui"):WaitForChild("Cmdr")
		local frame = gui:WaitForChild("Frame")

		if gui and frame then
			for _, child in pairs(frame:GetChildren()) do
				if child.Name == "Line" and child:IsA("TextLabel") then
					child:Destroy()
				end
			end
		end
		return ""
	end
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="63">
                <Properties>
                  <string name="Name">echo</string>
                  <string name="Source">return {
	Name = "echo";
	Aliases = {};
	Description = "Echoes your text back to you.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Text";
			Description = "The text."
		},
	};

	ClientRun = function(_, text)
		return text
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="64">
                <Properties>
                  <string name="Name">history</string>
                  <string name="Source">return {
	Name = "history";
	Aliases = {};
	AutoExec = {
		"alias ! run ${history $1}";
		"alias ^ run ${run replace ${history -1} $1 $2}";
		"alias !! ! -1";
	};
	Description = "Displays previous commands from history.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "integer";
			Name = "Line Number";
			Description = "Command line number (can be negative to go from end)"
		},
	};

	ClientRun = function(context, line)
		local history = context.Dispatcher:GetHistory()

		if line &lt;= 0 then
			line = #history + line
		end

		return history[line] or ""
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="65">
                <Properties>
                  <string name="Name">hover</string>
                  <string name="Source">local Players = game:GetService("Players")

return {
	Name = "hover";
	Description = "Returns the name of the player you are hovering over.";
	Group = "DefaultUtil";
	Args = {};

	ClientRun = function()
		local mouse = Players.LocalPlayer:GetMouse()
		local target = mouse.Target

		if not target then
			return ""
		end

		local p = Players:GetPlayerFromCharacter(target:FindFirstAncestorOfClass("Model"))

		return p and p.Name or ""
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="66">
                <Properties>
                  <string name="Name">replace</string>
                  <string name="Source">return {
	Name = "replace";
	Aliases = {};
	Description = "Replaces text A with text B";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Haystack";
			Description = "The source string upon which to perform replacement."
		},
		{
			Type = "string";
			Name = "Needle";
			Description = "The string pattern search for."
		},
		{
			Type = "string";
			Name = "Replacement";
			Description = "The string to replace matches (%1 to insert matches)."
		},
	};

	ClientRun = function(_, haystack, needle, replacement)
		return haystack:gsub(needle, replacement)
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="67">
                <Properties>
                  <string name="Name">run</string>
                  <string name="Source">return {
	Name = "run";
	Aliases = {};
	AutoExec = {
		"alias discard replace ${run $1} .* \\\"\\\""
	};
	Description = "Runs a given command string (replacing embedded commands).";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Command";
			Description = "The command string to run"
		},
	};

	ClientRun = function(context, command)
		return context.Dispatcher:EvaluateAndRun(context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, command))
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="68">
                <Properties>
                  <string name="Name">runif</string>
                  <string name="Source">local conditions = {
	startsWith = function (text, arg)
		if text:sub(1, #arg) == arg then
			return text:sub(#arg + 1)
		end
	end
}

return {
	Name = "runif";
	Aliases = {};
	Description = "Runs a given command string if a certain condition is met.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "conditionFunction";
			Name = "Condition";
			Description = "The condition function"
		},
		{
			Type = "string";
			Name = "Argument";
			Description = "The argument to the condition function"
		},
		{
			Type = "string";
			Name = "Test against";
			Description = "The text to test against."
		},
		{
			Type = "string";
			Name = "Command";
			Description = "The command string to run if requirements are met. If omitted, return value from condition function is used.";
			Optional = true;
		},
	};

	ClientRun = function(context, condition, arg, testAgainst, command)
		local conditionFunc = conditions[condition]

		if not conditionFunc then
			return ("Condition %q is not valid."):format(condition)
		end

		local text = conditionFunc(testAgainst, arg)

		if text then
			return context.Dispatcher:EvaluateAndRun(context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, command or text))
		end

		return ""
	end
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="69">
                <Properties>
                  <string name="Name">unbind</string>
                  <string name="Source">return {
	Name = "unbind";
	Aliases = {};
	Description = "Unbinds an input previously bound with Bind";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "userInput ! bindableResource @ player";
			Name = "Input/Key";
			Description = "The key or input type you'd like to unbind."
		}
	};

	ClientRun = function(context, inputEnum)
		local binds = context:GetStore("CMDR_Binds")

		if binds[inputEnum] then
			binds[inputEnum]:Disconnect()
			binds[inputEnum] = nil
			return "Unbound command from input."
		else
			return "That input wasn't bound."
		end
	end
}</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="70">
              <Properties>
                <string name="Name">help</string>
                <string name="Source">return {
	Name = "help";
	Description = "Displays a list of all commands, or inspects one command.";
	Group = "Help";
	Args = {
		{
			Type = "command";
			Name = "Command";
			Description = "The command to view information on";
			Optional = true;
		},
	};

	ClientRun = function (context, commandName)
		if commandName then
			local command = context.Cmdr.Registry:GetCommand(commandName)
			context:Reply(("Command: %s"):format(command.Name), Color3.fromRGB(230, 126, 34))
			if command.Aliases and #command.Aliases > 0 then
				context:Reply(("Aliases: %s"):format(table.concat(command.Aliases, ", ")), Color3.fromRGB(230, 230, 230))
			end
			context:Reply(command.Description, Color3.fromRGB(230, 230, 230))
			for i, arg in ipairs(command.Args) do
				context:Reply(("#%d %s%s: %s - %s"):format(
					i,
					arg.Name,
					arg.Optional == true and "?" or "",
					arg.Type, arg.Description
				))
			end
		else
			local commands = context.Cmdr.Registry:GetCommands()

			for _, cmd in pairs(commands) do
				context:Reply(("%s - %s"):format(cmd.Name, cmd.Description))
			end
		end
		return ""
	end;
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="71">
            <Properties>
              <string name="Name">BuiltInTypes</string>
            </Properties>
            <Item class="ModuleScript" referent="72">
              <Properties>
                <string name="Name">BindableResource</string>
                <string name="Source"><![CDATA[return function (registry)
	registry:RegisterType("bindableResource", registry.Cmdr.Util.MakeEnumType("BindableResource", {"Chat"}))
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="73">
              <Properties>
                <string name="Name">BrickColor</string>
                <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local brickColorNames = {
    "White", "Grey", "Light yellow", "Brick yellow", "Light green (Mint)", "Light reddish violet", "Pastel Blue",
    "Light orange brown", "Nougat", "Bright red", "Med. reddish violet", "Bright blue", "Bright yellow", "Earth orange",
    "Black", "Dark grey", "Dark green", "Medium green", "Lig. Yellowich orange", "Bright green", "Dark orange",
    "Light bluish violet", "Transparent", "Tr. Red", "Tr. Lg blue", "Tr. Blue", "Tr. Yellow", "Light blue",
    "Tr. Flu. Reddish orange", "Tr. Green", "Tr. Flu. Green", "Phosph. White", "Light red", "Medium red", "Medium blue",
    "Light grey", "Bright violet", "Br. yellowish orange", "Bright orange", "Bright bluish green", "Earth yellow",
    "Bright bluish violet", "Tr. Brown", "Medium bluish violet", "Tr. Medi. reddish violet", "Med. yellowish green",
    "Med. bluish green", "Light bluish green", "Br. yellowish green", "Lig. yellowish green", "Med. yellowish orange",
    "Br. reddish orange", "Bright reddish violet", "Light orange", "Tr. Bright bluish violet", "Gold", "Dark nougat",
    "Silver", "Neon orange", "Neon green", "Sand blue", "Sand violet", "Medium orange", "Sand yellow", "Earth blue",
    "Earth green", "Tr. Flu. Blue", "Sand blue metallic", "Sand violet metallic", "Sand yellow metallic",
    "Dark grey metallic", "Black metallic", "Light grey metallic", "Sand green", "Sand red", "Dark red",
    "Tr. Flu. Yellow", "Tr. Flu. Red", "Gun metallic", "Red flip/flop", "Yellow flip/flop", "Silver flip/flop", "Curry",
    "Fire Yellow", "Flame yellowish orange", "Reddish brown", "Flame reddish orange", "Medium stone grey", "Royal blue",
    "Dark Royal blue", "Bright reddish lilac", "Dark stone grey", "Lemon metalic", "Light stone grey", "Dark Curry",
    "Faded green", "Turquoise", "Light Royal blue", "Medium Royal blue", "Rust", "Brown", "Reddish lilac", "Lilac",
    "Light lilac", "Bright purple", "Light purple", "Light pink", "Light brick yellow", "Warm yellowish orange",
    "Cool yellow", "Dove blue", "Medium lilac", "Slime green", "Smoky grey", "Dark blue", "Parsley green", "Steel blue",
    "Storm blue", "Lapis", "Dark indigo", "Sea green", "Shamrock", "Fossil", "Mulberry", "Forest green", "Cadet blue",
    "Electric blue", "Eggplant", "Moss", "Artichoke", "Sage green", "Ghost grey", "Lilac", "Plum", "Olivine",
    "Laurel green", "Quill grey", "Crimson", "Mint", "Baby blue", "Carnation pink", "Persimmon", "Maroon", "Gold",
    "Daisy orange", "Pearl", "Fog", "Salmon", "Terra Cotta", "Cocoa", "Wheat", "Buttermilk", "Mauve", "Sunrise",
    "Tawny", "Rust", "Cashmere", "Khaki", "Lily white", "Seashell", "Burgundy", "Cork", "Burlap", "Beige", "Oyster",
    "Pine Cone", "Fawn brown", "Hurricane grey", "Cloudy grey", "Linen", "Copper", "Dirt brown", "Bronze", "Flint",
    "Dark taupe", "Burnt Sienna", "Institutional white", "Mid gray", "Really black", "Really red", "Deep orange",
    "Alder", "Dusty Rose", "Olive", "New Yeller", "Really blue", "Navy blue", "Deep blue", "Cyan", "CGA brown",
    "Magenta", "Pink", "Deep orange", "Teal", "Toothpaste", "Lime green", "Camo", "Grime", "Lavender",
    "Pastel light blue", "Pastel orange", "Pastel violet", "Pastel blue-green", "Pastel green", "Pastel yellow",
    "Pastel brown", "Royal purple", "Hot pink"
}

local brickColorFinder = Util.MakeFuzzyFinder(brickColorNames)

local brickColorType =  {
	Prefixes = "% teamColor";

    Transform = function(text)
        local brickColors = {}
        for i, name in pairs(brickColorFinder(text)) do
            brickColors[i] = BrickColor.new(name)
        end
        return brickColors
    end;

    Validate = function(brickColors)
        return #brickColors > 0, "No valid brick colors with that name could be found."
    end;

    Autocomplete = function(brickColors)
        return Util.GetNames(brickColors)
    end;

    Parse = function(brickColors)
        return brickColors[1]
    end;
}

local brickColor3Type = {
	Transform = brickColorType.Transform;
	Validate = brickColorType.Validate;
	Autocomplete = brickColorType.Autocomplete;

	Parse = function(brickColors)
		return brickColors[1].Color
	end;
}

return function(registry)
    registry:RegisterType("brickColor", brickColorType)
	registry:RegisterType("brickColors", Util.MakeListableType(brickColorType, {
		Prefixes = "% teamColors"
	}))

	registry:RegisterType("brickColor3", brickColor3Type)
    registry:RegisterType("brickColor3s", Util.MakeListableType(brickColor3Type))
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="74">
              <Properties>
                <string name="Name">Color3</string>
                <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local color3Type = Util.MakeSequenceType({
	Prefixes = "# hexColor3 ! brickColor3";
	ValidateEach = function(value, i)
		if value == nil then
			return false, ("Invalid or missing number at position %d in Color3 type."):format(i)
		elseif value < 0 or value > 255 then
			return false, ("Number out of acceptable range 0-255 at position %d in Color3 type."):format(i)
		elseif value % 1 ~= 0 then
			return false, ("Number is not an integer at position %d in Color3 type."):format(i)
		end

		return true
	end;
	TransformEach = tonumber;
	Constructor = Color3.fromRGB;
	Length = 3;
})

local function parseHexDigit(x)
	if #x == 1 then
		x = x .. x
	end

	return tonumber(x, 16)
end

local hexColor3Type = {
	Transform = function(text)
		local r, g, b = text:match("^#?(%x%x?)(%x%x?)(%x%x?)$")
		return Util.Each(parseHexDigit, r, g, b)
	end;

	Validate = function(r, g, b)
		return r ~= nil and g ~= nil and b ~= nil, "Invalid hex color"
	end;

	Parse = function(...)
		return Color3.fromRGB(...)
	end;
}

return function (cmdr)
	cmdr:RegisterType("color3", color3Type)
	cmdr:RegisterType("color3s", Util.MakeListableType(color3Type, {
		Prefixes = "# hexColor3s ! brickColor3s"
	}))

	cmdr:RegisterType("hexColor3", hexColor3Type)
	cmdr:RegisterType("hexColor3s", Util.MakeListableType(hexColor3Type))
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="75">
              <Properties>
                <string name="Name">Command</string>
                <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

return function (cmdr)
	local commandType = {
		Transform = function (text)
			local findCommand = Util.MakeFuzzyFinder(cmdr:GetCommandsAsStrings())

			return findCommand(text)
		end;

		Validate = function (commands)
			return #commands > 0, "No command with that name could be found."
		end;

		Autocomplete = function (commands)
			return commands
		end;

		Parse = function (commands)
			return commands[1]
		end;
	}

	cmdr:RegisterType("command", commandType)
	cmdr:RegisterType("commands", Util.MakeListableType(commandType))
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="76">
              <Properties>
                <string name="Name">ConditionFunction</string>
                <string name="Source"><![CDATA[return function (registry)
	registry:RegisterType("conditionFunction", registry.Cmdr.Util.MakeEnumType("ConditionFunction", {"startsWith"}))
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="77">
              <Properties>
                <string name="Name">Duration</string>
                <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local unitTable = {
    Years = 31556926,
    Months = 2629744,
    Weeks = 604800,
    Days = 86400,
    Hours = 3600,
    Minutes = 60,
    Seconds = 1
}

local searchKeyTable = {}
for key, _ in pairs(unitTable) do
    table.insert(searchKeyTable, key)
end
local unitFinder = Util.MakeFuzzyFinder(searchKeyTable)

local function stringToSecondDuration(stringDuration)
    -- The duration cannot be null or an empty string.
    if stringDuration == nil or stringDuration == "" then
        return nil
    end
    -- Allow 0 by itself (without a unit) to indicate 0 seconds
    local durationNum = tonumber(stringDuration)
    if durationNum and durationNum == 0 then
        return 0, 0, true
    end
    -- The duration must end with a unit,
    -- if it doesn't then return true as the fourth value to indicate the need to offer autocomplete for units.
    local endOnlyString = stringDuration:gsub("%d+%a+", "")
    local endNumber = endOnlyString:match("%d+")
    if endNumber then
        return nil, tonumber(endNumber), true
    end
    local seconds = nil
    local rawNum, rawUnit
    for rawComponent in stringDuration:gmatch("%d+%a+") do
        rawNum, rawUnit = rawComponent:match("(%d+)(%a+)")
        local unitNames = unitFinder(rawUnit)
        -- There were no matching units, it's invalid. Return the parsed number to be used for autocomplete
        if #unitNames == 0 then
            return nil, tonumber(rawNum)
        end
        if seconds == nil then seconds = 0 end
        -- While it was already defaulting to use minutes when using just "m", this does it without worrying
        -- about any consistency between list ordering.
        seconds = seconds + (rawUnit:lower() == "m" and 60 or unitTable[unitNames[1]]) * tonumber(rawNum)
    end
    -- If no durations were provided, return nil.
    if seconds == nil then
        return nil
    else
        return seconds, tonumber(rawNum)
    end
end

local function mapUnits(units, rawText, lastNumber, subStart)
    subStart = subStart or 1
    local returnTable = {}
    for i, unit in pairs(units) do
        if lastNumber == 1 then
            returnTable[i] = rawText .. unit:sub(subStart, #unit - 1)
        else
            returnTable[i] = rawText .. unit:sub(subStart)
        end
    end
    return returnTable
end

local durationType = {
    Transform = function(text)
        return text, stringToSecondDuration(text)
    end;

    Validate = function(_, duration)
        return duration ~= nil and duration >= 0
    end;

    Autocomplete = function(rawText, duration, lastNumber, isUnitMissing, matchedUnits)
        local returnTable = {}
        if isUnitMissing or matchedUnits then
            local unitsTable = isUnitMissing == true and unitFinder("") or matchedUnits
            if isUnitMissing == true then
                -- Concat the entire unit name to existing text.
                returnTable = mapUnits(unitsTable, rawText, lastNumber)
            else
                -- Concat the rest of the unit based on what already exists of the unit name.
                local existingUnitLength = rawText:match("^.*(%a+)$"):len()
                returnTable = mapUnits(unitsTable, rawText, existingUnitLength + 1)
            end
        elseif duration ~= nil then
            local endingUnit = rawText:match("^.*%d+(%a+)$")
            -- Assume there is a singular match at this point
            local fuzzyUnits = unitFinder(endingUnit)
            -- List all possible fuzzy matches. This is for the Minutes/Months ambiguity case.
            returnTable = mapUnits(fuzzyUnits, rawText, lastNumber, #endingUnit + 1)
            -- Sort alphabetically in the Minutes/Months case, so Minutes are displayed on top.
            table.sort(returnTable)
        end
        return returnTable
    end;

    Parse = function(_, duration)
        return duration
    end;
}

return function(registry)
    registry:RegisterType("duration", durationType)
    registry:RegisterType("durations", Util.MakeListableType(durationType))
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="78">
              <Properties>
                <string name="Name">Player</string>
                <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)
local Players = game:GetService("Players")

local function ShorthandSingle (text, executor)
	if text == "." or text == "me" then
		return {executor}
	end
end

local function ShorthandMultiple (text, executor)
	if text == "*" or text == "all" then
		return Players:GetPlayers()
	elseif text == "others" then
		local Others = Players:GetPlayers()
		for i = 1, #Others do
			if Others[i] == executor then
				table.remove(Others, i)
				break
			end
		end
		return Others
	end
end

local function CheckShorthands (text, executor, ...)
	for _, func in pairs({...}) do
		local values = func(text, executor)

		if values then return values end
	end
end

local playerType = {
	Transform = function (text, executor)
		local shorthand = CheckShorthands(text, executor, ShorthandSingle)
		if shorthand then
			return shorthand
		end

		local findPlayer = Util.MakeFuzzyFinder(Players:GetPlayers())

		return findPlayer(text)
	end;

	Validate = function (players)
		return #players > 0, "No player with that name could be found."
	end;

	Autocomplete = function (players)
		return Util.GetNames(players)
	end;

	Parse = function (players)
		return players[1]
	end;
}

local playersType = {
	Listable = true;
	Prefixes = "% teamPlayers";

	Transform = function (text, executor)
		local shorthand = CheckShorthands(text, executor, ShorthandSingle, ShorthandMultiple)

		if shorthand then
			return shorthand, true
		end

		local findPlayers = Util.MakeFuzzyFinder(Players:GetPlayers())

		return findPlayers(text)
	end;

	Validate = function (players)
		return #players > 0, "No players were found matching that query."
	end;

	Autocomplete = function (players)
		return Util.GetNames(players)
	end;

	Parse = function (players, returnAll)
		return returnAll and players or { players[1] }
	end;
}

return function (cmdr)
	cmdr:RegisterType("player", playerType)
	cmdr:RegisterType("players", playersType)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="79">
              <Properties>
                <string name="Name">PlayerId</string>
                <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)
local Players = game:GetService("Players")

local nameCache = {}
local function getUserId(name)
	if nameCache[name] then
		return nameCache[name]
	elseif Players:FindFirstChild(name) then
		nameCache[name] = Players[name].UserId
		return Players[name].UserId
	else
		local ok, userid = pcall(Players.GetUserIdFromNameAsync, Players, name)

		if not ok then
			return nil
		end

		nameCache[name] = userid
		return userid
	end
end

local playerIdType = {
	DisplayName = "Full Player Name";
	Prefixes = "# integer";

	Transform = function (text)
		local findPlayer = Util.MakeFuzzyFinder(Players:GetPlayers())

		return text, findPlayer(text)
	end;

	ValidateOnce = function (text)
		return getUserId(text) ~= nil, "No player with that name could be found."
	end;

	Autocomplete = function (_, players)
		return Util.GetNames(players)
	end;

	Parse = function (text)
		return getUserId(text)
	end;
}

return function (cmdr)
	cmdr:RegisterType("playerId", playerIdType)
	cmdr:RegisterType("playerIds", Util.MakeListableType(playerIdType, {
		Prefixes = "# integers"
	}))
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="80">
              <Properties>
                <string name="Name">Primitives</string>
                <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local stringType = {
	Validate = function (value)
		return value ~= nil
	end;

	Parse = function (value)
		return tostring(value)
	end;
}

local numberType = {
	Transform = function (text)
		return tonumber(text)
	end;

	Validate = function (value)
		return value ~= nil
	end;

	Parse = function (value)
		return value
	end;
}

local intType = {
	Transform = function (text)
		return tonumber(text)
	end;

	Validate = function (value)
		return value ~= nil and value == math.floor(value), "Only whole numbers are valid."
	end;

	Parse = function (value)
		return value
	end
}

local boolType do
	local truthy = Util.MakeDictionary({"true", "t", "yes", "y", "on", "enable", "enabled", "1", "+"});
	local falsy = Util.MakeDictionary({"false"; "f"; "no"; "n"; "off"; "disable"; "disabled"; "0"; "-"});

	boolType = {
		Transform = function (text)
			return text:lower()
		end;

		Validate = function (value)
			return truthy[value] ~= nil or falsy[value] ~= nil, "Please use true/yes/on or false/no/off."
		end;

		Parse = function (value)
			if truthy[value] then
				return true
			elseif falsy[value] then
				return false
			else
				error("Unknown boolean value.")
			end
		end;
	}
end

return function (cmdr)
	cmdr:RegisterType("string", stringType)
	cmdr:RegisterType("number", numberType)
	cmdr:RegisterType("integer", intType)
	cmdr:RegisterType("boolean", boolType)

	cmdr:RegisterType("strings", Util.MakeListableType(stringType))
	cmdr:RegisterType("numbers", Util.MakeListableType(numberType))
	cmdr:RegisterType("integers", Util.MakeListableType(intType))
	cmdr:RegisterType("booleans", Util.MakeListableType(boolType))
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="81">
              <Properties>
                <string name="Name">Team</string>
                <string name="Source">local Teams = game:GetService("Teams")
local Util = require(script.Parent.Parent.Shared.Util)

local teamType = {
	Transform = function (text)
		local findTeam = Util.MakeFuzzyFinder(Teams:GetTeams())

		return findTeam(text)
	end;

	Validate = function (teams)
		return #teams > 0, "No team with that name could be found."
	end;

	Autocomplete = function (teams)
		return Util.GetNames(teams)
	end;

	Parse = function (teams)
		return teams[1];
	end;
}

local teamPlayersType = {
	Listable = true;
	Transform = teamType.Transform;
	Validate = teamType.Validate;
	Autocomplete = teamType.Autocomplete;

	Parse = function (teams)
		return teams[1]:GetPlayers()
	end;
}

local teamColorType = {
	Transform = teamType.Transform;
	Validate = teamType.Validate;
	Autocomplete = teamType.Autocomplete;

	Parse = function (teams)
		return teams[1].TeamColor
	end;
}

return function (cmdr)
	cmdr:RegisterType("team", teamType)
	cmdr:RegisterType("teams", Util.MakeListableType(teamType))

	cmdr:RegisterType("teamPlayers", teamPlayersType)

	cmdr:RegisterType("teamColor", teamColorType)
	cmdr:RegisterType("teamColors", Util.MakeListableType(teamColorType))
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="82">
              <Properties>
                <string name="Name">UserInput</string>
                <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local combinedInputEnums = Enum.UserInputType:GetEnumItems()

for _, e in pairs(Enum.KeyCode:GetEnumItems()) do
	combinedInputEnums[#combinedInputEnums + 1] = e
end

local userInputType = {
	Transform = function (text)
		local findEnum = Util.MakeFuzzyFinder(combinedInputEnums)

		return findEnum(text)
	end;

	Validate = function (enums)
		return #enums > 0
	end;

	Autocomplete = function (enums)
		return Util.GetNames(enums)
	end;

	Parse = function (enums)
		return enums[1];
	end;
}

return function (cmdr)
	cmdr:RegisterType("userInput", userInputType)
	cmdr:RegisterType("userInputs", Util.MakeListableType(userInputType))
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="83">
              <Properties>
                <string name="Name">Vector</string>
                <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local function validateVector(value, i)
	if value == nil then
		return false, ("Invalid or missing number at position %d in Vector type."):format(i)
	end

	return true
end

local vector3Type = Util.MakeSequenceType({
	ValidateEach = validateVector;
	TransformEach = tonumber;
	Constructor = Vector3.new;
	Length = 3;
})

local vector2Type = Util.MakeSequenceType({
	ValidateEach = validateVector;
	TransformEach = tonumber;
	Constructor = Vector2.new;
	Length = 2;
})

return function (cmdr)
	cmdr:RegisterType("vector3", vector3Type)
	cmdr:RegisterType("vector3s", Util.MakeListableType(vector3Type))

	cmdr:RegisterType("vector2", vector2Type)
	cmdr:RegisterType("vector2s", Util.MakeListableType(vector2Type))
end</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="84">
            <Properties>
              <string name="Name">CmdrClient</string>
              <string name="Source">local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Shared = script:WaitForChild("Shared")
local Util = require(Shared:WaitForChild("Util"))

if RunService:IsClient() == false then
	error("Server scripts cannot require the client library. Please require the server library to use Cmdr in your own code.")
end

local Cmdr do
	Cmdr = setmetatable({
		ReplicatedRoot = script;
		RemoteFunction = script:WaitForChild("CmdrFunction");
		RemoteEvent = script:WaitForChild("CmdrEvent");
		ActivationKeys = {[Enum.KeyCode.Semicolon] = true};
		Enabled = true;
		MashToEnable = false;
		ActivationUnlocksMouse = false;
		PlaceName = "Cmdr";
		Util = Util;
		Events = {};
	}, {
		-- This sucks, and may be redone or removed
		-- Proxies dispatch methods on to main Cmdr object
		__index = function (self, k)
			local r = self.Dispatcher[k]
			if r and type(r) == "function" then
				return function (_, ...)
					return r(self.Dispatcher, ...)
				end
			end
		end
	})

	Cmdr.Registry = require(Shared.Registry)(Cmdr)
	Cmdr.Dispatcher = require(Shared.Dispatcher)(Cmdr)
end

if StarterGui:WaitForChild("Cmdr") and wait() and Player:WaitForChild("PlayerGui"):FindFirstChild("Cmdr") == nil then
	StarterGui.Cmdr:Clone().Parent = Player.PlayerGui
end

local Interface = require(script.CmdrInterface)(Cmdr)

--- Sets a list of keyboard keys (Enum.KeyCode) that can be used to open the commands menu
function Cmdr:SetActivationKeys (keysArray)
	self.ActivationKeys = Util.MakeDictionary(keysArray)
end

--- Sets the place name label on the interface
function Cmdr:SetPlaceName (name)
	self.PlaceName = name
	Interface.Window:UpdateLabel()
end

--- Sets whether or not the console is enabled
function Cmdr:SetEnabled (enabled)
	self.Enabled = enabled
end

--- Sets if activation will free the mouse.
function Cmdr:SetActivationUnlocksMouse (enabled)
	self.ActivationUnlocksMouse = enabled
end

--- Shows Cmdr window
function Cmdr:Show ()
	if not self.Enabled then
		return
	end

	Interface.Window:Show()
end

--- Hides Cmdr window
function Cmdr:Hide ()
	Interface.Window:Hide()
end

--- Toggles Cmdr window
function Cmdr:Toggle ()
	if not self.Enabled then
		return self:Hide()
	end

	Interface.Window:SetVisible(not Interface.Window:IsVisible())
end

--- Enables the "Mash to open" feature
function Cmdr:SetMashToEnable(isEnabled)
	self.MashToEnable = isEnabled

	if isEnabled then
		self:SetEnabled(false)
	end
end

--- Sets the handler for a certain event type
function Cmdr:HandleEvent(name, callback)
	self.Events[name] = callback
end

-- Only register when we aren't in studio because don't want to overwrite what the server portion did
if RunService:IsServer() == false then
	Cmdr.Registry:RegisterTypesIn(script:WaitForChild("Types"))
	Cmdr.Registry:RegisterCommandsIn(script:WaitForChild("Commands"))
end

-- Hook up event listener
Cmdr.RemoteEvent.OnClientEvent:Connect(function(name, ...)
	if Cmdr.Events[name] then
		Cmdr.Events[name](...)
	end
end)

require(script.DefaultEventHandlers)(Cmdr)

return Cmdr</string>
            </Properties>
            <Item class="ModuleScript" referent="85">
              <Properties>
                <string name="Name">CmdrInterface</string>
                <string name="Source"><![CDATA[-- Here be dragons

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

return function (Cmdr)
	local Util = Cmdr.Util

	local Window = require(script:WaitForChild("Window"))
	Window.Cmdr = Cmdr

	local AutoComplete = require(script:WaitForChild("AutoComplete"))(Cmdr)
	Window.AutoComplete = AutoComplete


	-- Sets the Window.ProcessEntry callback so that we can dispatch our commands out
	function Window.ProcessEntry(text)
		text = Util.TrimString(text)

		if #text == 0 then return end

		Window:AddLine(Window:GetLabel() .. " " .. text, Color3.fromRGB(255, 223, 93))

		Window:AddLine(Cmdr.Dispatcher:EvaluateAndRun(text, Player, {
			IsHuman = true
		}))
	end

	-- Sets the Window.OnTextChanged callback so we can update the auto complete
	function Window.OnTextChanged (text)
		local command = Cmdr.Dispatcher:Evaluate(text, Player, true)
		local arguments = Util.SplitString(text)
		local commandText = table.remove(arguments, 1)
		local atEnd = false
		if command then
			arguments = Util.MashExcessArguments(arguments, #command.Object.Args)

			atEnd = #arguments == #command.Object.Args
		end

		local entryComplete = commandText and #arguments > 0

		if text:sub(#text, #text):match("%s") and not atEnd then
			entryComplete = true
			arguments[#arguments + 1] = ""
		end

		if command and entryComplete then
			local commandValid, errorText = command:Validate()

			Window:SetIsValidInput(commandValid, ("Validation errors: %s"):format(errorText or ""))

			local acItems = {}

			local lastArgument = command:GetArgument(#arguments)
			if lastArgument then
				local typedText = lastArgument.RawSegments[#lastArgument.RawSegments]
				local items = lastArgument:GetAutocomplete()
				for i, item in pairs(items) do
					acItems[i] = {typedText, item}
				end

				local valid = true

				if #typedText > 0 then
					valid, errorText = lastArgument:Validate()
				end

				return AutoComplete:Show(acItems, {
					at = atEnd and #text - #typedText + (text:sub(#text, #text):match("%s") and -1 or 0);
					prefix = #lastArgument.RawSegments == 1 and lastArgument.Prefix or "";
					isLast = #command.Arguments == #command.ArgumentDefinitions and #typedText > 0;
					numArgs = #arguments;
					command = command;
					arg = lastArgument;
					name = lastArgument.Name .. (lastArgument.Required and "" or "?");
					type = lastArgument.Type.DisplayName;
					description = (valid == false and errorText) or lastArgument.Object.Description;
					invalid = not valid;
				})
			end
		elseif commandText and #arguments == 0 then
			Window:SetIsValidInput(true)
			local exactCommand = Cmdr.Registry:GetCommand(commandText)
			local exactMatch
			if exactCommand then
				exactMatch = {exactCommand.Name, exactCommand.Name, options = {
					name = exactCommand.Name;
					description = exactCommand.Description;
				}}
			end

			local acItems = {exactMatch}
			for _, cmd in pairs(Cmdr.Registry:GetCommandsAsStrings()) do
				if commandText:lower() == cmd:lower():sub(1, #commandText) and (exactMatch == nil or exactMatch[1] ~= commandText) then
					local commandObject = Cmdr.Registry:GetCommand(cmd)
					acItems[#acItems + 1] = {commandText, cmd, options = {
						name = commandObject.Name;
						description = commandObject.Description;
					}}
				end
			end

			return AutoComplete:Show(acItems)
		end

		Window:SetIsValidInput(false, "Invalid command. Use the help command to see all available commands.")
		AutoComplete:Hide()
	end

	Window:UpdateLabel()
	Window:UpdateWindowHeight()

	return {
		Window = Window;
		AutoComplete = AutoComplete;
	}
end
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="86">
                <Properties>
                  <string name="Name">AutoComplete</string>
                  <string name="Source"><![CDATA[-- luacheck: ignore 212
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

return function (Cmdr)
	local AutoComplete = {
		Items = {};
		ItemOptions = {};
		SelectedItem = 0;
	}

	local Util = Cmdr.Util
	local Shorthands = Util.MakeDictionary({"me", "all", ".", "*", "others"})

	local Gui = Player:WaitForChild("PlayerGui"):WaitForChild("Cmdr"):WaitForChild("Autocomplete")
	local AutoItem = Gui:WaitForChild("TextButton")
	local Title = Gui:WaitForChild("Title")
	local Description = Gui:WaitForChild("Description")
	local Entry = Gui.Parent:WaitForChild("Frame"):WaitForChild("Entry")
	AutoItem.Parent = nil

	-- Helper function that sets text and resizes labels
	local function SetText(obj, textObj, text, sizeFromContents)
		obj.Visible = text ~= nil
		textObj.Text = text or ""

		if sizeFromContents then
			textObj.Size = UDim2.new(0, Util.GetTextSize(text or "", textObj, Vector2.new(1000, 1000), 1, 0).X, obj.Size.Y.Scale, obj.Size.Y.Offset)
		end
	end

	-- Update the info display (Name, type, and description) based on given options.
	local function UpdateInfoDisplay (options)
		-- Update the objects' text and sizes
		SetText(Title, Title.Field, options.name, true)
		SetText(Title.Field.Type, Title.Field.Type, options.type and ": " .. options.type:sub(1, 1):upper() .. options.type:sub(2))
		SetText(Description, Description.Label, options.description)

		Description.Label.TextColor3 = options.invalid and Color3.fromRGB(255, 73, 73) or Color3.fromRGB(255, 255, 255)

		-- Calculate needed width and height
		local infoWidth = Title.Field.TextBounds.X + Title.Field.Type.TextBounds.X

		local guiWidth = math.max(infoWidth, Gui.Size.X.Offset)
		Description.Size = UDim2.new(1, 0, 0, 40)

		-- Flow description text
		while not Description.Label.TextFits do
			Description.Size = Description.Size + UDim2.new(0, 0, 0, 2)

			if Description.Size.Y.Offset > 500 then
				break
			end
		end

		-- Update container
		wait()
		Gui.UIListLayout:ApplyLayout()
		Gui.Size = UDim2.new(0, guiWidth, 0, Gui.UIListLayout.AbsoluteContentSize.Y)
	end

	--- Shows the auto complete menu with the given list and possible options
	-- item = {typedText, suggestedText, options?=options}
	-- The options table is optional. `at` should only be passed into AutoComplete::Show
	-- name, type, and description may be passed in an options dictionary inside the items as well
	-- options.at?: the character index at which to show the menu
	-- options.name?: The name to display in the info box
	-- options.type?: The type to display in the info box
	-- options.prefix?: The current type prefix (%Team)
	-- options.description?: The description for the currently active info box
	-- options.invalid?: If true, description is shown in red.
	-- options.isLast?: If true, auto complete won't keep going after this argument.
	function AutoComplete:Show (items, options)
		options = options or {}

		-- Remove old options.
		for _, item in pairs(self.Items) do
			if item.gui then
				item.gui:Destroy()
			end
		end

		-- Reset state
		self.SelectedItem = 1
		self.Items = items
		self.Prefix = options.prefix or ""
		self.LastItem = options.isLast or false
		self.Command = options.command
		self.Arg = options.arg
		self.NumArgs = options.numArgs

		-- Generate the new option labels
		local autocompleteWidth = 200

		for i, item in pairs(self.Items) do
			local leftText = item[1]
			local rightText = item[2]

			if Shorthands[leftText] then
				leftText = rightText
			end

			local btn = AutoItem:Clone()
			btn.Name = leftText .. rightText
			btn.BackgroundTransparency = i == self.SelectedItem and 0.5 or 1
			btn.Typed.Text = leftText
			btn.Suggest.Text = string.rep(" ", #leftText) .. rightText:sub(#leftText + 1)
			btn.Parent = Gui
			btn.LayoutOrder = i

			local maxBounds = math.max(btn.Typed.TextBounds.X, btn.Suggest.TextBounds.X) + 20
			if maxBounds > autocompleteWidth then
				autocompleteWidth = maxBounds
			end

			item.gui = btn
		end

		Gui.UIListLayout:ApplyLayout()

		-- Todo: Use TextService to find accurate position for auto complete box
		local text = Entry.TextBox.Text
		local words = Util.SplitString(text)
		if text:sub(#text, #text) == " " and not options.at then
			words[#words+1] = "e"
		end
		table.remove(words, #words)
		local extra = (options.at and options.at or (#table.concat(words, " ") + 1)) * 7

		-- Update the auto complete container
		Gui.Position = UDim2.new(0, Entry.TextBox.AbsolutePosition.X - 10 + extra, 0, Entry.TextBox.AbsolutePosition.Y + 30)
		Gui.Size = UDim2.new(0, autocompleteWidth, 0, Gui.UIListLayout.AbsoluteContentSize.Y)
		Gui.Visible = true

		-- Finally, update thge info display
		UpdateInfoDisplay(self.Items[1] and self.Items[1].options or options)
	end

	--- Returns the selected item in the auto complete
	function AutoComplete:GetSelectedItem ()
		if Gui.Visible == false then
			return nil
		end

		return AutoComplete.Items[AutoComplete.SelectedItem]
	end

	--- Hides the auto complete
	function AutoComplete:Hide ()
		Gui.Visible = false
	end

	--- Returns if the menu is visible
	function AutoComplete:IsVisible ()
		return Gui.Visible
	end

	--- Changes the user's item selection by the given delta
	function AutoComplete:Select (delta)
		if not Gui.Visible then return end

		self.SelectedItem = self.SelectedItem + delta

		if self.SelectedItem > #self.Items then
			self.SelectedItem = 1
		elseif self.SelectedItem < 1 then
			self.SelectedItem = #self.Items
		end

		for i, item in pairs(self.Items) do
			item.gui.BackgroundTransparency = i == self.SelectedItem and 0.5 or 1
		end

		if self.Items[self.SelectedItem] and self.Items[self.SelectedItem].options then
			UpdateInfoDisplay(self.Items[self.SelectedItem].options or {})
		end
	end

	return AutoComplete
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="87">
                <Properties>
                  <string name="Name">Window</string>
                  <string name="Source"><![CDATA[-- Here be dragons
-- luacheck: ignore 212
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local LINE_HEIGHT = 20
local WINDOW_MAX_HEIGHT = 300

--- Window handles the command bar GUI
local Window = {
	Valid = true,
	AutoComplete = nil,
	ProcessEntry = nil,
	OnTextChanged = nil,
	Cmdr = nil,
	HistoryState = nil,
}

local Gui = Player:WaitForChild("PlayerGui"):WaitForChild("Cmdr"):WaitForChild("Frame")
local Line = Gui:WaitForChild("Line")
local Entry = Gui:WaitForChild("Entry")

Line.Parent = nil

--- Update the text entry label
function Window:UpdateLabel()
	Entry.TextLabel.Text = Player.Name .. "@" .. self.Cmdr.PlaceName .. "$"
	Entry.TextLabel.Size = UDim2.new(0, Entry.TextLabel.TextBounds.X, 0, 20)
	Entry.TextBox.Position = UDim2.new(0, Entry.TextLabel.Size.X.Offset + 7, 0, 0)
end

--- Get the text entry label
function Window:GetLabel()
	return Entry.TextLabel.Text
end

--- Recalculate the window height
function Window:UpdateWindowHeight()
	local windowHeight = LINE_HEIGHT

	for _, child in pairs(Gui:GetChildren()) do
		if child:IsA("GuiObject") then
			windowHeight = windowHeight + child.Size.Y.Offset
		end
	end

	Gui.CanvasSize = UDim2.new(Gui.CanvasSize.X.Scale, Gui.CanvasSize.X.Offset, 0, windowHeight)
	Gui.Size =
		UDim2.new(
		Gui.Size.X.Scale,
		Gui.Size.X.Offset,
		0,
		windowHeight > WINDOW_MAX_HEIGHT and WINDOW_MAX_HEIGHT or windowHeight
	)

	Gui.CanvasPosition = Vector2.new(0, math.clamp(windowHeight - 300, 0, math.huge))
end

--- Add a line to the command bar
function Window:AddLine(text, color)
	if #text == 0 then
		Window:UpdateWindowHeight()
		return
	end

	local str = self.Cmdr.Util.EmulateTabstops(text or "nil", 8)
	local line = Line:Clone()
	line.Size =
		UDim2.new(
		line.Size.X.Scale,
		line.Size.X.Offset,
		0,
		TextService:GetTextSize(
			str,
			line.TextSize,
			line.Font,
			Vector2.new(Gui.UIListLayout.AbsoluteContentSize.X, math.huge)
		).Y + (LINE_HEIGHT - line.TextSize)
	)
	line.Text = str
	line.TextColor3 = color or line.TextColor3
	line.Parent = Gui
end

--- Returns if the command bar is visible
function Window:IsVisible()
	return Gui.Visible
end

--- Sets the command bar visible or not
function Window:SetVisible(visible)
	Gui.Visible = visible

	if visible then
		Entry.TextBox:CaptureFocus()
		self:SetEntryText("")

		if self.Cmdr.ActivationUnlocksMouse then
			self.PreviousMouseBehavior = UserInputService.MouseBehavior
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	else
		Entry.TextBox:ReleaseFocus()
		self.AutoComplete:Hide()

		if self.PreviousMouseBehavior then
			UserInputService.MouseBehavior = self.PreviousMouseBehavior
			self.PreviousMouseBehavior = nil
		end
	end
end

--- Hides the command bar
function Window:Hide()
	return self:SetVisible(false)
end

--- Shows the command bar
function Window:Show()
	return self:SetVisible(true)
end

--- Sets the text in the command bar text box, and captures focus
function Window:SetEntryText(text)
	Entry.TextBox.Text = text

	if self:IsVisible() then
		Entry.TextBox:CaptureFocus()
	end
end

--- Gets the text in the command bar text box
function Window:GetEntryText()
	return Entry.TextBox.Text:gsub("\t", "")
end

--- Sets whether the command is in a valid state or not.
-- Cannot submit if in invalid state.
function Window:SetIsValidInput(isValid, errorText)
	Entry.TextBox.TextColor3 = isValid and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 73, 73)
	self.Valid = isValid
	self._errorText = errorText
end

--- Event handler for text box focus lost
function Window:LoseFocus(submit)
	local text = Entry.TextBox.Text

	self:ClearHistoryState()

	if Gui.Visible and not GuiService.MenuIsOpen then
		-- self:SetEntryText("")
		Entry.TextBox:CaptureFocus()
	elseif GuiService.MenuIsOpen and Gui.Visible then
		self:Hide()
	end

	if submit and self.Valid then
		wait()
		self:SetEntryText("")
		self.ProcessEntry(text)
	elseif submit then
		self:AddLine(self._errorText, Color3.fromRGB(255, 153, 153))
	end
end

function Window:TraverseHistory(delta)
	local history = self.Cmdr.Dispatcher:GetHistory()

	if self.HistoryState == nil then
		self.HistoryState = {
			Position = #history + 1;
			InitialText = self:GetEntryText();
		}
	end

	self.HistoryState.Position = math.clamp(self.HistoryState.Position + delta, 1, #history + 1)

	self:SetEntryText(
		self.HistoryState.Position == #history + 1
			and self.HistoryState.InitialText
			or history[self.HistoryState.Position]
	)
end

function Window:ClearHistoryState()
	self.HistoryState = nil
end

function Window:SelectVertical(delta)
	if self.AutoComplete:IsVisible() and not self.HistoryState then
		self.AutoComplete:Select(delta)
	else
		self:TraverseHistory(delta)
	end
end

local lastPressTime = 0
local pressCount = 0
--- Handles user input when the box is focused
function Window:BeginInput(input, gameProcessed)
	if GuiService.MenuIsOpen then
		self:Hide()
	end

	if gameProcessed and self:IsVisible() == false then
		return
	end

	if self.Cmdr.ActivationKeys[input.KeyCode] then -- Activate the command bar
		if self.Cmdr.MashToEnable and not self.Cmdr.Enabled then
			if tick() - lastPressTime < 1 then
				if pressCount >= 5 then
					return self.Cmdr:SetEnabled(true)
				else
					pressCount = pressCount + 1
				end
			else
				pressCount = 1
			end
			lastPressTime = tick()
		elseif self.Cmdr.Enabled then
			self:SetVisible(not self:IsVisible())
			wait()
			self:SetEntryText("")

			if GuiService.MenuIsOpen then -- Special case for menu getting stuck open (roblox bug)
				self:Hide()
			end
		end

		return
	end

	if self.Cmdr.Enabled == false or not self:IsVisible() then
		if self:IsVisible() then
			self:Hide()
		end

		return
	end

	if input.KeyCode == Enum.KeyCode.Down then -- Auto Complete Down
		self:SelectVertical(1)
	elseif input.KeyCode == Enum.KeyCode.Up then -- Auto Complete Up
		self:SelectVertical(-1)
	elseif input.KeyCode == Enum.KeyCode.Return then -- Eat new lines
		wait()
		self:SetEntryText(self:GetEntryText():gsub("\n", ""):gsub("\r", ""))
	elseif input.KeyCode == Enum.KeyCode.Tab then -- Auto complete
		local item = self.AutoComplete:GetSelectedItem()
		local text = self:GetEntryText()
		if item and not (text:sub(#text, #text):match("%s") and self.AutoComplete.LastItem) then
			local replace = item[2]
			local newText
			local insertSpace = true
			local command = self.AutoComplete.Command

			if command then
				local lastArg = self.AutoComplete.Arg

				newText = command.Alias
				insertSpace = self.AutoComplete.NumArgs ~= #command.ArgumentDefinitions

				local args = command.Arguments
				for i = 1, #args do
					local arg = args[i]
					local segments = arg.RawSegments
					if arg == lastArg then
						segments[#segments] = replace
					end

					local argText = arg.Prefix .. table.concat(segments, ",")

					-- Put auto completion options in quotation marks if they have a space
					if argText:find(" ") then
						argText = ("%q"):format(argText)
					end

					newText = ("%s %s"):format(newText, argText)

					if arg == lastArg then
						break
					end
				end
			else
				newText = replace
			end
			-- need to wait a frame so we can eat the \t
			wait()
			-- Update the text box
			self:SetEntryText(newText .. (insertSpace and " " or ""))
		else
			-- Still need to eat the \t even if there is no auto-complete to show
			wait()
			self:SetEntryText(self:GetEntryText())
		end
	else
		self:ClearHistoryState()
	end
end

-- Hook events
Entry.TextBox.FocusLost:Connect(
	function(submit)
		return Window:LoseFocus(submit)
	end
)

UserInputService.InputBegan:Connect(
	function(input, gameProcessed)
		return Window:BeginInput(input, gameProcessed)
	end
)

Entry.TextBox:GetPropertyChangedSignal("Text"):Connect(
	function()
		if Entry.TextBox.Text:match("\t") then -- Eat \t
			Entry.TextBox.Text = Entry.TextBox.Text:gsub("\t", "")
			return
		end
		if Window.OnTextChanged then
			return Window.OnTextChanged(Entry.TextBox.Text)
		end
	end
)

Gui.ChildAdded:Connect(Window.UpdateWindowHeight)

return Window
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="88">
              <Properties>
                <string name="Name">DefaultEventHandlers</string>
                <string name="Source">local StarterGui = game:GetService("StarterGui")
local Window = require(script.Parent.CmdrInterface.Window)

return function (Cmdr)
	Cmdr:HandleEvent("Message", function (text)
		StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = ("[Announcement] %s"):format(text);
			Color = Color3.fromRGB(249, 217, 56);
		})
	end)

	Cmdr:HandleEvent("AddLine", function (...)
		Window:AddLine(...)
	end)
end</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="89">
            <Properties>
              <string name="Name">CreateGui</string>
              <string name="Source">--[[
	DO NOT MODIFY. This file is auto-generated.
	Plugin: https://www.roblox.com/library/2307140444/Object-to-Lua
]]

return function ()
	local Cmdr = Instance.new("ScreenGui")
	Cmdr.DisplayOrder = 1000
	Cmdr.Name = "Cmdr"
	Cmdr.ResetOnSpawn = false
	Cmdr.AutoLocalize = false

	local Frame = Instance.new("ScrollingFrame")
	Frame.BackgroundColor3 = Color3.fromRGB(17, 17, 17)
	Frame.BackgroundTransparency = 0.4
	Frame.BorderSizePixel = 0
	Frame.CanvasSize = UDim2.new(0, 0, 0, 100)
	Frame.Name = "Frame"
	Frame.Position = UDim2.new(0.025, 0, 0, 25)
	Frame.ScrollBarThickness = 6
	Frame.ScrollingDirection = Enum.ScrollingDirection.Y
	Frame.Selectable = false
	Frame.Size = UDim2.new(0.95, 0, 0, 50)
	Frame.Visible = false
	Frame.Parent = Cmdr

	local Autocomplete = Instance.new("Frame")
	Autocomplete.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Autocomplete.BackgroundTransparency = 0.5
	Autocomplete.BorderSizePixel = 0
	Autocomplete.Name = "Autocomplete"
	Autocomplete.Position = UDim2.new(0, 167, 0, 75)
	Autocomplete.Size = UDim2.new(0, 200, 0, 200)
	Autocomplete.Visible = false
	Autocomplete.Parent = Cmdr

	local UIListLayout = Instance.new("UIListLayout")
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.Parent = Frame

	local Line = Instance.new("TextLabel")
	Line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Line.BackgroundTransparency = 1
	Line.Font = Enum.Font.Code
	Line.Name = "Line"
	Line.Size = UDim2.new(1, 0, 0, 20)
	Line.TextColor3 = Color3.fromRGB(255, 255, 255)
	Line.TextSize = 14
	Line.TextXAlignment = Enum.TextXAlignment.Left
	Line.Parent = Frame

	local UIPadding = Instance.new("UIPadding")
	UIPadding.PaddingBottom = UDim.new(0, 10)
	UIPadding.PaddingLeft = UDim.new(0, 10)
	UIPadding.PaddingRight = UDim.new(0, 10)
	UIPadding.PaddingTop = UDim.new(0, 10)
	UIPadding.Parent = Frame

	local Entry = Instance.new("Frame")
	Entry.BackgroundTransparency = 1
	Entry.LayoutOrder = 999999999
	Entry.Name = "Entry"
	Entry.Size = UDim2.new(1, 0, 0, 20)
	Entry.Parent = Frame

	local UIListLayout2 = Instance.new("UIListLayout")
	UIListLayout2.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout2.Parent = Autocomplete

	local Title = Instance.new("Frame")
	Title.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Title.BackgroundTransparency = 0.2
	Title.BorderSizePixel = 0
	Title.LayoutOrder = -2
	Title.Name = "Title"
	Title.Size = UDim2.new(1, 0, 0, 40)
	Title.Parent = Autocomplete

	local Description = Instance.new("Frame")
	Description.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Description.BackgroundTransparency = 0.2
	Description.BorderSizePixel = 0
	Description.LayoutOrder = -1
	Description.Name = "Description"
	Description.Size = UDim2.new(1, 0, 0, 20)
	Description.Parent = Autocomplete

	local TextButton = Instance.new("TextButton")
	TextButton.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	TextButton.BackgroundTransparency = 0.5
	TextButton.BorderSizePixel = 0
	TextButton.Font = Enum.Font.Code
	TextButton.Size = UDim2.new(1, 0, 0, 30)
	TextButton.Text = ""
	TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextButton.TextSize = 14
	TextButton.TextXAlignment = Enum.TextXAlignment.Left
	TextButton.Parent = Autocomplete

	local TextBox = Instance.new("TextBox")
	TextBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextBox.BackgroundTransparency = 1
	TextBox.ClearTextOnFocus = false
	TextBox.Font = Enum.Font.Code
	TextBox.LayoutOrder = 999999999
	TextBox.Position = UDim2.new(0, 140, 0, 0)
	TextBox.Size = UDim2.new(1, 0, 0, 20)
	TextBox.Text = "x"
	TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextBox.TextSize = 14
	TextBox.TextXAlignment = Enum.TextXAlignment.Left
	TextBox.Parent = Entry

	local TextLabel = Instance.new("TextLabel")
	TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.BackgroundTransparency = 1
	TextLabel.Font = Enum.Font.Code
	TextLabel.Size = UDim2.new(0, 133, 0, 20)
	TextLabel.Text = ""
	TextLabel.TextColor3 = Color3.fromRGB(255, 223, 93)
	TextLabel.TextSize = 14
	TextLabel.TextXAlignment = Enum.TextXAlignment.Left
	TextLabel.Parent = Entry

	local Field = Instance.new("TextLabel")
	Field.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Field.BackgroundTransparency = 1
	Field.Font = Enum.Font.SourceSansBold
	Field.Name = "Field"
	Field.Size = UDim2.new(0, 37, 1, 0)
	Field.Text = "from"
	Field.TextColor3 = Color3.fromRGB(255, 255, 255)
	Field.TextSize = 20
	Field.TextXAlignment = Enum.TextXAlignment.Left
	Field.Parent = Title

	local UIPadding2 = Instance.new("UIPadding")
	UIPadding2.PaddingLeft = UDim.new(0, 10)
	UIPadding2.Parent = Title

	local Label = Instance.new("TextLabel")
	Label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Label.BackgroundTransparency = 1
	Label.Font = Enum.Font.SourceSansLight
	Label.Name = "Label"
	Label.Size = UDim2.new(1, 0, 1, 0)
	Label.Text = "The players to teleport. The players to teleport. The players to teleport. The players to teleport. "
	Label.TextColor3 = Color3.fromRGB(255, 255, 255)
	Label.TextSize = 16
	Label.TextWrapped = true
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.TextYAlignment = Enum.TextYAlignment.Top
	Label.Parent = Description

	local UIPadding3 = Instance.new("UIPadding")
	UIPadding3.PaddingBottom = UDim.new(0, 10)
	UIPadding3.PaddingLeft = UDim.new(0, 10)
	UIPadding3.PaddingRight = UDim.new(0, 10)
	UIPadding3.Parent = Description

	local Typed = Instance.new("TextLabel")
	Typed.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Typed.BackgroundTransparency = 1
	Typed.Font = Enum.Font.Code
	Typed.Name = "Typed"
	Typed.Size = UDim2.new(1, 0, 1, 0)
	Typed.Text = "Lab"
	Typed.TextColor3 = Color3.fromRGB(131, 222, 255)
	Typed.TextSize = 14
	Typed.TextXAlignment = Enum.TextXAlignment.Left
	Typed.Parent = TextButton

	local UIPadding4 = Instance.new("UIPadding")
	UIPadding4.PaddingLeft = UDim.new(0, 10)
	UIPadding4.Parent = TextButton

	local Suggest = Instance.new("TextLabel")
	Suggest.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Suggest.BackgroundTransparency = 1
	Suggest.Font = Enum.Font.Code
	Suggest.Name = "Suggest"
	Suggest.Size = UDim2.new(1, 0, 1, 0)
	Suggest.Text = "   el"
	Suggest.TextColor3 = Color3.fromRGB(255, 255, 255)
	Suggest.TextSize = 14
	Suggest.TextXAlignment = Enum.TextXAlignment.Left
	Suggest.Parent = TextButton

	local Type = Instance.new("TextLabel")
	Type.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Type.BackgroundTransparency = 1
	Type.BorderColor3 = Color3.fromRGB(255, 153, 153)
	Type.Font = Enum.Font.SourceSans
	Type.Name = "Type"
	Type.Position = UDim2.new(1, 0, 0, 0)
	Type.Size = UDim2.new(0, 0, 1, 0)
	Type.Text = ": Players"
	Type.TextColor3 = Color3.fromRGB(255, 255, 255)
	Type.TextSize = 15
	Type.TextXAlignment = Enum.TextXAlignment.Left
	Type.Parent = Field

	Cmdr.Parent = game:GetService("StarterGui")
	return Cmdr
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="90">
            <Properties>
              <string name="Name">Initialize</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local CreateGui = require(script.Parent.CreateGui)

--- Handles initial preparation of the game server-side.
return function (cmdr)
	local ReplicatedRoot, RemoteFunction, RemoteEvent

	local function Create (class, name, parent)
		local object = Instance.new(class)
		object.Name = name
		object.Parent = parent or ReplicatedRoot

		return object
	end

	ReplicatedRoot = script.Parent.CmdrClient

	if ReplicatedStorage:FindFirstChild("Resources") and
		ReplicatedStorage.Resources:FindFirstChild("Libraries") then -- If using RoStrap
		-- ReplicatedRoot.Name = "Cmdr"
		ReplicatedRoot.Parent = ReplicatedStorage.Resources.Libraries
	else
		ReplicatedRoot.Parent = ReplicatedStorage
	end

	RemoteFunction = Create("RemoteFunction", "CmdrFunction")
	RemoteEvent = Create("RemoteEvent", "CmdrEvent")

	Create("Folder", "Commands")
	Create("Folder", "Types")

	script.Parent.Shared.Parent = ReplicatedRoot

	cmdr.ReplicatedRoot = ReplicatedRoot
	cmdr.RemoteFunction = RemoteFunction
	cmdr.RemoteEvent = RemoteEvent

	cmdr:RegisterTypesIn(script.Parent.BuiltInTypes)

	script.Parent.BuiltInTypes:Destroy()
	script.Parent.BuiltInCommands.Name = "Server commands"

	if StarterGui:FindFirstChild("Cmdr") == nil then
		CreateGui()
	end
end
]]></string>
            </Properties>
          </Item>
          <Item class="Folder" referent="91">
            <Properties>
              <string name="Name">Shared</string>
            </Properties>
            <Item class="ModuleScript" referent="92">
              <Properties>
                <string name="Name">Argument</string>
                <string name="Source">local Util = require(script.Parent.Util)

local Argument = {}
Argument.__index = Argument

--- Returns a new ArgumentContext, an object that handles parsing and validating arguments
function Argument.new (command, argumentObject, value)
	local self = {
		Command = command; -- The command that owns this argument
		Type = nil; -- The type definition
		Name = argumentObject.Name; -- The name for this specific argument
		Object = argumentObject; -- The raw ArgumentObject (definition)
		Required = argumentObject.Default == nil and argumentObject.Optional ~= true; -- If the argument is required or not.
		Executor = command.Executor; -- The player who is running the command
		RawValue = nil; -- The raw, unparsed value
		RawSegments = {}; -- The raw, unparsed segments (if the raw value was comma-sep)
		TransformedValues = {}; -- The transformed value (generated later)
		Prefix = nil; -- The prefix for this command (%Team)
	}

	local parsedType, parsedRawValue, prefix = Util.ParsePrefixedUnionType(
		command.Cmdr.Registry:GetTypeName(argumentObject.Type),
		value
	)

	self.Type = command.Dispatcher.Registry:GetType(parsedType)
	self.RawValue = parsedRawValue
	self.Prefix = prefix

	if self.Type == nil then
		error(string.format("%s has an unregistered type %q", self.Name or "&lt;none>", parsedType or "&lt;none>"))
	end

	setmetatable(self, Argument)

	self:Transform()

	return self
end

--- Calls the transform function on this argument.
-- The return value(s) from this function are passed to all of the other argument methods.
-- Called automatically at instantiation
function Argument:Transform()
	if #self.TransformedValues ~= 0 then
		return
	end

	if self.Type.Listable and #self.RawValue > 0 then
		local rawSegments = Util.SplitStringSimple(self.RawValue, ",")

		if self.RawValue:sub(#self.RawValue, #self.RawValue) == "," then
			rawSegments[#rawSegments + 1] = "" -- makes auto complete tick over right after pressing ,
		end

		for i, rawSegment in ipairs(rawSegments) do
			self.RawSegments[i] = rawSegment
			self.TransformedValues[i] = { self:TransformSegment(rawSegment) }
		end
	else
		self.RawSegments[1] = self.RawValue
		self.TransformedValues[1] = { self:TransformSegment(self.RawValue) }
	end
end

function Argument:TransformSegment(rawSegment)
	if self.Type.Transform then
		return self.Type.Transform(rawSegment, self.Executor)
	else
		return rawSegment
	end
end

--- Returns whatever the Transform method gave us.
function Argument:GetTransformedValue(segment)
	return unpack(self.TransformedValues[segment])
end

--- Validates that the argument will work without any type errors.
function Argument:Validate(isFinal)
	if self.RawValue == nil or #self.RawValue == 0 and self.Required == false then
		return true
	end

	if self.Type.Validate or self.Type.ValidateOnce then
		for i = 1, #self.TransformedValues do
			if self.Type.Validate then
				local valid, errorText = self.Type.Validate(self:GetTransformedValue(i))

				if not valid then
					return valid, errorText or "Invalid value"
				end
			end

			if isFinal and self.Type.ValidateOnce then
				local validOnce, errorTextOnce = self.Type.ValidateOnce(self:GetTransformedValue(i))

				if not validOnce then
					return validOnce, errorTextOnce
				end
			end
		end

		return true
	else
		return true
	end
end

--- Gets a list of all possible values that could match based on the current value.
function Argument:GetAutocomplete()
	if self.Type.Autocomplete then
		return self.Type.Autocomplete(self:GetTransformedValue(#self.TransformedValues))
	else
		return {}
	end
end

function Argument:ParseValue(i)
	if self.Type.Parse then
		return self.Type.Parse(self:GetTransformedValue(i))
	else
		return self:GetTransformedValue(i)
	end
end

--- Returns the final value of the argument.
function Argument:GetValue()
	if #self.RawValue == 0 and not self.Required and self.Object.Default ~= nil then
		return self.Object.Default
	end

	if not self.Type.Listable then
		return self:ParseValue(1)
	end

	local values = {}

	for i = 1, #self.TransformedValues do
		local parsedValue = self:ParseValue(i)

		if type(parsedValue) ~= "table" then
			error(("Listable types must return a table from Parse (%s)"):format(self.Type.Name))
		end

		for _, value in pairs(parsedValue) do
			values[value] = true -- Put them into a dictionary to ensure uniqueness
		end
	end

	local valueArray = {}

	for value in pairs(values) do
		valueArray[#valueArray + 1] = value
	end

	return valueArray
end

return Argument</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="93">
              <Properties>
                <string name="Name">Command</string>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Argument = require(script.Parent.Argument)

local IsServer = RunService:IsServer()

local Command = {}
Command.__index = Command

--- Returns a new CommandContext, an object which is created for every command validation.
-- This is also what's passed as the context to the "Run" functions in commands
function Command.new (options)
	local self = {
		Dispatcher = options.Dispatcher; -- The dispatcher that created this command context
		Cmdr = options.Dispatcher.Cmdr; -- A quick reference to Cmdr for command context
		Name = options.CommandObject.Name; -- The command name (not alias)
		RawText = options.Text; -- The raw text used to trigger this command
		Object = options.CommandObject; -- The command object (definition)
		Group = options.CommandObject.Group; -- The group this command is in
		State = {}; -- A table which will hold any custom command state information
		Aliases = options.CommandObject.Aliases;
		Alias = options.Alias; -- The command name that was used
		Description = options.CommandObject.Description;
		Executor = options.Executor; -- The player who ran the command
		ArgumentDefinitions = options.CommandObject.Args; -- The argument definitions from the command definition
		RawArguments = options.Arguments; -- Array of strings which are the unparsed values for the arguments
		Arguments = {}; -- A table which will hold ArgumentContexts for each argument
		Data = options.Data; -- A special container for any additional data the command needs to collect from the client
		Response = nil; -- Will be set at the very end when the command is run and a string is returned from the Run function.
	}

	setmetatable(self, Command)

	return self
end

--- Parses all of the command arguments into ArgumentContexts
-- Called by the command dispatcher automatically
-- allowIncompleteArguments: if true, will not throw an error for missing arguments
function Command:Parse (allowIncompleteArguments)
	local hadOptional = false
	for i, definition in ipairs(self.ArgumentDefinitions) do
		local required = (definition.Default == nil and definition.Optional ~= true)

		if required and hadOptional then
			error(("Command %q: Required arguments cannot occur after optional arguments."):format(self.Name))
		elseif not required then
			hadOptional = true
		end

		if self.RawArguments[i] == nil and required and allowIncompleteArguments ~= true then
			return false, ("Required argument #%d %s is missing."):format(i, definition.Name)
		elseif self.RawArguments[i] or allowIncompleteArguments then
			self.Arguments[i] = Argument.new(self, definition, self.RawArguments[i] or "")
		end
	end

	return true
end

--- Validates that all of the arguments are in a valid state.
-- This must be called before :Run() is called.
-- Returns boolean (true if ok), errorText
function Command:Validate (isFinal)
	self._Validated = true
	local errorText = ""
	local success = true

	for i, arg in pairs(self.Arguments) do
		local argSuccess, argErrorText = arg:Validate(isFinal)

		if not argSuccess then
			success = false
			errorText = ("%s; #%d %s: %s"):format(errorText, i, arg.Name, argErrorText or "error")
		end
	end

	return success, errorText:sub(3)
end

--- Returns the last argument that has a value.
-- Useful for getting the autocomplete for the argument the user is working on.
function Command:GetLastArgument()
	for i = #self.Arguments, 1, -1 do
		if self.Arguments[i].RawValue then
			return self.Arguments[i]
		end
	end
end

--- Returns a table containing the parsed values for all of the arguments.
function Command:GatherArgumentValues ()
	local values = {}

	for i = 1, #self.ArgumentDefinitions do
		local arg = self.Arguments[i]
		if arg then
			values[i] = arg:GetValue()
		else
			values[i] = self.ArgumentDefinitions[i].Default
		end
	end

	return values
end

--- Runs the command. Handles dispatching to the server if necessary.
-- Command:Validate() must be called before this is called or it will throw.
function Command:Run ()
	if self._Validated == nil then
		error("Must validate a command before running.")
	end

	local beforeRunHook = self.Dispatcher:RunHooks("BeforeRun", self)
	if beforeRunHook then
		return beforeRunHook
	end

	if not IsServer and self.Object.Data and self.Data == nil then
		self.Data = self.Object.Data(self, unpack(self:GatherArgumentValues()))
	end

	if not IsServer and self.Object.ClientRun then
		self.Response = self.Object.ClientRun(self, unpack(self:GatherArgumentValues()))
	end

	if self.Response == nil then
		if self.Object.Run then -- We can just Run it here on this machine
			self.Response = self.Object.Run(self, unpack(self:GatherArgumentValues()))

		elseif IsServer then -- Uh oh, we're already on the server and there's no Run function.
			if self.Object.ClientRun then
				warn(self.Name, "command fell back to the server because ClientRun returned nil, but there is no server implementation! Either return a string from ClientRun, or create a server implementation for this command.")
			else
				warn(self.Name, "command has no implementation!")
			end

			self.Response = "No implementation."
		else -- We're on the client, so we send this off to the server to let the server see what it can do with it.
			self.Response = self.Dispatcher:Send(self.RawText, self.Data)
		end
	end

	local afterRunHook = self.Dispatcher:RunHooks("AfterRun", self)
	if afterRunHook then
		return afterRunHook
	else
		return self.Response
	end
end

--- Returns an ArgumentContext for the specific index
function Command:GetArgument (index)
	return self.Arguments[index]
end

-- Below are functions that are only meant to be used in command implementations --

--- Returns the extra data associated with this command.
-- This needs to be used instead of just context.Data for reliability when not using a remote command.
function Command:GetData ()
	if self.Data then
		return self.Data
	end

	if self.Object.Data and not IsServer then
		self.Data = self.Object.Data(self)
	end

	return self.Data
end

--- Sends an event message to a player
function Command:SendEvent(player, event, ...)
	assert(typeof(player) == "Instance", "Argument #1 must be a Player")
	assert(player:IsA("Player"), "Argument #1 must be a Player")
	assert(type(event) == "string", "Argument #2 must be a string")

	if IsServer then
		self.Dispatcher.Cmdr.RemoteEvent:FireClient(player, event, ...)
	elseif self.Dispatcher.Cmdr.Events[event] then
		assert(player == Players.LocalPlayer, "Event messages can only be sent to the local player on the client.")
		self.Dispatcher.Cmdr.Events[event](...)
	end
end

--- Sends an event message to all players
function Command:BroadcastEvent(...)
	if not IsServer then
		error("Can't broadcast event messages from the client.", 2)
	end

	self.Dispatcher.Cmdr.RemoteEvent:FireAllClients(...)
end

--- Alias of self:SendEvent(self.Executor, "AddLine", text)
function Command:Reply(...)
	return self:SendEvent(self.Executor, "AddLine", ...)
end

--- Alias of Registry:GetStore(...)
function Command:GetStore(...)
	return self.Dispatcher.Cmdr.Registry:GetStore(...)
end

return Command
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="94">
              <Properties>
                <string name="Name">Dispatcher</string>
                <string name="Source">local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local Util = require(script.Parent.Util)
local Command = require(script.Parent.Command)

local HISTORY_SETTING_NAME = "CmdrCommandHistory"

--- The dispatcher handles creating and running commands during the game.
local Dispatcher = {
	Cmdr = nil;
	Registry = nil;

}

--- Takes in raw command information and generates a command out of it.
-- text and executor are required arguments.
-- allowIncompleteData, when true, will ignore errors about arguments missing so we can parse live as the user types.
-- data is for special networked Data about the command gathered on the client. Purely Optional.
-- returns the command if successful, or (false, errorText) if not
function Dispatcher:Evaluate (text, executor, allowIncompleteArguments, data)
	if RunService:IsClient() == true and executor ~= Players.LocalPlayer then
		error("Can't evaluate a command that isn't sent by the local player.")
	end

	local arguments = Util.SplitString(text)
	local commandName = table.remove(arguments, 1)
	local commandObject = self.Registry:GetCommand(commandName)

	if commandObject then
		-- No need to continue splitting when there are no more arguments. We'll just mash any additional arguments into the last one.
		arguments = Util.MashExcessArguments(arguments, #commandObject.Args)

		-- Create the CommandContext and parse it.
		local command = Command.new({
			Dispatcher = self,
			Text = text,
			CommandObject = commandObject,
			Alias = commandName,
			Executor = executor,
			Arguments = arguments,
			Data = data
		})
		local success, errorText = command:Parse(allowIncompleteArguments)

		if success then
			return command
		else
			return false, errorText
		end
	else
		return false, "Invalid command. Use the help command to see all available commands."
	end
end

--- A helper that evaluates and runs the command in one go.
-- Either returns any validation errors as a string, or the output of the command as a string. Definitely a string, though.
function Dispatcher:EvaluateAndRun (text, executor, options)
	executor = executor or Players.LocalPlayer
	options = options or {}

	if RunService:IsClient() and options.IsHuman then
		self:PushHistory(text)
	end

	local command, errorText = self:Evaluate(text, executor, nil, options.Data)

	if not command then
		return errorText
	end

	local ok, out = pcall(function()
		local valid, errorText = command:Validate(true) -- luacheck: ignore

		if not valid then
			return errorText
		end

		return command:Run() or "Command executed."
	end)

	if not ok then
		warn(("Error occurred while evaluating command string %q\n%s"):format(text, out))
	end

	return ok and out or "An error occurred while running this command."
end

--- Send text as the local user to remote server to be evaluated there.
function Dispatcher:Send (text, data)
	if RunService:IsClient() == false then
		error("Dispatcher:Send can only be called from the client.")
	end

	return self.Cmdr.RemoteFunction:InvokeServer(text, {
		Data = data
	})
end

--- Invoke a command programmatically as the local user e.g. from a settings menu
-- Command should be the first argument, all arguments afterwards should be the arguments to the command.
function Dispatcher:Run (...)
	if not Players.LocalPlayer then
		error("Dispatcher:Run can only be called from the client.")
	end

	local args = {...}
	local text = args[1]

	for i = 2, #args do
		text = text .. " " .. tostring(args[i])
	end

	local command, errorText = self:Evaluate(text, Players.LocalPlayer)

	if not command then
		error(errorText) -- We do a full-on error here since this is code-invoked and they should know better.
	end

	local success, errorText = command:Validate(true) -- luacheck: ignore

	if not success then
		error(errorText)
	end

	return command:Run()
end

--- Runs hooks matching name and returns nil for ok or a string for cancellation
function Dispatcher:RunHooks(hookName, ...)
	if not self.Registry.Hooks[hookName] then
		error(("Invalid hook name: %q"):format(hookName), 2)
	end

	for _, hook in ipairs(self.Registry.Hooks[hookName]) do
		local value = hook.callback(...)

		if value ~= nil then
			return tostring(value)
		end
	end
end

function Dispatcher:PushHistory(text)
	assert(RunService:IsClient(), "PushHistory may only be used from the client.")

	local history = self:GetHistory()

	-- Remove duplicates
	if Util.TrimString(text) == "" or text == history[#history] then
		return
	end

	history[#history + 1] = text

	TeleportService:SetTeleportSetting(HISTORY_SETTING_NAME, history)
end

function Dispatcher:GetHistory()
	assert(RunService:IsClient(), "GetHistory may only be used from the client.")

	return TeleportService:GetTeleportSetting(HISTORY_SETTING_NAME) or {}
end

return function (cmdr)
	Dispatcher.Cmdr = cmdr
	Dispatcher.Registry = cmdr.Registry

	return Dispatcher
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="95">
              <Properties>
                <string name="Name">Registry</string>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Util = require(script.Parent.Util)

--- The registry keeps track of all the commands and types that Cmdr knows about.
local Registry = {
	TypeMethods = Util.MakeDictionary({"Transform", "Validate", "Autocomplete", "Parse", "DisplayName", "Listable", "ValidateOnce", "Prefixes"});
	CommandMethods = Util.MakeDictionary({"Name", "Aliases", "AutoExec", "Description", "Args", "Run", "ClientRun", "Data", "Group"});
	CommandArgProps = Util.MakeDictionary({"Name", "Type", "Description", "Optional", "Default"});
	Types = {};
	TypeAliases = {};
	Commands = {};
	CommandsArray = {};
	Cmdr = nil;
	Hooks = {
		BeforeRun = {};
		AfterRun = {}
	};
	Stores = setmetatable({}, {
		__index = function (self, k)
			self[k] = {}
			return self[k]
		end
	});
	AutoExecBuffer = {};
}

--- Registers a type in the system.
-- name: The type Name. This must be unique.
function Registry:RegisterType (name, typeObject)
	if not name or not typeof(name) == "string" then
		error("Invalid type name provided: nil")
	end

	if not name:find("^[%d%l]%w*$") then
		error(('Invalid type name provided: "%s", type names must be alphanumeric and start with a lower-case letter or a digit.'):format(name))
	end

	for key in pairs(typeObject) do
		if self.TypeMethods[key] == nil then
			error("Unknown key/method in type \"" .. name .. "\": " .. key)
		end
	end

	if self.Types[name] ~= nil then
		error(('Type "%s" has already been registered.'):format(name))
	end

	typeObject.Name = name
	typeObject.DisplayName = typeObject.DisplayName or name

	self.Types[name] = typeObject

	if typeObject.Prefixes then
		self:RegisterTypePrefix(name, typeObject.Prefixes)
	end
end

function Registry:RegisterTypePrefix (name, union)
	if not self.TypeAliases[name] then
		self.TypeAliases[name] = name
	end

	self.TypeAliases[name] = ("%s %s"):format(self.TypeAliases[name], union)
end

function Registry:RegisterTypeAlias (name, alias)
	assert(self.TypeAliases[name] == nil, ("Type alias %s already exists!"):format(alias))
	self.TypeAliases[name] = alias
end

--- Helper method that registers types from all module scripts in a specific container.
function Registry:RegisterTypesIn (container)
	for _, object in pairs(container:GetChildren()) do
		if object:IsA("ModuleScript") then
			object.Parent = self.Cmdr.ReplicatedRoot.Types

			require(object)(self)
		else
			self:RegisterTypesIn(object)
		end
	end
end

-- These are exactly the same thing. No one will notice. Except for you, dear reader.
Registry.RegisterHooksIn = Registry.RegisterTypesIn

--- Registers a command based purely on its definition.
-- Prefer using Registry:RegisterCommand for proper handling of server/client model.
function Registry:RegisterCommandObject (commandObject, fromCmdr)
	for key in pairs(commandObject) do
		if self.CommandMethods[key] == nil then
			error("Unknown key/method in command " .. (commandObject.Name or "unknown command") .. ": " .. key)
		end
	end

	if commandObject.Args then
		for i, arg in pairs(commandObject.Args) do
			for key in pairs(arg) do
				if self.CommandArgProps[key] == nil then
					error(('Unknown propery in command "%s" argument #%d: %s'):format(commandObject.Name or "unknown", i, key))
				end
			end
		end
	end

	if not fromCmdr and RunService:IsClient() and commandObject.Run then
		warn(commandObject.Name, "command has `Run` in its command definition; prefer using `ClientRun` for new work.")
	end

	if commandObject.AutoExec and RunService:IsClient() then
		table.insert(self.AutoExecBuffer, commandObject.AutoExec)
		self:FlushAutoExecBufferDeferred()
	end

	-- Unregister the old command if it exists...
	local oldCommand = self.Commands[commandObject.Name:lower()]
	if oldCommand and oldCommand.Aliases then
		for _, alias in pairs(oldCommand.Aliases) do
			self.Commands[alias:lower()] = nil
		end
	elseif not oldCommand then
		self.CommandsArray[#self.CommandsArray + 1] = commandObject
	end

	self.Commands[commandObject.Name:lower()] = commandObject

	if commandObject.Aliases then
		for _, alias in pairs(commandObject.Aliases) do
			self.Commands[alias:lower()] = commandObject
		end
	end
end

--- Registers a command definition and its server equivalent.
-- Handles replicating the definition to the client.
function Registry:RegisterCommand (commandScript, commandServerScript, filter)
	local commandObject = require(commandScript)

	if commandServerScript then
		commandObject.Run = require(commandServerScript)
	end

	if filter and not filter(commandObject) then
		return
	end

	self:RegisterCommandObject(commandObject)

	commandScript.Parent = self.Cmdr.ReplicatedRoot.Commands
end

--- A helper method that registers all commands inside a specific container.
function Registry:RegisterCommandsIn (container, filter)
	local skippedServerScripts = {}
	local usedServerScripts = {}

	for _, commandScript in pairs(container:GetChildren()) do
		if commandScript:IsA("ModuleScript") then
			if not commandScript.Name:find("Server") then
				local serverCommandScript = container:FindFirstChild(commandScript.Name .. "Server")

				if serverCommandScript then
					usedServerScripts[serverCommandScript] = true
				end

				self:RegisterCommand(commandScript, serverCommandScript, filter)
			else
				skippedServerScripts[commandScript] = true
			end
		else
			self:RegisterCommandsIn(commandScript, filter)
		end
	end

	for skippedScript in pairs(skippedServerScripts) do
		if not usedServerScripts[skippedScript] then
			warn("Command script " .. skippedScript.Name .. " was skipped because it has 'Server' in its name, and has no equivalent shared script.")
		end
	end
end

--- Registers the default commands, with an optional filter function or array of groups.
function Registry:RegisterDefaultCommands (arrayOrFunc)
	local isArray = type(arrayOrFunc) == "table"

	if isArray then
		arrayOrFunc = Util.MakeDictionary(arrayOrFunc)
	end

	self:RegisterCommandsIn(self.Cmdr.DefaultCommandsFolder, isArray and function (command)
		return arrayOrFunc[command.Group] or false
	end or arrayOrFunc)
end

--- Gets a command definition by name. (Can be an alias)
function Registry:GetCommand (name)
	name = name or ""
	return self.Commands[name:lower()]
end

--- Returns a unique array of all registered commands (not including aliases)
function Registry:GetCommands ()
	return self.CommandsArray
end

--- Returns an array of the names of all registered commands (not including aliases)
function Registry:GetCommandsAsStrings ()
	local commands = {}

	for _, command in pairs(self.CommandsArray) do
		commands[#commands + 1] = command.Name
	end

	return commands
end

--- Gets a type definition by name.
function Registry:GetType (name)
	return self.Types[name]
end

--- Returns a type name, parsing aliases.
function Registry:GetTypeName (name)
	return self.TypeAliases[name] or name
end

--- Adds a hook to be called when any command is run
function Registry:RegisterHook(hookName, callback, priority)
	if not self.Hooks[hookName] then
		error(("Invalid hook name: %q"):format(hookName), 2)
	end

	table.insert(self.Hooks[hookName], { callback = callback; priority = priority or 0; } )
	table.sort(self.Hooks[hookName], function(a, b) return a.priority < b.priority end)
end

-- Backwards compatability (deprecated)
Registry.AddHook = Registry.RegisterHook

--- Returns the store with the given name
-- Used for commands that require persistent state, like bind or ban
function Registry:GetStore(name)
	return self.Stores[name]
end

--- Calls self:FlushAutoExecBuffer at the end of the frame
function Registry:FlushAutoExecBufferDeferred()
	if self.AutoExecFlushConnection then
		return
	end

	self.AutoExecFlushConnection = RunService.Heartbeat:Connect(function()
		self.AutoExecFlushConnection:Disconnect()
		self.AutoExecFlushConnection = nil
		self:FlushAutoExecBuffer()
	end)
end

--- Runs all pending auto exec commands in Registry.AutoExecBuffer
function Registry:FlushAutoExecBuffer()
	for _, commandGroup in ipairs(self.AutoExecBuffer) do
		for _, command in ipairs(commandGroup) do
			self.Cmdr.Dispatcher:EvaluateAndRun(command)
		end
	end
end

return function (cmdr)
	Registry.Cmdr = cmdr

	return Registry
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="96">
              <Properties>
                <string name="Name">Util</string>
                <string name="Source"><![CDATA[local TextService = game:GetService("TextService")

local Util = {}

--- Takes an array and flips its values into dictionary keys with value of true.
function Util.MakeDictionary(array)
	local dictionary = {}

	for i = 1, #array do
		dictionary[array[i]] = true
	end

	return dictionary
end

-- Takes an array of instances and returns (array<names>, array<instances>)
local function transformInstanceSet(instances)
	local names = {}

	for i = 1, #instances do
		names[i] = instances[i].Name
	end

	return names, instances
end

--- Returns a function that is a fuzzy finder for the specified set or container.
-- Can pass an array of strings, array of instances, array of EnumItems,
-- array of dictionaries with a Name key or an instance (in which case its children will be used)
-- Exact matches will be inserted in the front of the resulting array
function Util.MakeFuzzyFinder(setOrContainer)
	local names
	local instances = {}

	if typeof(setOrContainer) == "Enum" then
		setOrContainer = setOrContainer:GetEnumItems()
	end

	if typeof(setOrContainer) == "Instance" then
		names, instances = transformInstanceSet(setOrContainer:GetChildren())
	elseif typeof(setOrContainer) == "table" then
		if
			typeof(setOrContainer[1]) == "Instance" or typeof(setOrContainer[1]) == "EnumItem" or
				(typeof(setOrContainer[1]) == "table" and typeof(setOrContainer[1].Name) == "string")
		 then
			names, instances = transformInstanceSet(setOrContainer)
		elseif type(setOrContainer[1]) == "string" then
			names = setOrContainer
		elseif setOrContainer[1] ~= nil then
			error("MakeFuzzyFinder only accepts tables of instances or strings.")
		else
			names = {}
		end
	else
		error("MakeFuzzyFinder only accepts a table, Enum, or Instance.")
	end

	-- Searches the set (checking exact matches first)
	return function(text, returnFirst)
		local results = {}

		for i, name in pairs(names) do
			local value = instances and instances[i] or name

			-- Continue on checking for non-exact matches...
			-- Still need to loop through everything, even on returnFirst, because possibility of an exact match.
			if name:lower() == text:lower() then
				if returnFirst then
					return value
				else
					table.insert(results, 1, value)
				end
			elseif name:lower():sub(1, #text) == text:lower() then
				results[#results + 1] = value
			end
		end

		if returnFirst then
			return results[1]
		end

		return results
	end
end

--- Takes an array of instances and returns an array of those instances' names.
function Util.GetNames(instances)
	local names = {}

	for i = 1, #instances do
		names[i] = instances[i].Name or tostring(instances[i])
	end

	return names
end

--- Splits a string using a simple separator (no quote parsing)
function Util.SplitStringSimple(inputstr, sep)
	if sep == nil then
		sep = "%s"
	end
	local t = {}
	local i = 1
	for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do
		t[i] = str
		i = i + 1
	end
	return t
end

local function charCode(n)
	return utf8.char(tonumber(n, 16))
end

-- Discard any excess return values
local function first(x)
	return x
end

--- Parses escape sequences into their fully qualified characters
function Util.ParseEscapeSequences(text)
	return text:gsub("\\(.)", {
		t = "\t";
		n = "\n";
	})
	:gsub("\\u(%x%x%x%x)", charCode)
	:gsub("\\x(%x%x)", charCode)
end

local function encodeControlChars(text)
	return first(
		text
		:gsub("\\\\", string.char(17))
		:gsub("\\\"", string.char(18))
		:gsub("\\'", string.char(19))
	)
end

local function decodeControlChars(text)
	return first(
		text
		:gsub(string.char(17), "\\")
		:gsub(string.char(18), "\"")
		:gsub(string.char(19), "'")
	)
end

--- Splits a string by space but taking into account quoted sequences which will be treated as a single argument.
function Util.SplitString(text, max)
	text = encodeControlChars(text)
	max = max or math.huge
	local t = {}
	local spat, epat, buf, quoted = [=[^(['"])]=], [=[(['"])$]=]
	for str in text:gmatch("%S+") do
		str = Util.ParseEscapeSequences(str)
		local squoted = str:match(spat)
		local equoted = str:match(epat)
		local escaped = str:match([=[(\*)['"]$]=])
		if squoted and not quoted and not equoted then
			buf, quoted = str, squoted
		elseif buf and equoted == quoted and #escaped % 2 == 0 then
			str, buf, quoted = buf .. " " .. str, nil, nil
		elseif buf then
			buf = buf .. " " .. str
		end
		if not buf then
			t[#t + (#t > max and 0 or 1)] = decodeControlChars(str:gsub(spat, ""):gsub(epat, ""))
		end
	end

	if buf then
		t[#t + (#t > max and 0 or 1)] = decodeControlChars(buf)
	end

	return t
end

--- Takes an array of arguments and a max value.
-- Any indicies past the max value will be appended to the last valid argument.
function Util.MashExcessArguments(arguments, max)
	local t = {}
	for i = 1, #arguments do
		if i > max then
			t[max] = ("%s %s"):format(t[max] or "", arguments[i])
		else
			t[i] = arguments[i]
		end
	end
	return t
end

--- Trims whitespace from both sides of a string.
function Util.TrimString(s)
	return s:match "^%s*(.-)%s*$"
end

--- Returns the text bounds size based on given text, label (from which properties will be pulled), and optional Vector2 container size.
function Util.GetTextSize(text, label, size)
	return TextService:GetTextSize(text, label.TextSize, label.Font, size or Vector2.new(label.AbsoluteSize.X, 0))
end

--- Makes an Enum type.
function Util.MakeEnumType(name, values)
	local findValue = Util.MakeFuzzyFinder(values)
	return {
		Validate = function(text)
			return findValue(text, true) ~= nil, ("Value %q is not a valid %s."):format(text, name)
		end,
		Autocomplete = function(text)
			local list = findValue(text)
			return type(list[1]) ~= "string" and Util.GetNames(list) or list
		end,
		Parse = function(text)
			return findValue(text, true)
		end
	}
end

--- Parses a prefixed union type argument (such as %Team)
function Util.ParsePrefixedUnionType(typeValue, rawValue)
	local split = Util.SplitStringSimple(typeValue)

	-- Check prefixes in order from longest to shortest
	local types = {}
	for i = 1, #split, 2 do
		types[#types + 1] = {
			prefix = split[i - 1] or "",
			type = split[i]
		}
	end

	table.sort(
		types,
		function(a, b)
			return #a.prefix > #b.prefix
		end
	)

	for i = 1, #types do
		local t = types[i]

		if rawValue:sub(1, #t.prefix) == t.prefix then
			return t.type, rawValue:sub(#t.prefix + 1), t.prefix
		end
	end
end

--- Creates a listable type from a singlular type
function Util.MakeListableType(type, override)
	local listableType = {
		Listable = true,
		Transform = type.Transform,
		Validate = type.Validate,
		Autocomplete = type.Autocomplete,
		Parse = function(...)
			return {type.Parse(...)}
		end
	}

	if override then
		for key, value in pairs(override) do
			listableType[key] = value
		end
	end

	return listableType
end

local function encodeCommandEscape(text)
	return first(text:gsub("\\%$", string.char(20)))
end

local function decodeCommandEscape(text)
	return first(text:gsub(string.char(20), "$"))
end

--- Runs embedded commands and replaces them
function Util.RunEmbeddedCommands(dispatcher, str)
	str = encodeCommandEscape(str)

	local results = {}
	-- We need to do this because you can't yield in the gsub function
	for text in str:gmatch("$(%b{})") do
		local doQuotes = true
		local commandString = text:sub(2, #text-1)

		if commandString:match("^{.+}$") then -- Allow double curly for literal replacement
			doQuotes = false
			commandString = commandString:sub(2, #commandString-1)
		end

		results[text] = dispatcher:EvaluateAndRun(commandString)

		if doQuotes and results[text]:find("%s") then
			results[text] = string.format("%q", results[text])
		end
	end

	return decodeCommandEscape(str:gsub("$(%b{})", results))
end

--- Replaces arguments in the format $1, $2, $something with whatever the
-- given function returns for it.
function Util.SubstituteArgs(str, replace)
	str = encodeCommandEscape(str)
	-- Convert numerical keys to strings
	if type(replace) == "table" then
		for i = 1, #replace do
			local k = tostring(i)
			replace[k] = replace[i]

			if replace[k]:find("%s") then
				replace[k] = string.format("%q", replace[k])
			end
		end
	end
	return decodeCommandEscape(str:gsub("$(%w+)", replace))
end

--- Creates an alias command
function Util.MakeAliasCommand(name, commandString)
	return {
		Name = name,
		Aliases = {},
		Description = commandString,
		Group = "UserAlias",
		Args = {
			{
				Type = "string",
				Name = "Argument 1",
				Description = "",
				Default = ""
			},
			{
				Type = "string",
				Name = "Argument 2",
				Description = "",
				Default = ""
			},
			{
				Type = "string",
				Name = "Argument 3",
				Description = "",
				Default = ""
			},
			{
				Type = "string",
				Name = "Argument 4",
				Description = "",
				Default = ""
			},
			{
				Type = "string",
				Name = "Argument 5",
				Description = "",
				Default = ""
			}
		},
		Run = function(context, ...)
			local args = {...}
			local commands = Util.SplitStringSimple(commandString, "&&")

			for i, command in ipairs(commands) do
				local output = context.Dispatcher:EvaluateAndRun(
					Util.RunEmbeddedCommands(
						context.Dispatcher,
						Util.SubstituteArgs(command, args)
					)
				)
				if i == #commands then
					return output -- return last command's output
				else
					context:Reply(output)
				end
			end

			return ""
		end
	}
end

--- Makes a type that contains a sequence, e.g. Vector3 or Color3
function Util.MakeSequenceType(options)
	options = options or {}

	assert(options.Parse ~= nil or options.Constructor ~= nil, "MakeSequenceType: Must provide one of: Constructor, Parse")

	options.TransformEach = options.TransformEach or function(...)
		return ...
	end

	options.ValidateEach = options.ValidateEach or function()
		return true
	end

	return {
		Prefixes = options.Prefixes;

		Transform = function (text)
			return Util.Map(Util.SplitPrioritizedDelimeter(text, {",", "%s"}), function(value)
				return options.TransformEach(value)
			end)
		end;

		Validate = function (components)
			if options.Length and #components > options.Length then
				return false, ("Maximum of %d values allowed in sequence"):format(options.Length)
			end

			for i = 1, options.Length or #components do
				local valid, reason = options.ValidateEach(components[i], i)

				if not valid then
					return false, reason
				end
			end

			return true
		end;

		Parse = options.Parse or function(components)
			return options.Constructor(unpack(components))
		end
	}
end

--- Splits a string by a single delimeter chosen from the given set.
-- The first matching delimeter from the set becomes the split character.
function Util.SplitPrioritizedDelimeter(text, delimeters)
	for i, delimeter in ipairs(delimeters) do
		if text:find(delimeter) or i == #delimeters then
			return Util.SplitStringSimple(text, delimeter)
		end
	end
end

--- Maps values of an array through a callback and returns an array of mapped values
function Util.Map(array, callback)
	local results = {}

	for i, v in ipairs(array) do
		results[i] = callback(v, i)
	end

	return results
end

--- Maps arguments #2-n through callback and returns values as tuple
function Util.Each(callback, ...)
	local results = {}
	for i, value in ipairs({...}) do
		results[i] = callback(value)
	end
	return unpack(results)
end

--- Emulates tabstops with spaces
function Util.EmulateTabstops(text, tabWidth)
	local result = ""
	for i = 1, #text do
		local char = text:sub(i, i)

		result = result .. (char == "\t" and string.rep(" ", tabWidth - #result % tabWidth) or char)
	end
	return result
end

return Util
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>